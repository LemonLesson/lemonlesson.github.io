<!DOCTYPE html>
<html  lang="en">
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 4.2.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>柠檬资源社</title>


    <meta property="og:type" content="website">
<meta property="og:title" content="柠檬资源社">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="柠檬资源社">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/images/og_image.png">
<meta property="article:author" content="Robynn-D">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/og_image.png">







<link rel="icon" href="/images/favicon.svg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    
    
    
    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.svg" alt="柠檬资源社" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">Home</a>
                
                <a class="navbar-item"
                href="/archives">Archives</a>
                
                <a class="navbar-item"
                href="/categories">Categories</a>
                
                <a class="navbar-item"
                href="/tags">Tags</a>
                
                <a class="navbar-item"
                href="/about">About</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    <a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                
                <a class="navbar-item search" title="Search" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-6-widescreen has-order-2 column-main">
    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-02T06:48:51.082Z">2019-08-02</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    2 minutes read (About 318 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/02/Dubbo%E9%9D%A2%E8%AF%95%E9%A2%98%E9%94%A6%E9%9B%86/">Dubbo面试题锦集</a>
            
        </h1>
        <div class="content">
            <h1 id="Dubbo面试题锦集"><a href="#Dubbo面试题锦集" class="headerlink" title="Dubbo面试题锦集"></a>Dubbo面试题锦集</h1><p>1、默认使用的是什么通信框架，还有别的选择吗?</p>
<p>2、服务调用是阻塞的吗？</p>
<p>3、一般使用什么注册中心？还有别的选择吗？</p>
<p>4、默认使用什么序列化框架，你知道的还有哪些？</p>
<p>5、服务提供者能实现失效踢出是什么原理？</p>
<p>6、服务上线怎么不影响旧版本？</p>
<p>7、如何解决服务调用链过长的问题？</p>
<p>8、说说核心的配置有哪些？</p>
<p>9、dubbo推荐用什么协议？</p>
<p>10、同一个服务多个注册的情况下可以直连某一个服务吗？</p>
<p>11、画一画服务注册与发现的流程图</p>
<p>12、集群容错怎么做？</p>
<p>13、在使用过程中都遇到了些什么问题？</p>
<p>14、dubbo和dubbox之间的区别？</p>
<p>15、你还了解别的分布式框架吗？</p>
<p>以上不完全总结了dubbo面试过程中的一些问题，也是实际使用过程中经常会注意到的地方，虽然dubbo没有更新了，但国内使用还是挺多，里面的实现思想还是挺好的，也值得学习。</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-02T06:48:51.082Z">2019-08-02</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    4 minutes read (About 529 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/02/Java%20Map%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/">Java Map集合面试题汇总</a>
            
        </h1>
        <div class="content">
            <h1 id="Java-Map集合面试题汇总"><a href="#Java-Map集合面试题汇总" class="headerlink" title="Java Map集合面试题汇总"></a>Java Map集合面试题汇总</h1><p>1、 你都知道哪些常用的Map集合?<br>    - HashMap、HashTable、LinkedHashMap、ConcurrentHashMap。 </p>
<p>2、Collection集合接口和Map接口有什么关系？<br>    - 没关系，Collection是List、Set父接口不是Map父接口。</p>
<p>3、HashMap是线程安全的吗？线程安全的Map都有哪些？性能最好的是哪个？<br>    - HashMap不是线程安全的。线程安全的有HashTable、ConcurrentHashMap、SynchronizedMap，性能最好的是ConcurrentHashMap。</p>
<p>4、使用HashMap有什么性能问题吗？<br>    - 使用HashMap要注意避免集合的扩容，它会很耗性能，根据元素的数量给它一个初始大小的值。 </p>
<p>5、HashMap的数据结构是怎样的？默认大小是多少？内部是怎么扩容的？<br>    - HashMap是数组和链表组成的，默认大小为16，当hashmap中的元素个数超过数组大小*loadFactor（默认值为0.75）时就会把数组的大小扩展为原来的两倍大小，然后重新计算每个元素在数组中的位置。</p>
<p>6、怎么按添加顺序存储元素？怎么按A-Z自然顺序存储元素？怎么自定义排序？<br>    - 按添加顺序使用LinkedHashMap,按自然顺序使用TreeMap,自定义排序TreeMap(Comparetor c)。 </p>
<p>7、HashMap的链表结构设计是用来解决什么问题的？<br>    - HashMap的链表结构设计是用来解决key的hash冲突问题的。 </p>
<p>8、HashMap的键、值可以为NULL吗？HashTable呢？<br>    - HashMap的键值都可以为NULL，HashTable不行。 </p>
<p>9、HashMap使用对象作为key，如果hashcode相同会怎么处理？<br>    - key的hash冲突，如果key equals一致将会覆盖值，不一致就会将值存储在key对应的链表中。</p>
<p>10、HashMap中的get操作是什么原理？<br>    - 先根据key的hashcode值找到对应的链表，再循环链表，根据key的hash是否相同且key的==或者equals比较操作找到对应的值。</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-02T06:48:51.082Z">2019-08-02</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    2 minutes read (About 369 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/02/Java%20List%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/">Java List面试题汇总</a>
            
        </h1>
        <div class="content">
            <h1 id="Java-List面试题汇总"><a href="#Java-List面试题汇总" class="headerlink" title="Java List面试题汇总"></a>Java List面试题汇总</h1><p>1、你知道的List都有哪些？<br>    - ArrayList、LinkedList、Vector等。 </p>
<p>2、List和Vector有什么区别？<br>    - Vector是List接口下线程安全的集合。 </p>
<p>3、List是有序的吗？<br>    -     List是有序的。 </p>
<p>4、ArrayList和LinkedList的区别？分别用在什么场景？<br>    - ArrayList和LinkedList数据结构不一样，前者用在查询较多的场合，后者适用于插入较多的场合。 </p>
<p>5、ArrayList和LinkedList的底层数据结构是什么？<br>    - ArrayList使用的是数组结构，LinkedList使用的是链表结构。 </p>
<p>6、ArrayList默认大小是多少，是如何扩容的？<br>    - Jdk1.7之前ArrayList默认大小是10，JDK1.7之后是0，JDK差异，每次约按1.5倍扩容。</p>
<p>7、List是线程安全的吗？如果要线程安全要怎么做？<br>    - List中的Vector才是线程安全的，其他要实现线程安全使用工具类Collections.synchronizedList(new ArrayList())方法。</p>
<p>8、怎么给List排序？<br>    - 使用List自身的sort方法，或者使用Collections.sort(list)方法; </p>
<p>9、Arrays.asList方法后的List可以扩容吗？<br>    - Arrays.asList使用的是final数组，并且不支持add方法，不支持扩容。</p>
<p>10、List和Array之间如何互相转换？<br>    - List&gt;Array使用toArray方法，Array&gt;List使用Arrays.asList(array)方法，由于它是固定的，不固定的可以使用new ArrayList(Arrays.asList(array))。</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-02T06:48:51.082Z">2019-08-02</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    7 hours read (About 60103 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/02/Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89/">Java 开发必备面试题详解（技术+人事）</a>
            
        </h1>
        <div class="content">
            <h1 id="Java-开发必备面试题详解（技术-人事）"><a href="#Java-开发必备面试题详解（技术-人事）" class="headerlink" title="Java 开发必备面试题详解（技术+人事）"></a>Java 开发必备面试题详解（技术+人事）</h1><p>大家好，我是宁楠，之前出了一个达人课《Spring MVC 实战手册》，在跟读者的交流过程中，不断有朋友谈到关于面试的问题，可见大家对这部分的需求还是比较大的。所以我就将平时积累的 Java 面试题进行详细地筛选，并在某些地方加入解题思路和对知识点的理解，整理成文章分享给大家。共计 211 道题，涉及到 Java 面试的高频考点，以及相关人事问题，希望对大家的求职面试有所帮助。</p>
<h3 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><p><strong>1. 判断身份证：要么是 15 位，要么是 18 位，最后一位可以为字母，并写程序提出其中的年月日。</strong></p>
<blockquote>
<p>我们可以用正则表达式来定义复杂的字符串格式，如 <code>\d{17}[0-9a-zA-Z]|\d{14}[0-9a-zA-Z]</code> 可以用来判断是否为合法的 15 位或 18 位身份证号码。  </p>
</blockquote>
<blockquote>
<p>因为 15 位和 18 位的身份证号码都是从 7 位到第 12 位为身份证为日期类型。这样我们可以设计出更精确的正则模式，使身份证号的日期合法，这样我们的正则模式可以进一步将日期部分的正则修改为 <code>[12][0-9]{3}[01][0-9][123][0-9]</code> ，当然可以更精确的设置日期。  </p>
</blockquote>
<blockquote>
<p>在 JDK 的 java.util.Regex 包中有实现正则的类，Pattern 和 Matcher。以下是实现代码：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.P attern;</span><br><span class="line">public class RegexTest &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 测试是否为合法的身份证号码</span><br><span class="line">        String[] strs &#x3D; &#123; &quot;130681198712092019&quot;, &quot;13068119871209201x&quot;,</span><br><span class="line">                &quot;13068119871209201&quot;, &quot;123456789012345&quot;, &quot;12345678901234x&quot;,</span><br><span class="line">                &quot;1234567890123&quot; &#125;;</span><br><span class="line">        Pattern p1 &#x3D; Pattern.compile(&quot;(\\d&#123;17&#125;[0-9a-zA-Z]|\\d&#123;14&#125;[0-9a-zA-Z])&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">            Matcher matcher &#x3D; p1.matcher(strs[i]);</span><br><span class="line">            System.out.println(strs[i] + &quot;:&quot; + matcher.matches());</span><br><span class="line">        &#125;</span><br><span class="line">        Pattern p2 &#x3D; Pattern.compile(&quot;\\d&#123;6&#125;(\\d&#123;8&#125;).*&quot;); &#x2F;&#x2F; 用于提取出生日字符串</span><br><span class="line">        Pattern p3 &#x3D; Pattern.compile(&quot;(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)&quot;);&#x2F;&#x2F; 用于将生日字符串进行分解为年月日</span><br><span class="line">        for (int i &#x3D; 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">            Matcher matcher &#x3D; p2.matcher(strs[i]);</span><br><span class="line">            boolean b &#x3D; matcher.find();</span><br><span class="line">            if (b) &#123;</span><br><span class="line">                String s &#x3D; matcher.group(1);</span><br><span class="line">                Matcher matcher2 &#x3D; p3.matcher(s);</span><br><span class="line">                if (matcher2.find()) &#123;</span><br><span class="line">                    System.out</span><br><span class="line">                            .println(&quot;生日为&quot; + matcher2.group(1) + &quot;年&quot;</span><br><span class="line">                                    + matcher2.group(2) + &quot;月&quot;</span><br><span class="line">                                    + matcher2.group(3) + &quot;日&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 说明生活中遇到的二叉树，用 Java 实现二叉树。</strong></p>
<blockquote>
<p>这是组合设计模式。  </p>
</blockquote>
<blockquote>
<p>我有很多个（假设 10 万个）数据要保存起来，以后还需要从保存的这些数据中检索是否存在某个数据。假如存在数组中，那么，碰巧要找的数字位于 99999 那个地方，查找的速度将很慢，因为要从第 1 个依次往后取，取出来后进行比较。平衡二叉树（构建平衡二叉树需要先排序，我们这里就不作考虑了）可以很好地解决这个问题，但二叉树的遍历（前序、中序、后序）效率要比数组低很多，代码如下：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line">    public int value;</span><br><span class="line">    public Node left;</span><br><span class="line">    public Node right;</span><br><span class="line">    public void store(int value)</span><br><span class="line">    &#123;</span><br><span class="line">        if(value&lt;this.value)</span><br><span class="line">        &#123;</span><br><span class="line">            if(left &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                left &#x3D; new Node();</span><br><span class="line">                left.value&#x3D;value;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                left.store(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(value&gt;this.value)</span><br><span class="line">        &#123;</span><br><span class="line">            if(right &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                right &#x3D; new Node();</span><br><span class="line">                right.value&#x3D;value;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                right.store(value);</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean find(int value)</span><br><span class="line">    &#123;   </span><br><span class="line">        System.out.println(&quot;happen &quot; + this.value);</span><br><span class="line">        if(value &#x3D;&#x3D; this.value)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(value&gt;this.value)</span><br><span class="line">        &#123;</span><br><span class="line">            if(right &#x3D;&#x3D; null) return false;</span><br><span class="line">            return right.find(value);</span><br><span class="line">        &#125;else</span><br><span class="line">        &#123;</span><br><span class="line">            if(left &#x3D;&#x3D; null) return false;</span><br><span class="line">            return left.find(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public  void preList()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(this.value + &quot;,&quot;);</span><br><span class="line">        if(left!&#x3D;null) left.preList();</span><br><span class="line">        if(right!&#x3D;null) right.preList();</span><br><span class="line">    &#125;</span><br><span class="line">    public void middleList()</span><br><span class="line">    &#123;</span><br><span class="line">        if(left!&#x3D;null) left.preList();</span><br><span class="line">        System.out.print(this.value + &quot;,&quot;);</span><br><span class="line">        if(right!&#x3D;null) right.preList();        </span><br><span class="line">    &#125;</span><br><span class="line">    public void afterList()</span><br><span class="line">    &#123;</span><br><span class="line">        if(left!&#x3D;null) left.preList();</span><br><span class="line">        if(right!&#x3D;null) right.preList();</span><br><span class="line">        System.out.print(this.value + &quot;,&quot;);     </span><br><span class="line">    &#125;   </span><br><span class="line">    public static void main(String [] args)</span><br><span class="line">    &#123;</span><br><span class="line">        int [] data &#x3D; new int[20];</span><br><span class="line">        for(int i&#x3D;0;i&lt;data.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            data[i] &#x3D; (int)(Math.random()*100) + 1;</span><br><span class="line">            System.out.print(data[i] + &quot;,&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        Node root &#x3D; new Node();</span><br><span class="line">        root.value &#x3D; data[0];</span><br><span class="line">        for(int i&#x3D;1;i&lt;data.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            root.store(data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        root.find(data[19]);</span><br><span class="line">        root.preList();</span><br><span class="line">        System.out.println();</span><br><span class="line">        root.middleList();</span><br><span class="line">        System.out.println();       </span><br><span class="line">        root.afterList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 第 1 个人 10 岁，第 2 个比第 1 个人大 2 岁，依次递推，请用递归方式计算出第 8 个人多大？</strong></p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line">public class A1 &#123;</span><br><span class="line">    public static void main(String [] args)&#123;</span><br><span class="line">        System.out.println(computeAge(8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int computeAge(int n)&#123;</span><br><span class="line">        if(n&#x3D;&#x3D;1) return 10;</span><br><span class="line">        return computeAge(n-1) + 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void toBinary(int n,StringBuffer result)&#123;</span><br><span class="line">    if(n&#x2F;2 !&#x3D; 0)</span><br><span class="line">    toBinary(n&#x2F;2,result);</span><br><span class="line">    result.append(n%2);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 有一对兔子，从出生后第 3 个月起每个月都生一对兔子，小兔子长到第四个月后每个月又生一对兔子，假如兔子都不死，问第月的兔子总数为多少？</strong></p>
<blockquote>
<p>程序分析： 兔子的规律为数列 1,1,2,3,5,8,13,21…  </p>
</blockquote>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/7ddb5450-ee15-11e8-8b4e-7322b3314c0b" alt=""></p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class exp1 &#123;</span><br><span class="line">     public static void main(String args[]) &#123;</span><br><span class="line">          int i &#x3D; 0;</span><br><span class="line">          for (i &#x3D; 1; i &lt;&#x3D; 20; i++)</span><br><span class="line">               System.out.println(f(i));  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public static int f(int x) &#123;</span><br><span class="line">          if (x &#x3D;&#x3D; 1 || x &#x3D;&#x3D; 2)</span><br><span class="line">               return 1;   else</span><br><span class="line">               return f(x - 1) + f(x - 2);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class exp1 &#123;</span><br><span class="line">     public static void main(String args[]) &#123;</span><br><span class="line">          int i &#x3D; 0;</span><br><span class="line">          math mymath &#x3D; new math();</span><br><span class="line">          for (i &#x3D; 1; i &lt;&#x3D; 20; i++)    </span><br><span class="line">            System.out.println(mymath.f(i));</span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">class math &#123;</span><br><span class="line">     public int f(int x) &#123;</span><br><span class="line">          if (x &#x3D;&#x3D; 1 || x &#x3D;&#x3D; 2)</span><br><span class="line">               return 1;</span><br><span class="line">          else    </span><br><span class="line">            return f(x - 1) + f(x - 2);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 打印出所有的“水仙花数”。所谓“水仙花数”是指一个三位数，其各位数字立方和等于该数本身。例 如：153 是一个“水仙花数”，因为 153 = 1 的三次方＋5 的三次方＋3 的三次方。在 2000 以内的数字。</strong></p>
<blockquote>
<p>程序分析：利用 for 循环控制 100~999 个数，每个数分解出个位、十位、百位。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class exp2 &#123;</span><br><span class="line">     public static void main(String args[]) &#123;</span><br><span class="line">          int i &#x3D; 0;</span><br><span class="line">          math mymath &#x3D; new math();</span><br><span class="line">          for (i &#x3D; 100; i &lt;&#x3D; 999; i++)    </span><br><span class="line">            if (mymath.shuixianhua(i) &#x3D;&#x3D; true)</span><br><span class="line">                System.out.println(i);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">class math &#123;</span><br><span class="line">     public int f(int x) &#123;</span><br><span class="line">          if (x &#x3D;&#x3D; 1 || x &#x3D;&#x3D; 2)</span><br><span class="line">               return 1;</span><br><span class="line">          else    </span><br><span class="line">            return f(x - 1) + f(x - 2);</span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">     public boolean iszhishu(int x) &#123;</span><br><span class="line">          for (int i &#x3D; 2; i &lt;&#x3D; x &#x2F; 2; i++)    if (x % 2 &#x3D;&#x3D; 0)</span><br><span class="line">            return false;</span><br><span class="line">              return true;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    public boolean shuixianhua(int x) &#123;</span><br><span class="line">          int i &#x3D; 0, j &#x3D; 0, k &#x3D; 0;</span><br><span class="line">          i &#x3D; x &#x2F; 100;   j &#x3D; (x % 100) &#x2F; 10;</span><br><span class="line">          k &#x3D; x % 10;</span><br><span class="line">          if (x &#x3D;&#x3D; i * i * i + j * j * j + k * k * k)</span><br><span class="line">               return true;</span><br><span class="line">          else    return false;  </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6. 输入两个正整数 m 和 n，求其最大公约数和最小公倍数。</strong></p>
<blockquote>
<p>程序分析：利用辗除法。 最大公约数：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class CommonDivisor &#123;</span><br><span class="line">     public static void main(String args[]) &#123;  </span><br><span class="line">        commonDivisor(24, 32);</span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">    static int commonDivisor(int M, int N) &#123;</span><br><span class="line">          if (N &lt; 0 || M &lt; 0) &#123;    </span><br><span class="line">             System.out.println(&quot;ERROR!&quot;);</span><br><span class="line">                   return -1;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">        if (N &#x3D;&#x3D; 0) &#123;</span><br><span class="line">               System.out.println(&quot;the biggest common divisor is :&quot; + M);    return M;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">        return commonDivisor(N, M % N);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">最小公倍数和最大公约数：</span><br><span class="line">import java.util.Scanner;  </span><br><span class="line">public class CandC &#123;  </span><br><span class="line">    &#x2F;&#x2F; 下面的方法是求出最大公约数</span><br><span class="line">     public static int gcd(int m, int n) &#123;</span><br><span class="line">          while (true) &#123;</span><br><span class="line">               if ((m &#x3D; m % n) &#x3D;&#x3D; 0)     return n;</span><br><span class="line">               if ((n &#x3D; n % m) &#x3D;&#x3D; 0)</span><br><span class="line">                return m;</span><br><span class="line">          &#125;</span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> public static void main(String args[]) throws Exception &#123;  </span><br><span class="line">     &#x2F;&#x2F; 取得输入值</span><br><span class="line">      Scanner chin &#x3D; new Scanner(System.in);</span><br><span class="line">    int a &#x3D; chin.nextInt(), b &#x3D; chin.nextInt();   int a &#x3D; 23;</span><br><span class="line">      int b &#x3D; 32;</span><br><span class="line">      int c &#x3D; gcd(a, b);   </span><br><span class="line">    System.out.println(&quot;最小公倍数：&quot; + a * b &#x2F; c + &quot;\n最大公约数：&quot; + c);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>7. 输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。</strong></p>
<blockquote>
<p>程序分析：利用 while 语句，条件为输入的字符不为 ‘\n ‘。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;  </span><br><span class="line"></span><br><span class="line">public class ex7 &#123;</span><br><span class="line">     public static void main(String args[]) &#123;  </span><br><span class="line">        System.out.println(&quot;请输入字符串：&quot;);           </span><br><span class="line">        Scanner scan &#x3D; new Scanner(System.in);</span><br><span class="line">          String str &#x3D; scan.next();</span><br><span class="line">          String E1 &#x3D; &quot;[\u4e00-\u9fa5]&quot;;</span><br><span class="line">          String E2 &#x3D; &quot;[a-zA-Z]&quot;;</span><br><span class="line">          int countH &#x3D; 0;   </span><br><span class="line">        int countE &#x3D; 0;</span><br><span class="line">          char[] arrChar &#x3D; str.toCharArray();</span><br><span class="line">          String[] arrStr &#x3D; new String[arrChar.length];</span><br><span class="line">          for (int i &#x3D; 0; i &lt; arrChar.length; i++) &#123;</span><br><span class="line">               arrStr[i] &#x3D; String.valueOf(arrChar[i]);  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (String i : arrStr) &#123;</span><br><span class="line">               if (i.matches(E1)) &#123;</span><br><span class="line">                countH++;</span><br><span class="line">               &#125;if (i.matches(E2)) &#123;</span><br><span class="line">                    countE++;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;   </span><br><span class="line">        System.out.println(&quot;汉字的个数&quot; + countH);   System.out.println(&quot;字母的个数&quot; + countE);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>8. 求 s=a+aa+aaa+aaaa+aa…a 的值，其中 a 是一个数字。例如 2+22+222+2222+22222（此时共有 5 个数相加），几个数相加有键盘控制。</strong></p>
<blockquote>
<p>程序分析：关键是计算出每一项的值。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class Sumloop &#123;</span><br><span class="line">     public static void main(String[] args) throws IOException &#123;</span><br><span class="line">          int s &#x3D; 0;   </span><br><span class="line">        String output &#x3D; &quot;&quot;;</span><br><span class="line">          BufferedReader stadin &#x3D; new BufferedReader(new InputStreamReader(</span><br><span class="line">    System.in));   </span><br><span class="line">        System.out.println(&quot;请输入a的值&quot;);</span><br><span class="line">        String input &#x3D; stadin.readLine();   </span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; Integer.parseInt(input); i++) &#123;</span><br><span class="line">               output +&#x3D; input;</span><br><span class="line">               int a &#x3D; Integer.parseInt(output);</span><br><span class="line">               s +&#x3D; a;</span><br><span class="line">          &#125;   </span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import java.io.*;  </span><br><span class="line">public class Sumloop &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;   </span><br><span class="line">        int s &#x3D; 0;</span><br><span class="line">          int n;</span><br><span class="line">          int t &#x3D; 0;</span><br><span class="line">          BufferedReader stadin &#x3D; new BufferedReader(new InputStreamReader(</span><br><span class="line">    System.in));  </span><br><span class="line">        String input &#x3D; stadin.readLine();</span><br><span class="line">          n &#x3D; Integer.parseInt(input);</span><br><span class="line">         for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">               t &#x3D; t * 10 + n;</span><br><span class="line">               s &#x3D; s + t;   </span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">          System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>9. 一个数如果恰好等于它的因子之和，这个数就称为“完数”。例如 6 = 1＋2＋3。编程找出 1000 以内的所有完数。</strong></p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Wanshu &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          int s;</span><br><span class="line">          for (int i &#x3D; 1; i &lt;&#x3D; 1000; i++) &#123;</span><br><span class="line">               s &#x3D; 0;</span><br><span class="line">               for (int j &#x3D; 1; j &lt; i; j++)     </span><br><span class="line">                if (i % j &#x3D;&#x3D; 0)</span><br><span class="line">                 s &#x3D; s + j;</span><br><span class="line">                   if (s &#x3D;&#x3D; i)</span><br><span class="line">            System.out.print(i + &quot; &quot;);</span><br><span class="line">          &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>10. 有 1、2、3、4 个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</strong></p>
<blockquote>
<p>程序分析：可填在百位、十位、个位的数字都是 1、2、3、4。组成所有的排列后再去掉不满足条件的排列。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Wanshu &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;   </span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">          int j &#x3D; 0;</span><br><span class="line">          int k &#x3D; 0;</span><br><span class="line">          int t &#x3D; 0;</span><br><span class="line">          for (i &#x3D; 1; i &lt;&#x3D; 4; i++)    </span><br><span class="line">            for (j &#x3D; 1; j &lt;&#x3D; 4; j++)</span><br><span class="line">                for (k &#x3D; 1; k &lt;&#x3D; 4; k++)</span><br><span class="line">                     if (i !&#x3D; j &amp;&amp; j !&#x3D; k &amp;&amp; i !&#x3D; k) &#123;</span><br><span class="line">                              t +&#x3D; 1;</span><br><span class="line">                              System.out.println(i * 100 + j * 10 + k);      </span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(t);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>11. 一个整数，它加上 100 后是一个完全平方数，加上 168 又是一个完全平方数，请问该数是多少？</strong></p>
<blockquote>
<p>程序分析：在 10 万以内判断，先将该数加上 100 后再开方，再将该数加上 268 后再开方，如果开方后的结果满足如下条件，即是结果。请看具体分析：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          long k &#x3D; 0;   </span><br><span class="line">        for (k &#x3D; 1; k &lt;&#x3D; 100000l; k++)</span><br><span class="line">               if (Math.floor(Math.sqrt(k + 100)) &#x3D;&#x3D; Math.sqrt(k + 100) &amp;&amp; Math.floor(Math.sqrt(k + 168)) &#x3D;&#x3D; Math.sqrt(k + 168))</span><br><span class="line">                System.out.println(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>12. 猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个。第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第 10 天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。</strong></p>
<blockquote>
<p>程序分析：采取逆向思维的方法，从后往前推断。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Monkey &#123;</span><br><span class="line">     static int total(int day) &#123;   </span><br><span class="line">        if (day &#x3D;&#x3D; 10) &#123;</span><br><span class="line">           return 1;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            return (total(day + 1) + 1) * 2;</span><br><span class="line">          &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">  System.out.println(total(1));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>13. 有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13……求出这个数列的前 20 项之和。</strong></p>
<blockquote>
<p>程序分析：请抓住分子与分母的变化规律。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class test20 &#123;</span><br><span class="line">     public static void main(String[] args) &#123;</span><br><span class="line">          float fm &#x3D; 1f;</span><br><span class="line">          float fz &#x3D; 1f;   float temp;</span><br><span class="line">          float sum &#x3D; 0f;</span><br><span class="line">          for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">               temp &#x3D; fm;</span><br><span class="line">               fm &#x3D; fz;   </span><br><span class="line">            fz &#x3D; fz + temp;</span><br><span class="line">               sum +&#x3D; fz &#x2F; fm;</span><br><span class="line">        &#125;</span><br><span class="line">          System.out.println(sum);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>14. 有 5 个人坐在一起，问第五个人多少岁？他说比第 4 个人大 2 岁。问第 4 个人岁数，他说比第 3 个人 大 2 岁。问第三个人，又说比第 2 人大两岁。问第 2 个人，说比第一个人大两岁。最后问第一个人，他说是 10 岁。请问第五个人多大？</strong></p>
<blockquote>
<p>程序分析：利用递归的方法，递归分为回推和递推两个阶段。要想知道第五个人岁数，需知道第四人的岁数，依次类推， 推到第一人（10 岁），再往回推。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Ex23 &#123;  </span><br><span class="line">     static int getAge(int n) &#123;   </span><br><span class="line">        if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">               return 10;</span><br><span class="line">          &#125;</span><br><span class="line">          return 2 + getAge(n - 1);</span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;   </span><br><span class="line">        System.out.println(&quot;第五个的年龄为:&quot; + getAge(5));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>15. 打印出杨辉三角形。</strong></p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/c047b950-ee15-11e8-ae88-19b33b399945" alt=""></p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Ex33 &#123;</span><br><span class="line">     public static void main(String args[]) &#123;   int i, j;</span><br><span class="line">          int a[][];</span><br><span class="line">          a &#x3D; new int[8][8];</span><br><span class="line">          for (i &#x3D; 0; i &lt; 8; i++) &#123;</span><br><span class="line">               a[i][i] &#x3D; 1;    a[i][0] &#x3D; 1;</span><br><span class="line">          &#125;</span><br><span class="line">          for (i &#x3D; 2; i &lt; 8; i++) &#123;</span><br><span class="line">               for (j &#x3D; 1; j &lt;&#x3D; i - 1; j++) &#123;</span><br><span class="line">                a[i][j] &#x3D; a[i - 1][j - 1] + a[i - 1][j];    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         for (i &#x3D; 0; i &lt; 8; i++) &#123;</span><br><span class="line">               for (j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">                System.out.printf(&quot;  &quot; + a[i][j]);    </span><br><span class="line">            &#125;</span><br><span class="line">               System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ol>
<li>Java 类加载过程？<blockquote>
<p>Java 类加载需要经历一下 7 个过程：  </p>
</blockquote>
</li>
</ol>
<blockquote>
<p><strong>1. 加载</strong>  </p>
</blockquote>
<blockquote>
<p>加载是类加载的第一个过程，在这个阶段，将完成一下三件事情：  </p>
</blockquote>
<ul>
<li>通过一个类的全限定名获取该类的二进制流。</li>
<li>将该二进制流中的静态存储结构转化为方法去运行时数据结构。</li>
<li>在内存中生成该类的 Class 对象，作为该类的数据访问入口。<blockquote>
<p><strong>2. 验证</strong>  </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>验证的目的是为了确保 Class 文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证:  </p>
</blockquote>
<ul>
<li>文件格式验证：验证字节流是否符合 Class 文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.</li>
<li>元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。</li>
<li>字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。</li>
<li>符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。<blockquote>
<p><strong>3. 准备</strong>  </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static int value&#x3D;123;&#x2F;&#x2F;在准备阶段value初始值为0 。在初始化阶段才会变为123 。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>4. 解析</strong>  </p>
</blockquote>
<blockquote>
<p>该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。  </p>
</blockquote>
<blockquote>
<p><strong>5. 初始化</strong>  </p>
</blockquote>
<blockquote>
<p>初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。  </p>
</blockquote>
<blockquote>
<p><strong>6. 使用</strong>  </p>
</blockquote>
<blockquote>
<p><strong>7. 卸载</strong>  </p>
</blockquote>
<ol>
<li>描述一下 JVM 加载 Class 文件的原理机制?<blockquote>
<p>Java 语言是一种具有动态性的解释型语言，类（Class）只有被加载到 JVM 后才能运行。当运行指定程序时，JVM 会将编译生成的 .class 文件按照需求和一定的规则加载到内存中，并组织成为一个完整的 Java 应用程序。这个加载过程是由类加载器完成，具体来说，就是由 ClassLoader 和它的子类来实现的。类加载器本身也是一个类，其实质是把类文件从硬盘读取到内存中。  </p>
</blockquote>
</li>
</ol>
<blockquote>
<p>类的加载方式分为隐式加载和显示加载。隐式加载指的是程序在使用 new 等方式创建对象时，会隐式地调用类的加载器把对应的类加载到 JVM 中。显示加载指的是通过直接调用 class.forName() 方法来把所需的类加载到 JVM 中。  </p>
</blockquote>
<blockquote>
<p>任何一个工程项目都是由许多类组成的，当程序启动时，只把需要的类加载到 JVM 中，其他类只有被使用到的时候才会被加载，采用这种方法一方面可以加快加载速度，另一方面可以节约程序运行时对内存的开销。此外，在 Java 语言中，每个类或接口都对应一个 .class 文件，这些文件可以被看成是一个个可以被动态加载的单元，因此当只有部分类被修改时，只需要重新编译变化的类即可，而不需要重新编译所有文件，因此加快了编译速度。  </p>
</blockquote>
<blockquote>
<p>在 Java 语言中，类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类（例如基类）完全加载到 JVM 中，至于其他类，则在需要的时候才加载。  </p>
</blockquote>
<blockquote>
<p>类加载的主要步骤：  </p>
</blockquote>
<ul>
<li><p>装载。根据查找路径找到相应的 class 文件，然后导入。</p>
</li>
<li><p>链接。链接又可分为 3 个小步：</p>
</li>
<li><p>检查，检查待加载的 class 文件的正确性。</p>
</li>
<li><p>准备，给类中的静态变量分配存储空间。</p>
</li>
<li><p>解析，将符号引用转换为直接引用（这一步可选）</p>
</li>
<li><p>初始化。对静态变量和静态代码块执行初始化工作。</p>
</li>
</ul>
<p><strong>18. Java 内存分配。</strong></p>
<ul>
<li><strong>寄存器：</strong> 我们无法控制。</li>
<li><strong>静态域</strong> ：static定义的静态成员。</li>
<li><strong>常量池：</strong> 编译时被确定并保存在 .class 文件中的（final）常量值和一些文本修饰的符号引用（类和接口的全限定名，字段的名称和描述符，方法和名称和描述符）。</li>
<li><strong>非 RAM 存储：</strong> 硬盘等永久存储空间。</li>
<li><strong>堆内存</strong> ：new 创建的对象和数组，由 Java 虚拟机自动垃圾回收器管理,存取速度慢。</li>
<li><strong>栈内存：</strong> 基本类型的变量和对象的引用变量（堆内存空间的访问地址），速度快，可以共享，但是大小与生存期必须确定，缺乏灵活性。</li>
</ul>
<ol>
<li>Java 堆的结构是什么样子的？什么是堆中的永久代（Perm Gen space）?<blockquote>
<p>JVM 的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在 JVM 启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。  </p>
</blockquote>
</li>
</ol>
<blockquote>
<p>堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些 对象回收掉之前，他们会一直占据堆内存空间。  </p>
</blockquote>
<p><strong>20. GC 是什么? 为什么要有 GC？</strong></p>
<blockquote>
<p>GC 是垃圾收集的意思（GabageCollection），内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。  </p>
</blockquote>
<p><strong>21. 简述 Java 垃圾回收机制。</strong></p>
<blockquote>
<p>在 Java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。  </p>
</blockquote>
<p><strong>22. 如何判断一个对象是否存活？（或者 GC 对象的判定方法）</strong></p>
<blockquote>
<p>判断一个对象是否存活有两种方法：  </p>
</blockquote>
<blockquote>
<p><strong>1. 引用计数法</strong>  </p>
</blockquote>
<blockquote>
<p>所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收.  </p>
</blockquote>
<blockquote>
<p>引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B，对象 B 又引用者对象 A，那么此时 A、B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。  </p>
</blockquote>
<blockquote>
<p><strong>2. 可达性算法（引用链法）</strong>  </p>
</blockquote>
<blockquote>
<p>该算法的思想是：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。  </p>
</blockquote>
<blockquote>
<p>在 Java 中可以作为 GC Roots 的对象有以下几种：  </p>
</blockquote>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区类静态属性引用的对象</li>
<li>方法区常量池引用的对象</li>
<li>本地方法栈JNI引用的对象<blockquote>
<p>虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达 GC Root 时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记.  </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法或者已被虚拟机调用过，那么就认为是没必要的。 如果该对象有必要执行 finalize() 方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize() 线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果 finalize() 执行缓慢或者发生了死锁，那么就会造成 F-Queue 队列一直等待，造成了内存回收系统的崩溃。GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除” 即将回收” 集合，等待回收。  </p>
</blockquote>
<p><strong>23. 垃圾回收的优点和原理。并考虑 2 种回收机制。</strong></p>
<blockquote>
<p>Java 语言中一个显著的特点就是引入了垃圾回收机制，使 C++ 程序员最头疼的内存管理的问题迎刃而解，它使得 Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java 中的对象不再有“作用域”的概念，只有对象的引用才有”作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。  </p>
</blockquote>
<blockquote>
<p>回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。  </p>
</blockquote>
<p><strong>24. 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</strong></p>
<blockquote>
<p>对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。通常，GC 采用有向图的方式记录和管理堆（heap）中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当 GC 确定一些对象为“不可达”时，GC 就有责任回收这些内存空间。可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言规范并不保证 GC 一定会执行。  </p>
</blockquote>
<p><strong>25. Java 中会存在内存泄漏吗，请简单描述。</strong></p>
<blockquote>
<p>所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。Java 中有垃圾回收机制，它可以保证一对象不再被引用的时候，即对象变成了孤儿的时候，对象将自动被垃圾回收器从内存中清除掉。由于 Java 使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么 GC 也是可以回收它们的，例如下面的代码可以看到这种情况的内存回收：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">public class GarbageTest &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param args</span><br><span class="line">     * @throws IOException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        try &#123;</span><br><span class="line">            gcTest();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;has exited gcTest!&quot;);</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.in.read();       </span><br><span class="line">        System.out.println(&quot;out begin gc!&quot;);        </span><br><span class="line">        for(int i&#x3D;0;i&lt;100;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            System.in.read();   </span><br><span class="line">            System.in.read();   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static void gcTest() throws IOException &#123;</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.in.read();       </span><br><span class="line">        Person p1 &#x3D; new Person();</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.in.read();       </span><br><span class="line">        Person p2 &#x3D; new Person();</span><br><span class="line">        p1.setMate(p2);</span><br><span class="line">        p2.setMate(p1);</span><br><span class="line">        System.out.println(&quot;before exit gctest!&quot;);</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.in.read();       </span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(&quot;exit gctest!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private static class Person</span><br><span class="line">    &#123;</span><br><span class="line">        byte[] data &#x3D; new byte[20000000];</span><br><span class="line">        Person mate &#x3D; null;</span><br><span class="line">        public void setMate(Person other)</span><br><span class="line">        &#123;</span><br><span class="line">            mate &#x3D; other;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java 中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是 Java 中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是 java 中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中 (例如放在一个全局 map 对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。  </p>
</blockquote>
<blockquote>
<p>检查 Java 中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。  </p>
</blockquote>
<blockquote>
<p>如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。  </p>
</blockquote>
<blockquote>
<p>下面内容来自于网上（主要特点就是清空堆栈中的某个元素，并不是彻底把它从数组中拿掉，而是把存储的总数减少，本人写得可以比这个好，在拿掉某个元素时，顺便也让它从数组中消失，将那个元素所在的位置的值设置为 null 即可）：  </p>
</blockquote>
<blockquote>
<p>我实在想不到比那个堆栈更经典的例子了，以致于我还要引用别人的例子，下面的例子不是我想到的，是书上看到的，当然如果没有在书上看到，可能过一段时间我自己也想的到，可是那时我说是我自己想到的也没有人相信的。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Stack &#123;</span><br><span class="line">    private Object[] elements&#x3D;new Object[10];</span><br><span class="line">    private int size &#x3D; 0;</span><br><span class="line">    public void push(Object e)&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] &#x3D; e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object pop()&#123;</span><br><span class="line">        if( size &#x3D;&#x3D; 0) throw new EmptyStackException();</span><br><span class="line">        return elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ensureCapacity()&#123;</span><br><span class="line">        if(elements.length &#x3D;&#x3D; size)&#123;</span><br><span class="line">            Object[] oldElements &#x3D; elements;</span><br><span class="line">            elements &#x3D; new Object[2 * elements.length+1];</span><br><span class="line">            System.arraycopy(oldElements,0, elements, 0, size);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的原理应该很简单，假如堆栈加了 10 个元素，然后全部弹出来，虽然堆栈是空的，没有我们要的东西，但是这是个对象是无法回收的，这个才符合了内存泄露的两个条件：无用，无法回收。但是就是存在这样的东西也不一定会导致什么样的后果，如果这个堆栈用的比较少，也就浪费了几个K内存而已，反正我们的内存都上 G 了，哪里会有什么影响，再说这个东西很快就会被回收的，有什么关系。下面看两个例子。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Bad&#123;</span><br><span class="line">    public static Stack s&#x3D;Stack();</span><br><span class="line">    static&#123;</span><br><span class="line">        s.push(new Object());</span><br><span class="line">        s.pop(); &#x2F;&#x2F;这里有一个对象发生内存泄露</span><br><span class="line">        s.push(new Object()); &#x2F;&#x2F;上面的对象可以被回收了，等于是自愈了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为是 static，就一直存在到程序退出，但是我们也可以看到它有自愈功能，就是说如果你的 Stack 最多有 100 个对象，那么最多也就只有 100 个对象无法被回收其实这个应该很容易理解，Stack 内部持有 100 个引用，最坏的情况就是他们都是无用的，因为我们一旦放新的进取，以前的引用自然消失！  </p>
</blockquote>
<blockquote>
<p>内存泄露的另外一种情况：当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前对象，造成内存泄露。  </p>
</blockquote>
<p><strong>26. 深拷贝和浅拷贝。</strong></p>
<blockquote>
<p>简单来讲就是复制、克隆。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p&#x3D;new Person(“张三”);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>浅拷贝就是对对象中的数据成员进行简单赋值，如果存在动态成员或者指针就会报错。  </p>
</blockquote>
<blockquote>
<p>深拷贝就是对对象中存在的动态成员或指针重新开辟内存空间。  </p>
</blockquote>
<p><strong>27. System.gc() 和 Runtime.gc() 会做什么事情？</strong></p>
<blockquote>
<p>这两个方法用来提示 JVM 要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于 JVM 的。  </p>
</blockquote>
<p><strong>28. finalize() 方法什么时候被调用？析构函数 (finalization) 的目的是什么？</strong></p>
<blockquote>
<p>垃圾回收器（garbage colector）决定回收某对象时，就会运行该对象的 finalize() 方法 但是在 Java 中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说 filalize() 可能永远不被执行，显然指望它做收尾工作是靠不住的。 那么 finalize() 究竟是做什么的呢？ 它最主要的用途是回收特殊渠道申请的内存。Java 程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种 JNI（Java Native Interface）调用 non-­Java 程序（C 或 C++）， finalize() 的工作就是回收这部分的内存。  </p>
</blockquote>
<p><strong>29. 如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存？</strong></p>
<blockquote>
<p>不会，在下一个垃圾回收周期中，这个对象将是可被回收的。  </p>
</blockquote>
<p><strong>30. 什么是分布式垃圾回收（DGC）？它是如何工作的？</strong></p>
<blockquote>
<p>DGC 叫做分布式垃圾回收。RMI 使用 DGC 来做自动垃圾回收。因为 RMI 包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC 使用引用计数算法来给远程对象提供自动内存管理。  </p>
</blockquote>
<p><strong>31. 串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？</strong></p>
<blockquote>
<p>吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。 而串行收集器对大多数的小应用（在现代处理器上需要大概 100M 左右的内存）就足够了。  </p>
</blockquote>
<p><strong>32. 在 Java 中，对象什么时候可以被垃圾回收？</strong></p>
<blockquote>
<p>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。  </p>
</blockquote>
<p><strong>33. 简述 Java 内存分配与回收策率以及 Minor GC 和 Major GC。</strong></p>
<ul>
<li>对象优先在堆的 Eden 区分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象将直接进入老年代<blockquote>
<p>当 Eden 区没有足够的空间进行分配时，虚拟机会执行一次 Minor GC。Minor GC 通常发生在新生代的 Eden 区，在这个区的对象生存期短，往往发生 Gc 的频率较高，回收速度比较快；Full GC/Major GC 发生在老年代，一般情况下，触发老年代 GC 的时候不会触发 Minor GC，但是通过配置，可以在 Full GC 之前进行一次 Minor GC 这样可以加快老年代的回收速度。  </p>
</blockquote>
</li>
</ul>
<p><strong>34. JVM 的永久代中会发生垃圾回收么？</strong></p>
<blockquote>
<p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收（Full GC）。  </p>
</blockquote>
<blockquote>
<p>注：Java 8 中已经移除了永久代，新加了一个叫做元数据区的 native 内存区。  </p>
</blockquote>
<p><strong>35. Java 中垃圾收集的方法有哪些？</strong></p>
<blockquote>
<p>标记 - 清除：这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：  </p>
</blockquote>
<ol>
<li>效率不高，标记和清除的效率都很低；</li>
<li>会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次 GC 动作。<blockquote>
<p>复制算法：为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。  </p>
</blockquote>
</li>
</ol>
<blockquote>
<p>于是将该算法进行了改进，内存区域不再是按照 1:1 去划分，而是将内存划分为 8:1:1 三部分，较大那份内存交 Eden 区，其余是两块较小的内存区叫 Survior 区。每次都会优先使用 Eden 区，若 Eden 区满，就将对象复制到第二块内存区上，然后清除 Eden 区，如果此时存活的对象太多，以至于 Survivor 不够时，会将这些对象通过分配担保机制复制到老年代中。（java 堆又分为新生代和老年代）  </p>
</blockquote>
<blockquote>
<p>标记 - 整理：该算法主要是为了解决标记 - 清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。  </p>
</blockquote>
<blockquote>
<p>分代收集：现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保。  </p>
</blockquote>
<p><strong>36. 什么是类加载器，类加载器有哪些？</strong></p>
<blockquote>
<p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。  </p>
</blockquote>
<blockquote>
<p>主要有一下四种类加载器：  </p>
</blockquote>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）用来加载 Java 核心类库，无法被 Java 程序直接引用。</li>
<li>扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li>
<li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader() 来获取它。</li>
<li>用户自定义类加载器，通过继承 java.lang.ClassLoader 类的方式实现。</li>
<li><em>37. 类加载器双亲委派模型机制？*</em></li>
</ul>
<blockquote>
<p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。  </p>
</blockquote>
<h3 id="Java-核心基础"><a href="#Java-核心基础" class="headerlink" title="Java 核心基础"></a>Java 核心基础</h3><p><strong>38. 一个 “.java” 源文件中是否可以包括多个类（不是内部类）？有什么限制？</strong></p>
<blockquote>
<p>可以有多个类，但只能有一个 public 的类，并且 public 的类名必须与文件名相一致。  </p>
</blockquote>
<p><strong>39. 说说 &amp; 和 &amp;&amp; 的区别。</strong></p>
<blockquote>
<p>&amp; 和 &amp;&amp; 都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为 true 时，整个运算结果才为 true，否则，只要有一方为 false，则结果为 false。  </p>
</blockquote>
<blockquote>
<p>&amp;&amp; 还具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式，例如，对于 if(str != null &amp;&amp; !str.equals(“”)) 表达式，当 str 为 null 时，后面的表达式不会执行，所以不会出现 NullPointerException 如果将 &amp;&amp; 改为 &amp;，则会抛出 NullPointerException 异常。If(x==33 &amp; ++y&gt;0) y 会增长，If(x==33 &amp;&amp; ++y&gt;0) 不会增长。  </p>
</blockquote>
<blockquote>
<p>&amp; 还可以用作位运算符，当 &amp; 操作符两边的表达式不是 boolean 类型时，&amp; 表示按位与操作，我们通常使用 0x0f 来与一个整数进行 &amp; 运算，来获取该整数的最低 4 个 bit 位，例如，0x31 &amp; 0x0f 的结果为 0x01。  </p>
</blockquote>
<blockquote>
<p>备注：这道题先说两者的共同点，再说出 &amp;&amp; 和 &amp; 的特殊之处，并列举一些经典的例子来表明自己理解透彻深入、实际经验丰富。  </p>
</blockquote>
<p><strong>40. 值传递和引用传递。</strong></p>
<blockquote>
<p>值传递是针对基本数据类型而言，传递的是值得副本，对副本的改变不会影响到原变量。  </p>
</blockquote>
<blockquote>
<p>引用传递就是将一个堆内存空间的使用权交给多个栈内存空间，每一个栈内存空间都可以对堆内存空间进行修改。  </p>
</blockquote>
<p><strong>41. 在 Java 中如何跳出当前的多重嵌套循环？</strong></p>
<blockquote>
<p>在 Java 中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的 break 语句，即可跳出外层循环。例如：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">  for(int j&#x3D;0;j&lt;10;j++)</span><br><span class="line">  &#123;</span><br><span class="line">      System.out.println(“i&#x3D;” + i + “,j&#x3D;” + j);</span><br><span class="line">      if(j &#x3D;&#x3D; 5) break ok;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外，我个人通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如，要在二维数组中查找到某个数字。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int arr[][] &#x3D; &#123;&#123;1,2,3&#125;,&#123;4,5,6,7&#125;,&#123;9&#125;&#125;;</span><br><span class="line">boolean found &#x3D; false;</span><br><span class="line">for(int i&#x3D;0;i&lt;arr.length &amp;&amp; !found;i++)</span><br><span class="line">  &#123;</span><br><span class="line">      for(int j&#x3D;0;j&lt;arr[i].length;j++)</span><br><span class="line">      &#123;</span><br><span class="line">          System.out.println(“i&#x3D;” + i + “,j&#x3D;” + j);</span><br><span class="line">          if(arr[i][j]  &#x3D;&#x3D; 5)</span><br><span class="line">          &#123;</span><br><span class="line">              found &#x3D; true;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>42. 访问修饰符 public,private,protected, 以及不写（默认）时的区别？</strong></p>
<blockquote>
<p>修饰符 当前类 同 包 子 类 其他包     public √ √ √ √   protected √ √ √ ×   Default √ √ × ×   private √ × × ×  </p>
</blockquote>
<p><strong>43. switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上?</strong></p>
<blockquote>
<p>在 switch（expr1）中，expr1 只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是 int 基本类型或 Integer 包装类型，由于，byte,short,char 都可以隐含转换为 int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long 和 String 类型都不符合 switch 的语法规定，并且不能被隐式转换成 int 类型，所以，它们不能作用于 swtich 语句中。  </p>
</blockquote>
<p><strong>44. char 型变量中能不能存贮一个中文汉字? 为什么?</strong></p>
<blockquote>
<p>char 型变量是用来存储 Unicode 编码的字符的，unicode 编码字符集中包含了汉字，所以，char 型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在 unicode 编码字符集中，那么，这个 char 型变量中就不能存储这个特殊汉字。补充说明：unicode 编码占用两个字节，所以，char 类型的变量也是占用两个字节。  </p>
</blockquote>
<blockquote>
<p>备注：后面一部分回答虽然不是在正面回答题目，但是，为了展现自己的学识和表现自己对问题理解的透彻深入，可以回答一些相关的知识，做到知无不言，言无不尽。  </p>
</blockquote>
<p><strong>45. 用最有效率的方法算出 2 乘以 8 等於几?</strong></p>
<blockquote>
<p>2 &lt;&lt; 3  </p>
</blockquote>
<blockquote>
<p>因为将一个数左移 n 位，就相当于乘以了 2 的 n 次方，那么，一个数乘以 8 只要将其左移 3 位即可，而位运算 cpu 直接支持的，效率最高，所以，2 乘以 8 等於几的最效率的方法是 2 &lt;&lt; 3。  </p>
</blockquote>
<p><strong>46. 使用 final 关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</strong></p>
<blockquote>
<p>使用 final 关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final StringBuffer a&#x3D;new StringBuffer(&quot;immutable&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行如下语句将报告编译期错误：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;new StringBuffer(&quot;&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是，执行如下语句则可以通过编译：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.append(&quot; broken!&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void method(final  StringBuffer  param)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">param.append(&quot;a&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>47. “==” 和 equals 方法究竟有什么区别？</strong></p>
<blockquote>
<p>（单独把一个东西说清楚，然后再说清楚另一个，这样，它们的区别自然就出来了，混在一起说，则很难说清楚）  </p>
</blockquote>
<blockquote>
<p>== 操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用 == 操作符。  </p>
</blockquote>
<blockquote>
<p>如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块内存（堆内存），变量也占用一块内存，例如 Objet obj = new Object(); 变量 obj 是一个内存，new Object() 是另一个内存，此时，变量 obj 所对应的内存中存储的数值就是对象占用的那块内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要看这两个变量所对应的内存中的数值是否相等，这时候就需要用 == 操作符进行比较。  </p>
</blockquote>
<blockquote>
<p>equals 方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。例如，对于下面的代码：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a&#x3D;new String(&quot;foo&quot;);</span><br><span class="line"></span><br><span class="line">String b&#x3D;new String(&quot;foo&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>两条 new 语句创建了两个对象，然后用 a,b 这两个变量分别指向了其中一个对象，这是两个不同的对象，它们的首地址是不同的，即 a 和 b 中存储的数值是不相同的，所以，表达式 a==b 将返回 false，而这两个对象中的内容是相同的，所以，表达式 a.equals(b) 将返回 true。  </p>
</blockquote>
<blockquote>
<p>在实际开发中，我们经常要比较传递进行来的字符串内容是否等，例如，String input = …;input.equals(“quit”)，许多人稍不注意就使用 == 进行比较了，这是错误的，随便从网上找几个项目实战的教学视频看看，里面就有大量这样的错误。记住，字符串的比较基本上都是使用 equals 方法。  </p>
</blockquote>
<blockquote>
<p>如果一个类没有自己定义 equals 方法，那么它将继承 Object 类的 equals 方法，Object 类的 equals 方法的实现代码如下：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean equals(Object o)&#123;</span><br><span class="line"></span><br><span class="line">return this&#x3D;&#x3D;o;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这说明，如果一个类没有自己定义 equals 方法，它默认的 equals 方法（从 Object 类继承的）就是使用 == 操作符，也是在比较两个变量指向的对象是否是同一对象，这时候使用 equals 和使用 == 会得到同样的结果，如果比较的是两个独立的对象则总返回 false。如果你编写的类希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖 equals 方法，由你自己写代码来决定在什么情况即可认为两个对象的内容是相同的。  </p>
</blockquote>
<p><strong>48. 静态变量和实例变量的区别？</strong></p>
<blockquote>
<p>在语法定义上的区别：静态变量前要加 static 关键字，而实例变量前则不加。  </p>
</blockquote>
<blockquote>
<p>在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个 <strong>实例变量</strong> 。静态变量不属于某个实例对象，而是属于类，所以也称为 <strong>类变量</strong> ，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。  </p>
</blockquote>
<blockquote>
<p>例如，对于下面的程序，无论创建多少个实例对象，永远都只分配了一个 staticVar 变量，并且每创建一个实例对象，这个 staticVar 就会加 1；但是，每创建一个实例对象，就会分配一个 instanceVar，即可能分配多个 instanceVar，并且每个 instanceVar 的值都只自加了 1 次。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class VariantTest&#123;</span><br><span class="line">    public static int staticVar &#x3D; 0;</span><br><span class="line">    public int instanceVar &#x3D; 0;</span><br><span class="line">    public VariantTest()</span><br><span class="line">    &#123;</span><br><span class="line">        staticVar++;</span><br><span class="line">        instanceVar++;</span><br><span class="line">      System.out.println(“staticVar&#x3D;” + staticVar + ”,instanceVar&#x3D;” + instanceVar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：这个解答除了说清楚两者的区别外，最后还用一个具体的应用例子来说明两者的差异，体现了自己有很好的解说问题和设计案例的能力，思维敏捷，超过一般程序员，有写作能力！  </p>
</blockquote>
<p><strong>49. 是否可以从一个 static 方法内部发出对非 static 方法的调用？</strong></p>
<blockquote>
<p>不可以。因为非 static 方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而 static 方法调用时不需要创建对象，可以直接调用。也就是说，当一个 static 方法被调用时，可能还没有创建任何实例对象，如果从一个 static 方法中发出对非 static 方法的调用，那个非 static 方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，不可以一个 static 方法内部发出对非 static 方法的调用。  </p>
</blockquote>
<p><strong>50. Math.round(11.5) 等于多少? Math.round(-11.5) 等于多少?</strong></p>
<blockquote>
<p>Math 类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英文名称的含义相对应，例如，ceil 的英文意义是天花板，该方法就表示向上取整，所以，Math.ceil(11.3)的结果为 12,Math.ceil(-11.3)的结果是 - 11；floor 的英文意义是地板，该方法就表示向下取整，所以，Math.floor(11.6)的结果为 11,Math.floor(-11.6)的结果是 - 12；最难掌握的是 round 方法，它表示 “四舍五入”，算法为 Math.floor(x+0.5)，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为 12，Math.round(-11.5)的结果为 - 11。  </p>
</blockquote>
<p><strong>51. Overload 和 Override 的区别。Overload 的方法是否可以改变返回值的类型?</strong></p>
<blockquote>
<p><strong>Overload</strong> 是重载的意思，Override 是覆盖的意思，也就是重写。  </p>
</blockquote>
<blockquote>
<p>重载 Overload 表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。  </p>
</blockquote>
<blockquote>
<p>重写 Override 表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是 private 类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。  </p>
</blockquote>
<blockquote>
<p>至于 Overloaded 的方法是否可以改变返回值的类型这个问题，要看你倒底想问什么呢？这个题目很模糊。如果几个 Overloaded 的方法的参数列表不一样，它们的返回者类型当然也可以不一样。但我估计你想问的问题是：如果两个方法的参数列表完全一样，是否可以让它们的返回值不同来实现重载 Overload。这是不行的，我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用 map.remove(key) 方法时，虽然 remove 方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java 就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。  </p>
</blockquote>
<blockquote>
<p><strong>override</strong> 可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意以下的几点：  </p>
</blockquote>
<ul>
<li><p>覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；</p>
</li>
<li><p>覆盖的方法的返回值必须和被覆盖的方法的返回一致；</p>
</li>
<li><p>覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；</p>
</li>
<li><p>被覆盖的方法不能为 private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</p>
</li>
</ul>
<blockquote>
<p>overload 对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的方法，通过定义不同的输入参数来区分这些方法，然后再调用时，VM 就会根据不同的参数样式，来选择合适的方法执行。在使用重载要注意以下的几点：  </p>
</blockquote>
<ul>
<li><p>在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是 fun(int,float)，但是不能为 fun(int,int)）；</p>
</li>
<li><p>不能通过访问权限、返回类型、抛出的异常进行重载；</p>
</li>
<li><p>方法的异常类型和数目不会对重载造成影响；</p>
</li>
<li><p>对于继承来说，如果某一方法在父类中是访问权限是 priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。</p>
</li>
</ul>
<p><strong>52. ClassLoader 如何加载 class。</strong></p>
<blockquote>
<p>JVM 里有多个类加载，每个类加载可以负责加载特定位置的类，例如，bootstrap 类加载负责加载 jre/lib/rt.jar 中的类， 我们平时用的 jdk 中的类都位于 rt.jar 中。extclassloader 负责加载 jar/lib/ext/*.jar 中的类，appclassloader 负责 classpath 指定的目录或 jar 中的类。除了 bootstrap 之外，其他的类加载器本身也都是 java 类，它们的父类是 ClassLoader。  </p>
</blockquote>
<p><strong>53. 序列化接口的 id 有什么用？</strong></p>
<blockquote>
<p>对象经常要通过 IO 进行传送，让你写程序传递对象，你会怎么做？把对象的状态数据用某种格式写入到硬盘，Person-&gt;“zxx,male,28,30000”àPerson，既然大家都要这么干，并且没有个统一的干法，于是，sun 公司就提出一种统一的解决方案，它会把对象变成某个格式进行输入和输出，这种格式对程序员来说是透明（transparent）的，但是，我们的某个类要想能被 sun 的这种方案处理，必须实现 Serializable 接口。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream.writeObject(obj);</span><br><span class="line">Object obj &#x3D; ObjectInputStream.readObject();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>假设两年前我保存了某个类的一个对象，这两年来，我修改该类，删除了某个属性和增加了另外一个属性，两年后，我又去读取那个保存的对象，或有什么结果？未知！sun 的 jdk 就会蒙了。为此，一个解决办法就是在类中增加版本后，每一次类的属性修改，都应该把版本号升级一下，这样，在读取时，比较存储对象时的版本号与当前类的版本号，如果不一致，则直接报版本号不同的错!  </p>
</blockquote>
<p><strong>54. hashCode 方法的作用？</strong></p>
<blockquote>
<p>hashcode 这个方法是用来鉴定 2 个对象是否相等的。与 equals 方法功能类似，但是有区别。一般来讲，equals 这个方法是给用户调用的，如果你想判断 2 个对象是否相等，你可以重写 equals 方法，然后在代码中调用，就可以判断他们是否相等了。简单来讲，equals 方法主要是用来判断从表面上看或者从内容上看，2 个对象是不是相等。举个例子，有个学生类，属性只有姓名和性别，那么我们可以认为只要姓名和性别相等，那么就说这 2 个对象是相等的。  </p>
</blockquote>
<blockquote>
<p>hashcode 方法一般用户不会去调用，比如在 hashmap 中，由于 key 是不可以重复的，他在判断 key 是不是重复的时候就判断了 hashcode 这个方法，而且也用到了 equals 方法。这里不可以重复是说 equals 和 hashcode 只要有一个不等就可以了！所以简单来讲，hashcode 相当于是一个对象的编码，就好像文件中的 md5，他和 equals 不同就在于他返回的是 int 型的，比较起来不直观。我们一般在覆盖 equals 的同时也要覆盖 hashcode，让他们的逻辑一致。举个例子，还是刚刚的例子，如果姓名和性别相等就算 2 个对象相等的话，那么 hashcode 的方法也要返回姓名的 hashcode 值加上性别的 hashcode 值，这样从逻辑上，他们就一致了。  </p>
</blockquote>
<p><strong>55. 构造器 Constructor 是否可被 override?</strong></p>
<blockquote>
<p>构造器 Constructor 不能被继承，因此不能重写 Override，但可以被重载 Overload。  </p>
</blockquote>
<p><strong>56. 接口是否可继承接口? 抽象类是否可实现 (implements) 接口? 抽象类是否可继承具体类(concrete class)? 抽象类中是否可以有静态的 main 方法？</strong></p>
<blockquote>
<p>接口可以继承接口。抽象类可以实现 (implements) 接口，抽象类可继承具体类。抽象类中可以有静态的 main 方法。  </p>
</blockquote>
<blockquote>
<p>备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想想，如果你是 java 语言的设计者，你是否会提供这样的支持，如果不提供的话，有什么理由吗？如果你没有道理不提供，那答案就是肯定的了。  </p>
</blockquote>
<blockquote>
<p>只有记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有 abstract 方法。  </p>
</blockquote>
<p><strong>57. Java 中实现多态的机制是什么？</strong></p>
<blockquote>
<p>靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。  </p>
</blockquote>
<p><strong>58. abstract class 和 interface 有什么区别?</strong></p>
<blockquote>
<p>含有 abstract 修饰符的 class 即为抽象类，abstract 类不能创建的实例对象。含有 abstract 方法的类必须定义为 abstract class，abstract class 类中的方法不必是抽象的。abstract class 类中定义抽象方法必须在具体 (Concrete) 子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为 abstract 类型。  </p>
</blockquote>
<blockquote>
<p>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为 public abstract 类型，接口中的成员变量类型默认为 public static final。  </p>
</blockquote>
<blockquote>
<p>下面比较一下两者的语法区别：  </p>
</blockquote>
<ul>
<li><p>抽象类可以有构造方法，接口中不能有构造方法。</p>
</li>
<li><p>抽象类中可以有普通成员变量，接口中没有普通成员变量</p>
</li>
<li><p>抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</p>
</li>
<li><p>抽象类中的抽象方法的访问类型可以是 public，protected 和（默认类型, 虽然 eclipse 下不报错，但应该也不行），但接口中的抽象方法只能是 public 类型的，并且默认即为 public abstract 类型。</p>
</li>
<li><p>抽象类中可以包含静态方法，接口中不能包含静态方法</p>
</li>
<li><p>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是 public static final 类型，并且默认即为 public static final 类型。</p>
</li>
<li><p>一个类可以实现多个接口，但只能继承一个抽象类。</p>
</li>
</ul>
<blockquote>
<p>下面接着再说说两者在应用上的区别：**  </p>
</blockquote>
<blockquote>
<p>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有 Servlet 类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的 Servlet 都继承这个抽象基类，在抽象基类的 service 方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码，伪代码如下：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public abstract class BaseServlet extends HttpServlet&#123;</span><br><span class="line">    public final void service(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException&#123;</span><br><span class="line">        &#x2F;&#x2F;记录访问日志</span><br><span class="line">        &#x2F;&#x2F;进行权限判断</span><br><span class="line">        if(具有权限)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              doService(request,response);</span><br><span class="line">            &#125;catch(Excetpion e)&#123;</span><br><span class="line">              &#x2F;&#x2F;记录异常信息</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;   </span><br><span class="line">  &#125;</span><br><span class="line">  protected abstract void doService(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException;  </span><br><span class="line">  &#x2F;&#x2F;注意访问权限定义成protected，显得既专业，又严谨，因为它是专门给子类用的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyServlet1 extends BaseServlet&#123;</span><br><span class="line">    protected void doService(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException&#123;</span><br><span class="line">    &#x2F;&#x2F;本Servlet只处理的具体业务逻辑代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。  </p>
</blockquote>
<blockquote>
<p>备注：这道题的思路是先从总体解释抽象类和接口的基本概念，然后再比较两者的语法细节，最后再说两者的应用区别。比较两者语法细节区别的条理是：先从一个类中的构造方法、普通成员变量和方法（包括抽象方法），静态变量和方法，继承性等 6 个方面逐一去比较回答，接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功底。  </p>
</blockquote>
<p><strong>59. abstract 的 method 是否可同时是 static, 是否可同时是 native，是否可同时是 synchronized?</strong></p>
<blockquote>
<p>abstract 的 method 不可以是 static 的，因为抽象的方法是要被子类实现的，而 static 与子类扯不上关系。  </p>
</blockquote>
<blockquote>
<p>native 方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与 abstract 混用。例如，FileOutputSteam 类要硬件打交道，底层的实现用的是操作系统相关的 api 实现，例如，在 windows 用 c 语言实现的，所以，查看 jdk 的源代码，可以发现 FileOutputStream 的 open 方法的定义如下：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private native void open(String name) throws FileNotFoundException;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们要用 java 调用别人写的 c 语言函数，我们是无法直接调用的，我们需要按照 java 的要求写一个 c 语言的函数，又我们的这个 c 语言函数去调用别人的 c 语言函数。由于我们的 c 语言函数是按 java 的要求来写的，我们这个 c 语言函数就可以与 java 对接上，java 那边的对接方式就是定义出与我们这个 c 函数相对应的方法，java 中对应的方法不需要写具体的代码，但需要在前面声明 native。  </p>
</blockquote>
<blockquote>
<p>关于 synchronized 与 abstract 合用的问题，我觉得也不行，因为在我几年的学习和开发中，从来没见到过这种情况，并且我觉得 synchronized 应该是作用在一个具体的方法上才有意义。而且，方法上的 synchronized 同步所使用的同步锁对象是 this，而抽象方法上无法确定 this 是什么。  </p>
</blockquote>
<p><strong>60. 什么是内部类？Static Nested Class 和 Inner Class 的不同。</strong></p>
<blockquote>
<p>内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。我想可能是既然静态成员类似 c 语言的全局变量，而内部类通常是用于创建内部对象用的，所以，把 “全局变量” 放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中，代码如下：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Outer&#123;</span><br><span class="line">    int out_x  &#x3D; 0;</span><br><span class="line">    public void method()&#123;</span><br><span class="line">        Inner1 inner1 &#x3D; new Inner1();</span><br><span class="line">        &#x2F;&#x2F;在方法体内部定义的内部类</span><br><span class="line">        class Inner2</span><br><span class="line">        &#123;</span><br><span class="line">            public void method() &#123;</span><br><span class="line">                out_x &#x3D; 3;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner2 inner2 &#x3D; new Inner2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;在方法体外面定义的内部类</span><br><span class="line">    public class Inner1 &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在方法体外面定义的内部类的访问类型可以是 public,protecte, 默认的，private 等 4 种类型，这就好像类中定义的成员变量有 4 种访问类型一样，它们决定这个内部类的定义对其他类是否可见；对于这种情况，我们也可以在外面创建内部类的实例对象，创建内部类的实例对象时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象，代码如下：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outer outer &#x3D; new Outer();</span><br><span class="line">Outer.Inner1 inner1 &#x3D; outer.new Innner1();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样，但这种内部类的前面可以使用 final 或 abstract 修饰符。这种内部类对其他类是不可见的其他类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但是，该局部变量前必须加 final 修饰符。  </p>
</blockquote>
<blockquote>
<p>对于这些细节，只要在 eclipse 写代码试试，根据开发工具提示的各类错误信息就可以马上了解到。  </p>
</blockquote>
<blockquote>
<p>在方法体内部还可以采用如下语法来创建一种匿名内部类，即定义某一接口或类的子类的同时，还创建了该子类的实例对象，无需为该子类定义名称：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">    public void start()&#123;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最后，在方法外部定义的内部类前面可以加上 static 关键字，从而成为 Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static Nested Class 与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成 public、protected、默认的、private 等多种类型，而普通类只能定义成 public 和默认的这两种类型。在外面引用 Static Nested Class 类的名称为 “外部类名. 内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建 Static Nested Class，例如，假设 Inner 是定义在 Outer 类中的 Static Nested Class，那么可以使用如下语句创建 Inner 类：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer.Inner inner &#x3D; new Outer.Inner();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于 static Nested Class 不依赖于外部类的实例对象，所以，static Nested Class 能访问外部类的非 static 成员变量。当在外部类中访问 Static Nested Class 时，可以直接使用 Static Nested Class 的名字，而不需要加上外部类的名字了，在 Static Nested Class 中也可以直接引用外部类的 static 的成员变量，不需要加上外部类的名字。  </p>
</blockquote>
<blockquote>
<p>在静态方法中定义的内部类也是 Static Nested Class，这时候不能在类前面加 static 关键字，静态方法中的 Static Nested Class 与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的 static 的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加 final 修饰符。  </p>
</blockquote>
<blockquote>
<p>备注：首先根据你的印象说出你对内部类的总体方面的特点：例如，在两个地方可以定义，可以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。  </p>
</blockquote>
<p><strong>61. String s = “Hello”;s = s + “world!”; 这两行代码执行后，原始的 String 对象中的内容到底变了没有？</strong></p>
<blockquote>
<p>没有。因为 String 被设计成不可变 (immutable) 类，所以它的所有对象都是不可变对象。在这段代码中，s 原先指向一个 String 对象，内容是 “Hello”，然后我们对 s 进行了 + 操作，那么 s 所指向的那个对象是否发生了改变呢？答案是没有。这时，s 不指向原来那个对象了，而指向了另一个 String 对象，内容为 “Hello world!”，原来那个对象还存在于内存之中，只是 s 这个引用变量不再指向它了。  </p>
</blockquote>
<blockquote>
<p>通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用 String 来代表字符串的话会引起很大的内存开销。因为 String 对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个 String 对象来表示。这时，应该考虑使用 StringBuffer 类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。  </p>
</blockquote>
<blockquote>
<p>同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都 new 一个 String。例如我们要在构造器中对一个名叫 s 的 String 引用变量进行初始化，把它设置为初始值，应当这样做：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    private String s;</span><br><span class="line">    ...</span><br><span class="line">    public Demo &#123;</span><br><span class="line">      s &#x3D; &quot;Initial Value&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为 String 对象不可改变，所以对于内容相同的字符串，只要一个 String 对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他们的 String 类型属性 s 都指向同一个对象。 上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java 认为它们代表同一个 String 对象。而用关键字 new 调用构造器，总是会创建一个新的对象，无论内容是否相同。  </p>
</blockquote>
<blockquote>
<p>至于为什么要把 String 类设计成不可变类，是它的用途决定的。其实不只 String，很多 Java 标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。所以 Java 标准类库还提供了一个可变版本，即 StringBuffer。  </p>
</blockquote>
<p><strong>62. String s = new String(“xyz”); 创建了几个 String Object? 二者之间有什么区别？</strong></p>
<blockquote>
<p>两个对象，”xyz” 对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz” 不管出现多少遍，都是缓冲区中的那一个。New String 每写一遍，就创建一个新的对象，它一句那个常量”xyz” 对象的内容来创建出一个新 String 对象。如果以前就用过’xyz’，这句代表就不会创建”xyz” 自己了，直接从缓冲区拿。  </p>
</blockquote>
<p><strong>63. StringBuffer 与 StringBuilder 的区别。</strong></p>
<blockquote>
<p>StringBuffer 和 StringBuilder 类都表示内容可以被修改的字符串， <strong>StringBuilder</strong> 是 <strong>线程不安全的，运行效率高</strong> ，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用 StringBuilder。如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用 StringBuffer。  </p>
</blockquote>
<p><strong>64. final,finally, finalize 的区别。</strong></p>
<ul>
<li><p>final 用于声明 <strong>属性，方法和类</strong> ，分别表示属性不可变，方法不可覆盖，类不可继承。 内部类要访问局部变量，局部变量必须定义成 final 类型。</p>
</li>
<li><p>finally 是 <strong>异常处理语句结构</strong> 的一部分，表示总是执行。</p>
</li>
<li><p>finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM 不保证此方法总被调用。</p>
</li>
</ul>
<p><strong>65. Java 中的异常处理机制的简单原理和应用。</strong></p>
<blockquote>
<p>异常是指 java 程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很相似，现实生活中的事件可以包含事件发生的时间、地点、人物、情节等信息，可以用一个对象来表示，Java 使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。  </p>
</blockquote>
<blockquote>
<p>Java 对异常进行了分类，不同类型的异常分别用不同的 Java 类表示，所有异常的根类为 java.lang.Throwable，Throwable 下面又派生了两个子类：Error 和 Exception，Error 表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程死锁等系统问题。Exception 表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）；普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。  </p>
</blockquote>
<blockquote>
<p>Java 为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须 try..catch 处理或用 throws 声明继续抛给上层调用方法处理，所以普通异常也称为 checked 异常，而系统异常可以处理也可以不处理，所以，编译器不强制用 try..catch 处理或用 throws 声明，所以系统异常也称为 unchecked 异常。  </p>
</blockquote>
<blockquote>
<p>提示答题者：就按照三个级别去思考：虚拟机必须宕机的错误，程序可以死掉也可以不死掉的错误，程序不应该死掉的错误。  </p>
</blockquote>
<h3 id="多线程-高并发"><a href="#多线程-高并发" class="headerlink" title="多线程 / 高并发"></a>多线程 / 高并发</h3><p><strong>66. stop() 和 suspend() 方法为何不推荐使用？</strong></p>
<blockquote>
<p><strong>反对使用 stop()，是因为它不安全</strong> 。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。  </p>
</blockquote>
<blockquote>
<p><strong>suspend() 方法容易发生死锁</strong> 。调用 suspend() 的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被 “挂起” 的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用 suspend()，而应在自己的 Thread 类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用 wait() 命其进入等待状态。若标志指出线程应当恢复，则用一个 notify() 重新启动线程。  </p>
</blockquote>
<p><strong>67. sleep() 和 wait() 有什么区别?</strong></p>
<blockquote>
<p>sleep 就是正在执行的线程主动让出 cpu，cpu 去执行其他线程，在 sleep 指定的时间过后，cpu 才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep 方法并不会释放锁，即使当前线程使用 sleep 方法让出了 cpu，但其他被同步锁挡住了的线程也无法得到执行。wait 是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了 notify 方法（notify 并不释放锁，只是告诉调用过 wait 方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果 notify 方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在 notfiy 方法后增加一个等待和一些代码，看看效果），调用 wait 方法的线程就会解除 wait 状态和程序可以再次得到锁后继续向下运行。  </p>
</blockquote>
<p><strong>68. 同步和异步有何异同，在什么情况下分别使用他们？</strong></p>
<blockquote>
<p>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。  </p>
</blockquote>
<blockquote>
<p>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。  </p>
</blockquote>
<p><strong>69. 当一个线程进入一个对象的一个 synchronized 方法后，其它线程是否可进入此对象的其它方法?</strong></p>
<ul>
<li><p>其他方法前是否加了 synchronized 关键字，如果没加，则能。</p>
</li>
<li><p>如果这个方法内部调用了 wait，则可以进入其他 synchronized 方法。</p>
</li>
<li><p>如果其他个方法都加了 synchronized 关键字，并且内部没有调用 wait，则不能。</p>
</li>
<li><p>如果其他方法是 static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是 this。</p>
</li>
</ul>
<p><strong>70. 简述 synchronized 和 java.util.concurrent.locks.Lock 的异同？</strong></p>
<blockquote>
<p>主要相同点：Lock 能完成 synchronized 所实现的所有功能。  </p>
</blockquote>
<blockquote>
<p>主要不同点：Lock 有比 synchronized 更精确的线程语义和更好的性能。synchronized 会自动释放锁，而 Lock 一定要求程序员手工释放，并且必须在 finally 从句中释放。Lock 还有更强大的功能，例如，它的 tryLock 方法可以非阻塞方式去拿锁。  </p>
</blockquote>
<blockquote>
<p>举例说明（对下面的题用 lock 进行了改写）  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class ThreadTest &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * @param args</span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">  private int j;</span><br><span class="line">  private Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">      ThreadTest tt &#x3D; new ThreadTest();</span><br><span class="line">      for(int i&#x3D;0;i&lt;2;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          new Thread(tt.new Adder()).start();</span><br><span class="line">          new Thread(tt.new Subtractor()).start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private class Subtractor implements Runnable</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">          while(true)</span><br><span class="line">          &#123;</span><br><span class="line">              &#x2F;*synchronized (ThreadTest.this) &#123;          </span><br><span class="line">                  System.out.println(&quot;j--&#x3D;&quot; + j--);</span><br><span class="line">                  &#x2F;&#x2F;这里抛异常了，锁能释放吗？</span><br><span class="line">              &#125;*&#x2F;</span><br><span class="line">              lock.lock();</span><br><span class="line">              try</span><br><span class="line">              &#123;</span><br><span class="line">                  System.out.println(&quot;j--&#x3D;&quot; + j--);</span><br><span class="line">              &#125;finally</span><br><span class="line">              &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private class Adder implements Runnable</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">          while(true)</span><br><span class="line">          &#123;</span><br><span class="line">              &#x2F;*synchronized (ThreadTest.this) &#123;</span><br><span class="line">              System.out.println(&quot;j++&#x3D;&quot; + j++);   </span><br><span class="line">              &#125;*&#x2F;</span><br><span class="line">              lock.lock();</span><br><span class="line">              try</span><br><span class="line">              &#123;</span><br><span class="line">                  System.out.println(&quot;j++&#x3D;&quot; + j++);</span><br><span class="line">              &#125;finally</span><br><span class="line">              &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">              &#125;               </span><br><span class="line">          &#125;           </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>71. 概括的解释下线程的几种可用状态。</strong></p>
<ul>
<li><p>新建 new。</p>
</li>
<li><p>就绪 放在可运行线程池中，等待被线程调度选中，获取 cpu。</p>
</li>
<li><p>运行 获得了 cpu。</p>
</li>
<li><p>阻塞</p>
<ul>
<li>等待阻塞 执行 wait() 。</li>
<li>同步阻塞 获取对象的同步琐时，同步锁被别的线程占用。</li>
<li>其他阻塞 执行了 sleep() 或 join() 方法)。</li>
</ul>
</li>
<li><p>死亡。</p>
</li>
</ul>
<p><strong>72. 什么是 ThreadLocal?</strong></p>
<blockquote>
<p>ThreadLocal 用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择 ThreadLocal 变量。  </p>
</blockquote>
<blockquote>
<p>每个线程都会拥有他们自己的 Thread 变量，它们可以使用 get()\set() 方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal 实例通常是希望它们同线程状态关联起来是 private static 属性。  </p>
</blockquote>
<p><strong>73. run() 和 start() 区别。</strong></p>
<blockquote>
<p><strong>run( )：</strong> 只是调用普通 run 方法  </p>
</blockquote>
<blockquote>
<p><strong>start( )：</strong> 启动了线程, 由 Jvm 调用 run 方法  </p>
</blockquote>
<blockquote>
<p>启动一个线程是调用 start() 方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由 JVM 调度并执行。这并不意味着线程就会立即运行。run() 方法可以产生必须退出的标志来停止一个线程。  </p>
</blockquote>
<p><strong>74. 请说出你所知道的线程同步的方法。</strong></p>
<blockquote>
<p><strong>wait()：</strong> 使一个线程处于等待状态，并且释放所持有的对象的 lock。 <strong>sleep()：</strong> 使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉 InterruptedException 异常。 <strong>notify()：</strong> 唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且不是按优先级。 <strong>notityAll()：</strong> 唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。  </p>
</blockquote>
<p><strong>75. 线程调度和线程控制。</strong></p>
<blockquote>
<p>线程调度（优先级）:  </p>
</blockquote>
<blockquote>
<p>与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取 CPU 资源的概率较大，优先级低的并非没机会执行。 线程的优先级用 1-10 之间的整数表示，数值越大优先级越高，默认的优先级为 5。 在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。  </p>
</blockquote>
<blockquote>
<p><strong>线程控制</strong>  </p>
</blockquote>
<ul>
<li><p><strong>sleep( )</strong> // 线程休眠 <strong>join( )</strong> // 线程加入 <strong>yield( )</strong> // 线程礼让 <strong>setDaemon( )</strong> // 线程守护</p>
<blockquote>
<p><strong>中断线程</strong>  </p>
</blockquote>
</li>
<li><p><strong>stop( )</strong> <strong>interrupt( )</strong> ==(首先选用)==</p>
</li>
<li><p><em>76. 什么是线程饿死，什么是活锁？*</em></p>
</li>
</ul>
<blockquote>
<p>当所有线程阻塞，或者由于需要的资源无效而不能处理，不存在非阻塞线程使资源可用。JavaAPI 中线程活锁可能发生在以下情形：  </p>
</blockquote>
<ul>
<li><p>当所有线程在序中执行 Object.wait(0)，参数为 0 的 wait 方法。程序将发生活锁直到在相应的对象上有线程调用 Object.notify() 或者 Object.notifyAll()。</p>
</li>
<li><p>当所有线程卡在无限循环中。</p>
</li>
</ul>
<p><strong>77. 多线程中的忙循环是什么?</strong></p>
<blockquote>
<p>忙循环就是程序员用循环让一个线程等待，不像传统方法 wait(), sleep() 或 yield() 它们都放弃了 CPU 控制，而忙循环不会放弃 CPU，它就是在运行一个空循环。这么做的目的是为了保留 CPU 缓存。  </p>
</blockquote>
<blockquote>
<p>在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。  </p>
</blockquote>
<p><strong>78. volatile 变量是什么？volatile 变量和 atomic 变量有什么不同？</strong></p>
<blockquote>
<p>volatile 则是保证了所修饰的变量的可见。因为 volatile 只是在保证了同一个变量在多线程中的可见性，所以它更多是用于修饰作为开关状态的变量，即 Boolean 类型的变量。  </p>
</blockquote>
<blockquote>
<p>volatile 多用于修饰类似开关类型的变量、Atomic 多用于类似计数器相关的变量、其它多线程并发操作用 synchronized 关键字修饰。  </p>
</blockquote>
<blockquote>
<p><strong>volatile 有两个功用</strong> ：  </p>
</blockquote>
<ul>
<li><p>这个变量不会在多个线程中存在复本，直接从内存读取。</p>
</li>
<li><p>这个关键字会禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。</p>
</li>
</ul>
<p><strong>79. volatile 类型变量提供什么保证？能使得一个非原子操作变成原子操作吗？</strong></p>
<blockquote>
<p>volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。  </p>
</blockquote>
<blockquote>
<p>在 Java 中除了 long 和 double 之外的所有基本类型的读和赋值，都是原子性操作。而 64 位的 long 和 double 变量由于会被 JVM 当作两个分离的 32 位来进行操作，所以不具有原子性，会产生字撕裂问题。但是当你定义 long 或 double 变量时，如果使用 volatile 关键字，就会获到（简单的赋值与返回操作的）原子性。  </p>
</blockquote>
<h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><p><strong>80. ArrayList 和 Vector 的区别。</strong></p>
<blockquote>
<p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，并且其中的数据是允许重复的，这是 HashSet 之类的集合的最大不同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素（本来题目问的与 hashset 没有任何关系，但为了说清楚 ArrayList 与 Vector 的功能，我们使用对比方式，更有利于说明问题）。接着才说 ArrayList 与 Vector 的区别，这主要包括两个方面。  </p>
</blockquote>
<ul>
<li>同步性：<blockquote>
<p>Vector 是线程安全的，也就是说是它的方法之间是线程同步的，而 ArrayList 是线程序不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用 ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。  </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>备注：对于 Vector&amp;ArrayList、Hashtable&amp;HashMap，要记住线程安全的问题，记住 Vector 与 Hashtable 是旧的，是 java 一诞生就提供了的，它们是线程安全的，ArrayList 与 HashMap 是 java2 时才提供的，它们是线程不安全的。所以，我们讲课时先讲老的。  </p>
</blockquote>
<ul>
<li>数据增长：<blockquote>
<p>ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加 ArrayList 与 Vector 的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector 默认增长为原来两倍，而 ArrayList 的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的 1.5 倍）。ArrayList 与 Vector 都可以设置初始的空间大小，Vector 还可以设置增长的空间大小，而 ArrayList 没有提供设置增长空间的方法。  </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>总结：即 Vector 增长原来的一倍，ArrayList 增加原来的 0.5 倍。  </p>
</blockquote>
<p><strong>81. 说说 ArrayList,Vector, LinkedList 的存储性能和特性。</strong></p>
<blockquote>
<p>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 由于使用了 synchronized 方法（线程安全）。  </p>
</blockquote>
<blockquote>
<p>通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快 。  </p>
</blockquote>
<blockquote>
<p>ArrayList 在查找时速度快，LinkedList 在插入与删除时更具优势。  </p>
</blockquote>
<p><strong>83. 快速失败 (fail-­fast) 和安全失败 (fail-­safe) 的区别是什么？</strong></p>
<blockquote>
<p>Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util 包下面的所有的集合类都是快速失败的，而 java.util.concurrent 包下面的所有的类都是安全失败的。快速失败的迭代器会抛出 ConcurrentModificationException 异常，而安全失败的迭代器永远不会抛出这样的异常。  </p>
</blockquote>
<p><strong>84. hashmap 的数据结构。</strong></p>
<blockquote>
<p>在 java 编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，hashmap 也不例外。Hashmap 实际上是一个数组和链表的结合体（在数据结构中，一般称之为 “链表散列 “）  </p>
</blockquote>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//upload-images.jianshu.io/upload_images/127268-da2e47d551af3f54?imageMogr2/auto-orient/strip%257CimageView2/2/w/576/format/webp" alt=""></p>
<blockquote>
<p>enter image description here  </p>
</blockquote>
<p><strong>85. HashMap 的工作原理是什么?</strong></p>
<blockquote>
<p>Java 中的 HashMap 是以键值对 (key-­value) 的形式存储元素的。HashMap 需要一个 hash 函数，它使用 hashCode()和 equals()方法来向集合 / 从集合添加和检索元素。当调用 put() 方法的时候，HashMap 会计算 key 的 hash 值，然后把键值对存储在集合中合适的索引上。 如果 key 已经存在了，value 会被更新成新值。HashMap 的一些重要的特性是它的容量 (capacity)，负载因子 (load factor) 和扩容极限(threshold resizing)。  </p>
</blockquote>
<p><strong>86. Hashmap 什么时候进行扩容呢？</strong></p>
<blockquote>
<p>当 hashmap 中的元素个数超过数组大小 loadFactor 时，就会进行数组扩容，loadFactor 的默认值为 0.75，也就是说，默认情况下，数组大小为 16，那么当 hashmap 中元素个数超过 16 <em>0.75=12 的时候，就把数组的大小扩展为 2</em> 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知 hashmap 中元素的个数，那么预设元素的个数能够有效的提高 hashmap 的性能。比如说，我们有 1000 个元素 new HashMap(1000), 但是理论上来讲 new HashMap(1024) 更合适，不过上面 annegu 已经说过，即使是 1000，hashmap 也自动会将其设置为 1024。 但是 new HashMap(1024) 还不是更合适的，因为 0.75*1000 &lt; 1000, 也就是说为了让 0.75 * size &gt; 1000, 我们必须这样 new HashMap(2048) 才最合适，既考虑了 &amp; 的问题，也避免了 resize 的问题。  </p>
</blockquote>
<p><strong>87. List、Map、Set 三个接口，存取元素时，各有什么特点？</strong></p>
<blockquote>
<p>这样的题属于随意发挥题：这样的题比较考水平，两个方面的水平：一是要真正明白这些内容，二是要有较强的总结和表述能力。如果你明白，但表述不清楚，在别人那里则等同于不明白。  </p>
</blockquote>
<blockquote>
<p>首先，List 与 Set 具有相似性，它们都是单列元素的集合，所以，它们有一个功共同的父接口，叫 Collection。Set 里面不允许有重复的元素，所谓重复，即不能有两个相等（注意，不是仅仅是相同）的对象 ，即假设 Set 集合中有了一个 A 对象，现在我要向 Set 集合再存入一个 B 对象，但 B 对象与 A 对象 equals 相等，则 B 对象存储不进去，所以，Set 集合的 add 方法有一个 boolean 的返回值，当集合中没有某个元素，此时 add 方法可成功加入该元素时，则返回 true，当集合含有与某个元素 equals 相等的元素时，此时 add 方法无法加入该元素，返回结果为 false。Set 取元素时，没法说取第几个，只能以 Iterator 接口取得所有的元素，再逐一遍历各个元素。  </p>
</blockquote>
<blockquote>
<p>List 表示有先后顺序的集合， 注意，不是那种按年龄、按大小、按价格之类的排序。当我们多次调用 add(Obj e) 方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来后到的顺序排序。有时候，也可以插队，即调用 add(int index,Obj e) 方法，就可以指定当前对象在集合中的存放位置。一个对象可以被反复存储进 List 中，每调用一次 add 方法，这个对象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被 add 多次时，即相当于集合中有多个索引指向了这个对象，如图 x 所示。List 除了可以以 Iterator 接口取得所有的元素，再逐一遍历各个元素之外，还可以调用 get(index i) 来明确说明取第几个。  </p>
</blockquote>
<blockquote>
<p>Map 与 List 和 Set 不同，它是双列的集合，其中有 put 方法，定义如下：put(obj key,obj value)，每次存储时，要存储一对 key/value，不能存储重复的 key，这个重复的规则也是按 equals 比较相等。取则可以根据 key 获得相应的 value，即 get(Object key) 返回值为 key 所对应的 value。另外，也可以获得所有的 key 的结合，还可以获得所有的 value 的结合，还可以获得 key 和 value 组合成的 Map.Entry 对象的集合。  </p>
</blockquote>
<blockquote>
<p>List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素, 内部排序。Map 保存 key-value 值，value 可多值。  </p>
</blockquote>
<blockquote>
<p>HashSet 按照 hashcode 值的某种运算方式进行存储，而不是直接按 hashCode 值的大小进行存储。例如，”abc” —&gt; 78，”def” —&gt; 62，”xyz” —&gt; 65 在 hashSet 中的存储顺序不是 62,65,78，这些问题感谢以前一个叫崔健的学员提出，最后通过查看源代码给他解释清楚，看本次培训学员当中有多少能看懂源码。LinkedHashSet 按插入的顺序存储，那被存储对象的 hashcode 方法还有什么作用呢？学员想想! hashset 集合比较两个对象是否相等，首先看 hashcode 方法是否相等，然后看 equals 方法是否相等。new 两个 Student 插入到 HashSet 中，看 HashSet 的 size，实现 hashcode 和 equals 方法后再看 size。  </p>
</blockquote>
<blockquote>
<p>同一个对象可以在 Vector 中加入多次。往集合里面加元素，相当于集合里用一根绳子连接到了目标对象。往 HashSet 中却加不了多次的。  </p>
</blockquote>
<p><strong>88. Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用 == 还是 equals()? 它们有何区别?</strong></p>
<blockquote>
<p>Set 里的元素是不能重复的，元素重复与否是使用 equals() 方法进行判断的。  </p>
</blockquote>
<blockquote>
<p>equals() 和 == 方法决定引用值是否指向同一对象 equals() 在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。  </p>
</blockquote>
<p><strong>89. 两个对象值相同 (x.equals(y) == true)，但却可有不同的 hash code，这句话对不对?</strong></p>
<blockquote>
<p>对。如果对象要保存在 HashSet 或 HashMap 中，它们的 equals 相等，那么，它们的 hashcode 值就必须相等。  </p>
</blockquote>
<blockquote>
<p>如果不是要保存在 HashSet 或 HashMap，则与 hashcode 没有什么关系了，这时候 hashcode 不等是可以的，例如 arrayList 存储的对象就不用实现 hashcode，当然，我们没有理由不实现，通常都会去实现的。  </p>
</blockquote>
<p><strong>90. heap 和 stack 有什么区别。</strong></p>
<blockquote>
<p>Java 的内存分为两类，一类是 <strong>栈内存</strong> ，一类是 <strong>堆内存</strong> 。栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。  </p>
</blockquote>
<blockquote>
<p>堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用 new 创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用 final 修饰后，放在堆中，而不是栈中。  </p>
</blockquote>
<p><strong>91. Java 集合类框架的基本接口有哪些？</strong></p>
<blockquote>
<p>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它 自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。  </p>
</blockquote>
<blockquote>
<p>Java 集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java 集合类里面 最基本的接口有：  </p>
</blockquote>
<blockquote>
<p><strong>Collection：</strong> 代表一组对象，每一个对象都是它的子元素。  </p>
</blockquote>
<blockquote>
<p><strong>Set：</strong> 不包含重复元素的 Collection。  </p>
</blockquote>
<blockquote>
<p><strong>List：</strong> 有顺序的 collection，并且可以包含重复元素。  </p>
</blockquote>
<blockquote>
<p><strong>Map：</strong> 可以把键 (key) 映射到值 (value) 的对象，键不能重复。  </p>
</blockquote>
<p><strong>92. HashSet 和 TreeSet 有什么区别？</strong></p>
<blockquote>
<p>HashSet 是由一个 hash 表来实现的，因此，它的元素是无序的。add()，remove()，contains()  </p>
</blockquote>
<blockquote>
<p>TreeSet 是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()， remove()，contains() 方法的时间复杂度是 O(logn)。  </p>
</blockquote>
<p><strong>93. HashSet 的底层实现是什么?</strong></p>
<blockquote>
<p>通过看源码知道 HashSet 的实现是依赖于 HashMap 的，HashSet 的值都是存储在 HashMap 中的。在 HashSet 的构造法中会初始化一个 HashMap 对象，HashSet 不允许值重复，因此，HashSet 的值是作为 HashMap 的 key 存储在 HashMap 中的，当存储的值已经存在时返回 false。  </p>
</blockquote>
<p><strong>94. LinkedHashMap 的实现原理?</strong></p>
<blockquote>
<p>LinkedHashMap 也是基于 HashMap 实现的，不同的是它定义了一个 Entry header，这个 header 不是放在 Table 里，它是额外独立出来的。LinkedHashMap 通过继承 hashMap 中的 Entry, 并添加两个属性 Entry before,after, 和 header 结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。LinkedHashMap 定义了排序模式 accessOrder，该属性为 boolean 型变量，对于访问顺序，为 true；对于插入顺序，则为 false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。  </p>
</blockquote>
<p><strong>95. 为什么集合类没有实现 Cloneable 和 Serializable 接口？</strong></p>
<blockquote>
<p>克隆 (cloning) 或者是序列化 (serialization) 的语义和含义是跟具体的实现相关的。因此，应该 由集合类的具体实现来决定如何被克隆或者是序列化。  </p>
</blockquote>
<p><strong>96. 什么是迭代器 (Iterator)？</strong></p>
<blockquote>
<p>Iterator 接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代 器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素, 但是不可以直接调用集合的 remove(Object Obj) 删除，可以通过迭代器的 remove() 方法删除。  </p>
</blockquote>
<p><strong>97. Iterator 和 ListIterator 的区别是什么？</strong></p>
<blockquote>
<p>下面列出了他们的区别：  </p>
</blockquote>
<blockquote>
<p>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。  </p>
</blockquote>
<blockquote>
<p>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。  </p>
</blockquote>
<blockquote>
<p>ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。  </p>
</blockquote>
<p><strong>98. 数组 (Array) 和列表 (ArrayList) 有什么区别？什么时候应该使用 Array 而不是 ArrayList？</strong></p>
<blockquote>
<p>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。  </p>
</blockquote>
<blockquote>
<p>Array 大小是固定的，ArrayList 的大小是动态变化的。  </p>
</blockquote>
<blockquote>
<p>ArrayList 处理固定大小的基本数据类型的时候，这种方式相对比较慢。  </p>
</blockquote>
<p><strong>99. Java 集合类框架的最佳实践有哪些？</strong></p>
<ul>
<li>假如元素的大小是固 定的，而且能事先知道，我们就应该用 Array 而不是 ArrayList。</li>
<li>有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置 初始容量来避免重新计算 hash 值或者是扩容。</li>
<li>为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的 ClassCastException。</li>
<li>使用 JDK 提供的不变类 (immutable class) 作为 Map 的键可以避免为我们自己的类实现 hashCode()和 equals()方法。</li>
<li>编程的时候接口优于实现。</li>
<li>底层的集合实际上是空的情况下，返回长度是 0 的集合或者是数组，不要返回 null。</li>
<li><em>100. Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用 == 还是 equals()？它们有何区别？*</em></li>
</ul>
<blockquote>
<p>Set 里的元素是不能重复的，那么用 iterator() 方法来区分重复与否。equals() 是判读两个 Set 是否相等  </p>
</blockquote>
<blockquote>
<p>equals() 和 == 方法决定引用值是否指向同一对象 equals() 在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值  </p>
</blockquote>
<p><strong>101. Comparable 和 Comparator 接口是干什么的？列出它们的区别。</strong></p>
<blockquote>
<p>Java 提供了只包含一个 compareTo() 方法的 Comparable 接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。  </p>
</blockquote>
<blockquote>
<p>Java 提供了包含 compare() 和 equals() 两个方法的 Comparator 接口。compare() 方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals() 方法需要一个对象作为参数，它用来决定输入参数是否和 comparator 相等。只有当输入参数也是一个 comparator 并且输入参数和当前 comparator 的排序结果是相同的时 候，这个方法才返回 true。  </p>
</blockquote>
<p><strong>102. Collection 和 Collections 的区别。</strong></p>
<blockquote>
<p>collection 是集合类的上级接口, 继承与它的接口主要是 set 和 list。  </p>
</blockquote>
<blockquote>
<p>collections 类是针对集合类的一个帮助类. 它提供一系列的静态方法对各种集合的搜索, 排序, 线程安全化等操作。  </p>
</blockquote>
<h3 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h3><p><strong>103. 字节流与字符流的区别。</strong></p>
<blockquote>
<p>要把一片二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为 IO 流，对应的抽象类为 OutputStream 和 InputStream ，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。  </p>
</blockquote>
<blockquote>
<p>在应用中，经常要完全是字符的一段文本输出去或读进来，用字节流可以吗？计算机中的一切最终都是二进制的字节形式存在。对于 “中国” 这些字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。  </p>
</blockquote>
<blockquote>
<p>底层设备永远只接受 <strong>字节数据</strong> ，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向 IO 设别写入或读取字符串提供了一点点方便。  </p>
</blockquote>
<blockquote>
<p>字符向字节转换时，要注意编码的问题，因为字符串转成字节数组，  </p>
</blockquote>
<blockquote>
<p>其实是转成该字符的某种编码的字节形式，读取也是反之的道理。  </p>
</blockquote>
<blockquote>
<p>讲解字节流与字符流关系的代码案例：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line">public class IOTest &#123;</span><br><span class="line">     public static void main(String[] args) throws Exception &#123;</span><br><span class="line">           String str &#x3D; &quot;中国人&quot;;</span><br><span class="line">           &#x2F;*FileOutputStream fos  &#x3D; new FileOutputStream(&quot;1.txt&quot;);</span><br><span class="line">           fos.write(str.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">           fos.close();*&#x2F;</span><br><span class="line">           &#x2F;*FileWriter fw &#x3D; new FileWriter(&quot;1.txt&quot;);</span><br><span class="line">           fw.write(str);</span><br><span class="line">           fw.close();*&#x2F;</span><br><span class="line">           PrintWriter pw &#x3D; new PrintWriter(&quot;1.txt&quot;,&quot;utf-8&quot;);</span><br><span class="line">           pw.write(str);</span><br><span class="line">           pw.close();</span><br><span class="line">           &#x2F;*FileReader fr &#x3D; new FileReader(&quot;1.txt&quot;);</span><br><span class="line">         char[] buf &#x3D; new char[1024];</span><br><span class="line">           int len &#x3D; fr.read(buf);</span><br><span class="line">           String myStr &#x3D; new String(buf,0,len);</span><br><span class="line">           System.out.println(myStr);*&#x2F;</span><br><span class="line">           &#x2F;*FileInputStream fr &#x3D; new FileInputStream(&quot;1.txt&quot;);</span><br><span class="line">           byte[] buf &#x3D; new byte[1024];</span><br><span class="line">           int len &#x3D; fr.read(buf);</span><br><span class="line">           String myStr &#x3D; new String(buf,0,len,&quot;UTF-8&quot;);</span><br><span class="line">           System.out.println(myStr);*&#x2F;</span><br><span class="line">           BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(new FileInputStream(&quot;1.txt&quot;),&quot;UTF-8&quot;));</span><br><span class="line">           String myStr &#x3D; br.readLine();</span><br><span class="line">           br.close();</span><br><span class="line">           System.out.println(myStr);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>104. 什么是 Java 序列化，如何实现 Java 序列化？或者请解释 Serializable 接口的作用。</strong></p>
<blockquote>
<p>我们有时候将一个 Java 对象变成字节流的形式传出去或者从一个字节流中恢复成一个 Java 对象，例如，要将 Java 对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个 Java 对象变成某个格式的字节流再传输，但是，jre 本身就提供了这种支持，我们可以调用 OutputStream 的 writeObject 方法来做，如果要让 Java 帮我们做，要被传输的对象必须实现 serializable 接口，这样，javac 编译时就会进行特殊处理，编译的类才可以被 writeObject 方法操作，这就是所谓的序列化。需要被序列化的类必须实现 Serializable 接口，该接口是一个 mini 接口，其中没有需要实现的方法，implements Serializable 只是为了标注该对象是可被序列化的。  </p>
</blockquote>
<blockquote>
<p>例如，在 web 开发中，如果对象被保存在了 Session 中，tomcat 在重启时要把 Session 对象序列化到硬盘，这个对象就必须实现 Serializable 接口。如果对象要经过分布式系统进行网络传输或通过 rmi 等远程调用，这就需要在网络上传输对象，被传输的对象就必须实现 Serializable 接口。  </p>
</blockquote>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p><strong>105. 请简洁描述 MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？</strong></p>
<blockquote>
<p>SQL 标准定义的四个隔离级别为：  </p>
</blockquote>
<blockquote>
<p><strong>read uncommited ：</strong> 读到未提交数据  </p>
</blockquote>
<blockquote>
<p><strong>read committed：</strong> 脏读，不可重复读  </p>
</blockquote>
<blockquote>
<p><strong>repeatable read：</strong> 可重读  </p>
</blockquote>
<blockquote>
<p><strong>serializable ：</strong> 串行事物  </p>
</blockquote>
<p><strong>106. 在 MySQL 中 ENUM 的用法是什么？</strong></p>
<blockquote>
<p>ENUM 是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。  </p>
</blockquote>
<blockquote>
<p>SQL 语法如下：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Create table size(name ENUM(&#39;Smail,&#39;Medium&#39;,&#39;Large&#39;);</span><br></pre></td></tr></table></figure>

<p><strong>107. CHAR 和 VARCHAR 的区别？</strong></p>
<blockquote>
<p>CHAR 和 VARCHAR 类型在存储和检索方面有所不同。  </p>
</blockquote>
<blockquote>
<p>CHAR 列长度固定为创建表时声明的长度，长度值范围是 1 到 255。  </p>
</blockquote>
<blockquote>
<p>当 CHAR 值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需删除尾随空格。  </p>
</blockquote>
<p><strong>108. 列的字符串类型可以是什么？</strong></p>
<blockquote>
<p>字符串类型是：  </p>
</blockquote>
<blockquote>
<p>SET  </p>
</blockquote>
<blockquote>
<p>BLOB  </p>
</blockquote>
<blockquote>
<p>ENUM  </p>
</blockquote>
<blockquote>
<p>CHAR  </p>
</blockquote>
<blockquote>
<p>TEXT  </p>
</blockquote>
<blockquote>
<p>VARCHAR  </p>
</blockquote>
<p><strong>109. MySQL 中使用什么存储引擎？</strong></p>
<blockquote>
<p>存储引擎称为表类型，数据使用各种技术存储在文件中。  </p>
</blockquote>
<blockquote>
<p>技术涉及：  </p>
</blockquote>
<blockquote>
<p>Storage mechanism  </p>
</blockquote>
<blockquote>
<p>Locking levels  </p>
</blockquote>
<blockquote>
<p>Indexing  </p>
</blockquote>
<blockquote>
<p>Capabilities and functions.  </p>
</blockquote>
<p><strong>110. TIMESTAMP 在 UPDATE CURRENT_TIMESTAMP 数据类型上做什么？</strong></p>
<blockquote>
<p>创建表时 TIMESTAMP 列用 Zero 更新。只要表中的其他字段发生更改，UPDATE CURRENT_TIMESTAMP 修饰符就将时间戳字段更新为当前时间。  </p>
</blockquote>
<p><strong>111. 主键和候选键有什么区别？</strong></p>
<blockquote>
<p>表格的每一行都由主键唯一标识, 一个表只有一个主键。  </p>
</blockquote>
<blockquote>
<p>主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。  </p>
</blockquote>
<p><strong>112. MySQL 数据库服务器性能分析的方法命令有哪些?</strong></p>
<blockquote>
<p>Show status 一些值得监控的变量值： Bytes <em>received 和 Bytes</em> sent 和服务器之间来往的流量。 Com <strong>服务器正在执行的命令。 Created</strong> 在查询执行期限间创建的临时表和文件。 Handler <strong>存储引擎操作。 Select</strong> 不同类型的联接执行计划。 Sort_* 几种排序信息。 Show session status like ‘Select’; Show profiles SET profiling=1; Show profiles\G Show profile;  </p>
</blockquote>
<p><strong>113. LIKE 和 REGEXP 操作有什么区别？</strong></p>
<blockquote>
<p>LIKE 和 REGEXP 运算符用于表示 ^ 和％。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;tablename&gt; WHERE * REGEXP &quot;^b&quot;;</span><br><span class="line">SELECT * FROM &lt;tablename&gt; WHERE * LIKE &quot;%b&quot;;</span><br></pre></td></tr></table></figure>

<p><strong>114. BLOB 和 TEXT 有什么区别？</strong></p>
<h1 id="BLOB"><a href="#BLOB" class="headerlink" title="BLOB"></a><strong>BLOB</strong></h1><blockquote>
<p>BLOB 是一个二进制对象，可以容纳可变数量的数据。有四种类型的 BLOB  </p>
</blockquote>
<ul>
<li>TINYBLOB</li>
<li>BLOB</li>
<li>MEDIUMBLOB 和</li>
<li>LONGBLOB<blockquote>
<p>它们只能在所能容纳价值的最大长度上有所不同。  </p>
</blockquote>
</li>
</ul>
<h1 id="TEXT"><a href="#TEXT" class="headerlink" title="TEXT"></a><strong>TEXT</strong></h1><blockquote>
<p>TEXT 是一个不区分大小写的 BLOB。四种 TEXT 类型  </p>
</blockquote>
<ul>
<li>TINYTEXT</li>
<li>TEXT</li>
<li>MEDIUMTEXT 和</li>
<li>LONGTEXT<blockquote>
<p>它们对应于四种 BLOB 类型，并具有相同的最大长度和存储要求。  </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>BLOB 和 TEXT 类型之间的唯一区别在于对 BLOB 值进行排序和比较时区分大小写，对 TEXT 值不区分大小写。  </p>
</blockquote>
<p><strong>115. 数据库的三范式？</strong></p>
<blockquote>
<p>第一范式：数据库表的每一个字段都是不可分割的。  </p>
</blockquote>
<blockquote>
<p>第二范式：数据库表中的非主属性只依赖于主键。  </p>
</blockquote>
<blockquote>
<p>第三范式：不存在非主属性对关键字的传递函数依赖关系。  </p>
</blockquote>
<p><strong>116. MySQL 表中允许有多少个 TRIGGERS？</strong></p>
<blockquote>
<p>在 MySQL 表中允许有六个触发器，如下：  </p>
</blockquote>
<blockquote>
<p>BEFORE INSERT  </p>
</blockquote>
<blockquote>
<p>AFTER INSERT  </p>
</blockquote>
<blockquote>
<p>BEFORE UPDATE  </p>
</blockquote>
<blockquote>
<p>AFTER UPDATE  </p>
</blockquote>
<blockquote>
<p>BEFORE DELETE and  </p>
</blockquote>
<blockquote>
<p>AFTER DELETE  </p>
</blockquote>
<p><strong>117. 什么是通用 SQL 函数？</strong></p>
<h1 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h1><ul>
<li>Abs（num）求绝对值</li>
<li>floor（num）向下取整</li>
<li>ceil（num）向上取整</li>
</ul>
<hr>
<h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><ul>
<li><p>insert (s1,index,length,s2) 替换函数</p>
<ul>
<li>S1 表示被替换的字符串</li>
<li>s2 表示将要替换的字符串</li>
<li>Index 表示被替换的位置, 从 1 开始</li>
<li>Lebgth 表示被替换的长度</li>
</ul>
</li>
<li><p>upper（str），ucase（str）将字母改为大写</p>
</li>
<li><p>lower（str），lcase（str）将字母改为小写</p>
</li>
<li><p>left（str，length）返回 str 字符串的前 length 个字符</p>
</li>
<li><p>right（str，length）返回 str 字符串的后 length 个字符</p>
</li>
<li><p>substring（str，index，length）返回 str 字符串从 index 位开始长度为 length 个字符（index 从 1 开始）</p>
</li>
<li><p>reverse（str）将 str 字符串倒序输出</p>
</li>
</ul>
<hr>
<h1 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h1><ul>
<li>curdate（）、current_date( ) 获取当前日期</li>
<li>curtime（）、current_time( ) 获取当前日期</li>
<li>now（）获取当前日期和时间</li>
<li>datediff（d1、d2）d1 和 d2 之间的天数差</li>
<li>adddate（date，num）返回 date 日期开始，之后 num 天的日期</li>
<li>subdate（date，num）返回 date 日期开始，之前 num 天的日期</li>
</ul>
<hr>
<h1 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h1><ul>
<li>Count（字段）根据某个字段统计总记录数（当前数据库保存到多少条数据）</li>
<li>sum（字段）计算某个字段的数值总和</li>
<li>avg（字段）计算某个字段的数值的平均值</li>
<li>Max（字段）、min（字段）求某个字段最大或最小值</li>
<li><em>118. MySQL 中有哪几种锁？*</em></li>
</ul>
<blockquote>
<p>MyISAM 支持表锁，InnoDB 支持表锁和行锁，默认为行锁。  </p>
</blockquote>
<blockquote>
<p>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。  </p>
</blockquote>
<blockquote>
<p>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。  </p>
</blockquote>
<p><strong>119. MySQL 数据优化。</strong></p>
<ul>
<li><p><strong>优化数据类型</strong></p>
<ul>
<li>避免使用 NULL，NULL 需要特殊处理, 大多数时候应该使用 NOT NULL，或者使用一个特殊的值，如 0，-1 作为默认值。</li>
<li>仅可能使用更小的字段，MySQL 从磁盘读取数据后是存储到内存中的，然后使用 cpu 周期和磁盘 I/O 读取它，这意味着越小的数据类型占用的空间越小.</li>
</ul>
</li>
<li><p><strong>小心字符集转换</strong></p>
<ul>
<li>客户端或应用程序使用的字符集可能和表本身的字符集不一样，这需要 MySQL 在运行过程中隐含地进行转换，此外，要确定字符集如 UTF-8 是否支持多字节字符，因此它们需要更多的存储空间。</li>
</ul>
</li>
<li><p>_ <em>优化 count(my</em> col) 和 count( <em>)</em> *</p>
</li>
<li><p><strong>优化子查询</strong></p>
<ul>
<li>遇到子查询时，MySQL 查询优化引擎并不是总是最有效的，这就是为什么经常将子查询转换为连接查询的原因了，优化器已经能够正确处理连接查询了，当然要注意的一点是，确保连接表 (第二个表) 的连接列是有索引的，在第一个表上 MySQL 通常会相对于第二个表的查询子集进行一次全表扫描，这是嵌套循环算法的一部分。</li>
</ul>
</li>
<li><p><strong>优化 UNION</strong></p>
<ul>
<li>在跨多个不同的数据库时使用 UNION 是一个有趣的优化方法，UNION 从两个互不关联的表中返回数据，这就意味着不会出现重复的行，同时也必须对数据进行排序，我们知道排序是非常耗费资源的，特别是对大表的排序。</li>
<li>UNION ALL 可以大大加快速度，如果你已经知道你的数据不会包括重复行，或者你不在乎是否会出现重复的行，在这两种情况下使用 UNION ALL 更适合。此外，还可以在应用程序逻辑中采用某些方法避免出现重复的行，这样 UNION ALL 和 UNION 返回的结果都是一样的，但 UNION ALL 不会进行排序。</li>
</ul>
</li>
</ul>
<p><strong>120. MySQL 的关键字。</strong></p>
<blockquote>
<p>添加索引：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table tableName add 索引（索引字段）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主键：primary key  </p>
</blockquote>
<blockquote>
<p>唯一：unique  </p>
</blockquote>
<blockquote>
<p>全局：fulltext  </p>
</blockquote>
<blockquote>
<p>普通：index  </p>
</blockquote>
<blockquote>
<p>多列： index index_name  </p>
</blockquote>
<blockquote>
<p>页级: 引擎 BDB。次锁定相邻的一组记录。  </p>
</blockquote>
<blockquote>
<p>表级: 引擎 MyISAM ， 理解为锁住整个表，可以同时读，写不行。 行级: 引擎 INNODB ， 单独的一行记录加锁，对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。 表级锁速度快，但冲突多，行级冲突少，但速度慢。  </p>
</blockquote>
<p><strong>121. 存储引擎。</strong></p>
<blockquote>
<p>存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。  </p>
</blockquote>
<ul>
<li><p>MyISAM：这种引擎是 mysql 最早提供的。这种引擎又可以分为静态 MyISAM、动态 MyISAM 和压缩 MyISAM 三种：</p>
<ul>
<li>静态 MyISAM：如果数据表中的各数据列的长度都是预先固定好的，服务器将自动选择这种表类型。因为数据表中每一条记录所占用的空间都是一样的，所以这种表存取和更新的效率非常高。当数据受损时，恢复工作也比较容易做。</li>
<li>动态 MyISAM：如果数据表中出现 varchar、text 或 BLOB 字段时，服务器将自动选择这种表类型。相对于静态 MyISAM，这种表存储空间比较小，但由于每条记录的长度不一，所以多次修改数据后，数据表中的数据就可能离散的存储在内存中，进而导致执行效率下降。同时，内存中也可能会出现很多碎片。因此，这种类型的表要经常用 optimize table 命令或优化工具来进行碎片整理。</li>
<li>压缩 MyISAM：以上说到的两种类型的表都可以用 myisamchk 工具压缩。这种类型的表进一步减小了占用的存储，但是这种表压缩之后不能再被修改。另外，因为是压缩数据，所以这种表在读取的时候要先时行解压缩。</li>
</ul>
</li>
</ul>
<blockquote>
<p>但是，不管是何种 MyISAM 表，目前它都不支持事务，行级锁和外键约束的功能。  </p>
</blockquote>
<ul>
<li><p>MyISAM Merge 引擎：这种类型是 MyISAM 类型的一种变种。合并表是将几个相同的 MyISAM 表合并为一个虚表。常应用于日志和数据仓库。</p>
</li>
<li><p>InnoDB：InnoDB 表类型可以看作是对 MyISAM 的进一步更新产品，它提供了事务、行级锁机制和外键约束的功能。</p>
</li>
<li><p>memory(heap)：这种类型的数据表只存在于内存中。它使用散列索引，所以数据的存取速度非常快。因为是存在于内存中，所以这种类型常应用于临时表中。</p>
</li>
<li><p>archive：这种类型只支持 select 和 insert 语句，而且不支持索引。</p>
</li>
<li><p>Desc[ribe] tablename：查看数据表的结构。</p>
</li>
<li><p>show engines：命令可以显示当前数据库支持的存储引擎情况。</p>
</li>
</ul>
<p><strong>122. 数据库备份。</strong></p>
<blockquote>
<p>必须要在未登录状态下  </p>
</blockquote>
<ul>
<li><p>导出整个数据库</p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出一个表</p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出一个数据库结构</p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u dbuser -p -d --add-drop-table dbname &gt;d:&#x2F;dbname_db.sql</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>-d 没有数据 –add-drop-table 在每个 create 语句之前增加一个 drop table  </p>
</blockquote>
<p><strong>123. truncate delete drop 的区别。</strong></p>
<blockquote>
<p><strong>drop(DDL 语句)：</strong> 是不可逆操作，会将表所占用空间全部释放掉；  </p>
</blockquote>
<blockquote>
<p><strong>truncate(DDL 语句)：</strong> 只针对于删除表的操作，在删除过程中不会激活与表有关的删除触发器并且不会把删除记录放在日志中；当表被 truncate 后，这个表和索引会恢复到初始大小；  </p>
</blockquote>
<blockquote>
<p><strong>delete(DML 语句)：</strong> 可以删除表也可以删除行，但是删除记录会被计入日志保存，而且表空间大小不会恢复到原来；  </p>
</blockquote>
<blockquote>
<p>执行速度：drop&gt;truncate&gt;delete。  </p>
</blockquote>
<p><strong>124. Redis 是什么？两句话做一下概括。</strong></p>
<blockquote>
<p>是一个完全开源免费的 key-value 内存数据库 2. 通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets。  </p>
</blockquote>
<ul>
<li><p>Redis 使用最佳方式是全部数据 in-memory。</p>
</li>
<li><p>Redis 更多场景是作为 Memcached 的替代者来使用。</p>
</li>
<li><p>当需要除 key/value 之外的更多数据类型支持时，使用 Redis 更合适。</p>
</li>
<li><p>当存储的数据不能被剔除时，使用 Redis 更合适。</p>
</li>
<li><p><em>125. Redis（管道，哈希）。*</em></p>
</li>
<li><p>Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。</p>
</li>
<li><p>Redis 支持数据的备份，即 master-slave 模式的数据备份。</p>
</li>
<li><p>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</p>
</li>
<li><p><em>126. Redis 实现原理或机制。*</em></p>
</li>
</ul>
<blockquote>
<p>Redis 是一个 key-value 存储系统。和 Memcached 类似，但是解决了断电后数据完全丢失的情况，而且她支持更多无化的 value 类型，除了和 string 外，还支持 lists（链表）、sets（集合）和 zsets（有序集合）几种数据类型。这些数据类型都支持 push/pop、add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。  </p>
</blockquote>
<blockquote>
<p>Redis 是一种基于客户端 - 服务端模型以及请求 / 响应协议的 TCP 服务。这意味着通常情况下一个请求会遵循以下步骤：  </p>
</blockquote>
<blockquote>
<p>客户端向服务端发送一个查询请求，并监听 Socket 返回，通常是以阻塞模式，等待服务端响应。服务端处理命令，并将结果返回给客户端。  </p>
</blockquote>
<blockquote>
<p>在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。  </p>
</blockquote>
<blockquote>
<p>Redis 管道技术最显著的优势是提高了 Redis 服务的性能。  </p>
</blockquote>
<blockquote>
<p>分区是分割数据到多个 Redis 实例的处理过程，因此每个实例只保存 key 的一个子集。  </p>
</blockquote>
<blockquote>
<p>通过利用多台计算机内存的和值，允许我们构造更大的数据库。  </p>
</blockquote>
<blockquote>
<p>通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。  </p>
</blockquote>
<blockquote>
<p>Redis 的一些特性在分区方面表现的不是很好：  </p>
</blockquote>
<blockquote>
<p>涉及多个 key 的操作通常是不被支持的。举例来说，当两个 set 映射到不同的 Redis 实例上时，你就不能对这两个 set 执行交集操作。  </p>
</blockquote>
<blockquote>
<p>涉及多个 key 的 Redis 事务不能使用。  </p>
</blockquote>
<blockquote>
<p>当使用分区时，数据处理较为复杂，比如你需要处理多个 rdb/aof 文件，并且从多个实例和主机备份持久化文件。  </p>
</blockquote>
<blockquote>
<p>增加或删除容量也比较复杂。Redis 集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做 presharding 的技术对此是有帮助的。  </p>
</blockquote>
<p><strong>127. Redis 有两种类型分区。</strong></p>
<blockquote>
<p>最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的 Redis 实例。  </p>
</blockquote>
<blockquote>
<p>比如，ID 从 0 到 10000 的用户会保存到实例 R0，ID 从 10001 到 20000 的用户会保存到 R1，以此类推。  </p>
</blockquote>
<blockquote>
<p>这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各 种对象的映射表，通常对 Redis 来说并非是好的方法。  </p>
</blockquote>
<blockquote>
<p>哈希分区：另外一种分区方法是 hash 分区。这对任何 key 都适用，也无需是 object_name: 这种形式，像下面描述的一样简单：  </p>
</blockquote>
<blockquote>
<p>用一个 hash 函数将 key 转换为一个数字，比如使用 crc32 hash 函数。对 key foobar 执行 crc32(foobar) 会输出类似 93024922 的整数。  </p>
</blockquote>
<blockquote>
<p>对这个整数取模，将其转化为 0-3 之间的数字，就可以将这个整数映射到 4 个 Redis 实例中的一个了。93024922 % 4 = 2，就是说 key foobar 应该被存到 R2 实例中。注意：取模操作是取除的余数，通常在多种编程语言中用 % 操作符实现。  </p>
</blockquote>
<blockquote>
<p>实际上，上面的集群模式还存在两个问题：  </p>
</blockquote>
<ol>
<li><p>扩容问题：</p>
</li>
<li><p>因为使用了一致性哈稀进行分片，那么不同的 key 分布到不同的 Redis-Server 上，当我们需要扩容时，需要增加机器到分片列表中，这时候会使得同样的 key 算出来落到跟原来不同的机器上，这样如果要取某一个值，会出现取不到的情况，对于这种情况，Redis 的作者提出了一种名为 Pre-Sharding 的方式：</p>
</li>
<li><p>Pre-Sharding 方法是将每一个台物理机上，运行多个不同断口的 Redis 实例，假如有三个物理机，每个物理机运行三个 Redis 实际，那么我们的分片列表中实际有 9 个 Redis 实例，当我们需要扩容时，增加一台物理机，步骤如下：</p>
<ol>
<li>在新的物理机上运行 Redis-Server；</li>
<li>该 Redis-Server 从属于 (slaveof) 分片列表中的某一 Redis-Server（假设叫 RedisA）；</li>
<li>等主从复制 (Replication) 完成后，将客户端分片列表中 RedisA 的 IP 和端口改为新物理机上 Redis-Server 的 IP 和端口；</li>
<li>停止 RedisA。<blockquote>
<p>这样相当于将某一 Redis-Server 转移到了一台新机器上。Prd-Sharding 实际上是一种在线扩容的办法，但还是很依赖 Redis 本身的复制功能的，如果主库快照数据文件过大，这个复制的过程也会很久，同时会给主库带来压力。所以做这个拆分的过程最好选择为业务访问低峰时段进行。  </p>
</blockquote>
</li>
</ol>
</li>
<li><p>单点故障问题：</p>
</li>
<li><p>还是用到 Redis 主从复制的功能，两台物理主机上分别都运行有 Redis-Server，其中一个 Redis-Server 是另一个的从库，采用双机热备技术，客户端通过虚拟 IP 访问主库的物理 IP，当主库宕机时，切换到从库的物理 IP。只是事后修复主库时，应该将之前的从库改为主库（使用命令 slaveof no one），主库变为其从库（使命令 slaveof IP PORT），这样才能保证修复期间新增数据的一致性。</p>
</li>
</ol>
<p><strong>128. 什么是 MongoDB。</strong></p>
<blockquote>
<p>非关系型数据库 (NoSql),Mongo DB 很好的实现了面向对象的思想 (OO 思想), 在 Mongo DB 中 每一条记录都是一个 Document 对象。Mongo DB 最大的优势在于所有的数据持久操作都无需开发人员手动编写 SQL 语句, 直接调用方法就可以轻松的实现 CRUD 操作.  </p>
</blockquote>
<p><strong>129. MongoDB 特点。</strong></p>
<blockquote>
<p>高性能、易部署、易使用，存储数据非常方便。主要功能特性有：  </p>
</blockquote>
<blockquote>
<p>面向集合存储，易存储对象类型的数据。  </p>
</blockquote>
<blockquote>
<p>模式自由。  </p>
</blockquote>
<blockquote>
<p>支持动态查询。  </p>
</blockquote>
<blockquote>
<p>支持完全索引，包含内部对象。  </p>
</blockquote>
<blockquote>
<p>支持查询。  </p>
</blockquote>
<blockquote>
<p>支持复制和故障恢复。  </p>
</blockquote>
<blockquote>
<p>使用高效的二进制数据存储，包括大型对象（如视频等）。  </p>
</blockquote>
<blockquote>
<p>自动处理碎片，以支持云计算层次的扩展性  </p>
</blockquote>
<blockquote>
<p>支持 Python，PHP，Ruby，Java，C，C#，Javascript，Perl 及 C++ 语言的驱动程序，社区中也提供了对 Erlang 及. NET 等平台的驱动程序。  </p>
</blockquote>
<blockquote>
<p>文件存储格式为 BSON（一种 JSON 的扩展）。  </p>
</blockquote>
<blockquote>
<p>可通过网络访问。  </p>
</blockquote>
<p><strong>130. MongoDB 的功能。</strong></p>
<blockquote>
<p>面向集合的存储：适合存储对象及 JSON 形式的数据。  </p>
</blockquote>
<blockquote>
<p>动态查询：Mongo 支持丰富的查询表达式。查询指令使用 JSON 形式的标记，可轻易查询文档中内嵌的对象及数组。  </p>
</blockquote>
<blockquote>
<p>完整的索引支持：包括文档内嵌对象及数组。Mongo 的查询优化器会分析查询表达式，并生成一个高效的查询计划。  </p>
</blockquote>
<blockquote>
<p>查询监视：Mongo 包含一个监视工具用于分析数据库操作的性能。  </p>
</blockquote>
<blockquote>
<p>复制及自动故障转移：Mongo 数据库支持服务器之间的数据复制，支持主 - 从模式及服务器之间的相互复制。复制的主要目标是提供冗余及自动故障转移。  </p>
</blockquote>
<blockquote>
<p>高效的传统存储方式：支持二进制数据及大型对象（如照片或图片）  </p>
</blockquote>
<blockquote>
<p>自动分片以支持云级别的伸缩性：自动分片功能支持水平的数据库集群，可动态添加额外的机器。  </p>
</blockquote>
<p><strong>131. MongoDB 的适用场景。</strong></p>
<blockquote>
<p>网站数据：Mongo 非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。  </p>
</blockquote>
<blockquote>
<p>缓存：由于性能很高，Mongo 也适合作为信息基础设施的缓存层。在系统重启之后，由 Mongo 搭建的持久化缓存层可以避免下层的数据源 过载。  </p>
</blockquote>
<blockquote>
<p>大尺寸，低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储。  </p>
</blockquote>
<blockquote>
<p>高伸缩性的场景：Mongo 非常适合由数十或数百台服务器组成的数据库。Mongo 的路线图中已经包含对 MapReduce 引擎的内置支持。  </p>
</blockquote>
<blockquote>
<p>用于对象及 JSON 数据的存储：Mongo 的 BSON 数据格式非常适合文档化格式的存储及查询。  </p>
</blockquote>
<p><strong>132. Redis、memcache、MongoDB 对比。</strong></p>
<blockquote>
<p>mongodb 和 memcached 不是一个范畴内的东西。mongodb 是文档型的非关系型数据库，其优势在于查询功能比较强大，能存储海量数据。  </p>
</blockquote>
<blockquote>
<p>和 memcached 更为接近的是 Redis。它们都是内存型数据库，数据保存在内存中，通过 tcp 直接存取，优势是速度快，并发高，缺点是数据类型有限，查询功能不强，一般用作缓存。  </p>
</blockquote>
<ol>
<li><p>性能</p>
</li>
<li><p>Redis 和 memcache 差不多，要大于 mongodb。</p>
</li>
<li><p>操作的便利性</p>
</li>
<li><p>memcache 数据结构单一。</p>
</li>
<li><p>Redis 丰富一些，数据操作方面，Redis 更好一些，较少的网络 IO 次数。</p>
</li>
<li><p>mongodb 支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富。</p>
</li>
<li><p>内存空间的大小和数据量的大小</p>
</li>
<li><p>Redis 在 2.0 版本后增加了自己的 VM 特性，突破物理内存的限制；可以对 key value 设置过期时间（类似 memcache）。</p>
</li>
<li><p>memcache 可以修改最大可用内存, 采用 LRU 算法。</p>
</li>
<li><p>mongoDB 适合大数据量的存储，依赖操作系统 VM 做内存管理，吃内存也比较厉害，服务不要和别的服务在一起。</p>
</li>
<li><p>可用性（单点问题）</p>
</li>
<li><p>Redis 对于单点问题，依赖客户端来实现分布式读写；主从复制时，每次从节点重新连接主节点都要依赖整个快照, 无增量复制，因性能和效率问题，所以单点问题比较复杂；不支持自动 sharding, 需要依赖程序设定一致 hash 机制。一种替代方案是，不用 Redis 本身的复制机制，采用自己做主动复制（多份存储），或者改成增量复制的方式（需要自己实现），一致性问题和性能的权衡。</p>
</li>
<li><p>Memcache 本身没有数据冗余机制，也没必要；对于故障预防，采用依赖成熟的 hash 或者环状的算法，解决单点故障引起的抖动问题。</p>
</li>
<li><p>mongoDB 支持 master-slave,replicaset（内部采用 paxos 选举算法，自动故障恢复）,auto sharding 机制，对客户端屏蔽了故障转移和切分机制。</p>
</li>
<li><p>可靠性（持久化）</p>
</li>
<li><p>对于数据持久化和数据恢复，Redis 支持（快照、AOF）：依赖快照进行持久化，aof 增强了可靠性的同时，对性能有所影响。</p>
</li>
<li><p>memcache 不支持，通常用在做缓存, 提升性能；</p>
</li>
<li><p>MongoDB 从 1.8 版本开始采用 binlog 方式支持持久化的可靠性。</p>
</li>
<li><p>数据一致性（事务支持）</p>
</li>
<li><p>Memcache 在并发场景下，用 cas 保证一致性。</p>
</li>
<li><p>Redis 事务支持比较弱，只能保证事务中的每个操作连续执行。</p>
</li>
<li><p>mongoDB 不支持事务。</p>
</li>
<li><p>数据分析</p>
</li>
<li><p>mongoDB 内置了数据分析的功能 (mapreduce), 其他不支持。</p>
</li>
<li><p>应用场景</p>
</li>
<li><p>Redis：数据量较小的更性能操作和运算上。</p>
</li>
<li><p>memcache：用于在动态系统中减少数据库负载，提升性能; 做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用 sharding）。</p>
</li>
<li><p>MongoDB: 主要解决海量数据的访问效率问题。</p>
</li>
</ol>
<p><strong>133. Redis 有什么用？只有了解了它有哪些特性，我们在用的时候才能扬长避短，为我们所用。</strong></p>
<ol>
<li><strong>速度快：</strong> 使用标准 C 写，所有数据都在内存中完成，读写速度分别达到 10 万 / 20 万。</li>
<li><strong>持久化：</strong> 对数据的更新采用 Copy-on-write 技术，可以异步地保存到磁盘上，主要有两种策略，一是根据时间，更新次数的快照（save 300 10 ）二是基于语句追加方式 (Append-only file，aof) 。</li>
<li><strong>自动操作：</strong> 对不同数据类型的操作都是自动的，很安全。</li>
<li>快速的主 – 从复制，官方提供了一个数据，Slave 在 21 秒即完成了对 Amazon 网站 10G key set 的复制。</li>
<li><strong>Sharding 技术：</strong> 很容易将数据分布到多个 Redis 实例中，数据库的扩展是个永恒的话题，在关系型数据库中，主要是以添加硬件、以分区为主要技术形式的纵向扩展解决了很多的应用场景，但随着 web2.0、移动互联网、云计算等应用的兴起，这种扩展模式已经不太适合了，所以近年来，像采用主从配置、数据库复制形式的，Sharding 这种技术把负载分布到多个特理节点上去的横向扩展方式用处越来越多。</li>
</ol>
<p><strong>134. 这里对 Redis 数据库做下小结。</strong></p>
<ol>
<li>提高了 DB 的可扩展性，只需要将新加的数据放到新加的服务器上就可以了</li>
<li>提高了 DB 的可用性，只影响到需要访问的 shard 服务器上的数据的用户</li>
<li>提高了 DB 的可维护性，对系统的升级和配置可以按 shard 一个个来搞，对服务产生的影响较小</li>
<li>小的数据库存的查询压力小，查询更快，性能更好<h3 id="Java-WEB"><a href="#Java-WEB" class="headerlink" title="Java WEB"></a>Java WEB</h3></li>
</ol>
<p><strong>135. Tomcat 的优化经验。</strong></p>
<blockquote>
<p>Tomcat 作为 Web 服务器，它的处理性能直接关系到用户体验，下面是几种常见的优化措施:  </p>
</blockquote>
<ul>
<li><p>去掉对 web.xml 的监视，把 jsp 提前编辑成 Servlet。有富余物理内存的情况，加大 tomcat 使用的 jvm 的内存。</p>
</li>
<li><p>服务器资源   服务器所能提供 CPU、内存、硬盘的性能对处理能力有决定性影响。</p>
<ul>
<li>对于高并发情况下会有大量的运算，那么 CPU 的速度会直接影响到处理速度。</li>
<li>内存在大量数据处理的情况下，将会有较大的内存容量需求，可以用 - Xmx -Xms -XX:MaxPermSize 等参数对内存不同功能块进行划分。我们之前就遇到过内存分配不足，导致虚拟机一直处于 full GC，从而导致处理能力严重下降。</li>
<li>硬盘主要问题就是读写性能，当大量文件进行读写时，磁盘极容易成为性能瓶颈。最好的办法还是利用下面提到的缓存。</li>
</ul>
</li>
<li><p>利用缓存和压缩   对于静态页面最好是能够缓存起来，这样就不必每次从磁盘上读。这里我们采用了 Nginx 作为缓存服务器，将图片、css、js 文件都进行了缓存，有效的减少了后端 tomcat 的访问。   另外，为了能加快网络传输速度，开启 gzip 压缩也是必不可少的。但考虑到 tomcat 已经需要处理很多东西了，所以把这个压缩的工作就交给前端的 Nginx 来完成。   除了文本可以用 gzip 压缩，其实很多图片也可以用图像处理工具预先进行压缩，找到一个平衡点可以让画质损失很小而文件可以减小很多。曾经我就见过一个图片从 300 多 kb 压缩到几十 kb，自己几乎看不出来区别。</p>
</li>
<li><p>采用集群   单个服务器性能总是有限的，最好的办法自然是实现横向扩展，那么组建 tomcat 集群是有效提升性能的手段。我们还是采用了 Nginx 来作为请求分流的服务器，后端多个 tomcat 共享 session 来协同工作。可以参考之前写的《利用 nginx+tomcat+memcached 组建 web 服务器负载均衡》。</p>
</li>
<li><p>优化 tomcat 参数</p>
</li>
</ul>
<blockquote>
<p>这里以 tomcat7 的参数配置为例，需要修改 conf/server.xml 文件，主要是优化连接配置，关闭客户端 dns 查询。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8080&quot;   </span><br><span class="line">   protocol&#x3D;&quot;org.apache.coyote.http11.Http11NioProtocol&quot;  </span><br><span class="line">   connectionTimeout&#x3D;&quot;20000&quot;  </span><br><span class="line">   redirectPort&#x3D;&quot;8443&quot;   </span><br><span class="line">   maxThreads&#x3D;&quot;500&quot;   </span><br><span class="line">   minSpareThreads&#x3D;&quot;20&quot;  </span><br><span class="line">   acceptCount&#x3D;&quot;100&quot;</span><br><span class="line">   disableUploadTimeout&#x3D;&quot;true&quot;</span><br><span class="line">   enableLookups&#x3D;&quot;false&quot;   </span><br><span class="line">   URIEncoding&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>136. HTTP 请求的 GET 与 POST 方式的区别。</strong></p>
<blockquote>
<p>GET 请求，请求的数据会附加在 URL 之后，以 <strong>?</strong> 分割 URL 和传输数据，多个参数用 <strong>&amp;</strong> 连接。URL 的编码格式采用的是 ASCII 编码，而不是 unicode，即是说所有的非 ASCII 字符都要编码之后再传输。  </p>
</blockquote>
<blockquote>
<p>POST 请求：POST 请求会把请求的数据放置在 HTTP 请求包的包体中。  </p>
</blockquote>
<blockquote>
<p>因此，GET 请求的数据会暴露在地址栏中，而 POST 请求则不会。  </p>
</blockquote>
<ul>
<li>传输数据的大小<blockquote>
<p>在 HTTP 规范中，没有对 URL 的长度和传输的数据大小进行限制。但是在实际开发过程中，对于 GET，特定的浏览器和服务器对 URL 的长度有限制。因此，在使用 GET 请求时，传输数据会受到 URL 长度的限制。  </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>对于 POST，由于不是 URL 传值，理论上是不会受限制的，但是实际上各个服务器会规定对 POST 提交数据大小进行限制，Apache、IIS 都有各自的配置。  </p>
</blockquote>
<ul>
<li><p>安全性</p>
<blockquote>
<p>POST 的安全性比 GET 的高。这里的安全是指真正的安全，而不同于上面 GET 提到的安全方法中的安全，上面提到的安全仅仅是不修改服务器的数据。比如，在进行登录操作，通过 GET 请求，用户名和密码都会暴露再 URL 上，因为登录页面有可能被浏览器缓存以及其他人查看浏览器的历史记录的原因，此时的用户名和密码就很容易被他人拿到了。除此之外，GET 请求提交的数据还可能会造成 Cross-site request frogery 攻击。  </p>
</blockquote>
</li>
<li><p>HTTP 中的 GET，POST，SOAP 协议都是在 HTTP 上运行的。</p>
</li>
<li><p><em>137. 解释一下什么是 Servlet。*</em></p>
</li>
</ul>
<blockquote>
<p>Servlet 是一种服务器端的 Java 应用程序，具有独立于平台和协议的特性, 可以生成动态的 Web 页面。 它担当客户请求（Web 浏览器或其他 HTTP 客户程序）与服务器响应（HTTP 服务器上的数据库或应用程序）的中间层。 Servlet 是位于 Web 服务器内部的服务器端的 Java 应用程序，与传统的从命令行启动的 Java 应用程序不同，Servlet 由 Web 服务器进行加载，该 Web 服务器必须包含支持 Servlet 的 Java 虚拟机。  </p>
</blockquote>
<p><strong>138. 说一说 Servlet 的生命周期。</strong></p>
<blockquote>
<p>Servlet 有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由 javax.servlet.Servlet 接口的 init、service 和 destroy 方法表达。  </p>
</blockquote>
<blockquote>
<p>Servlet 被服务器实例化后，容器运行其 init 方法，请求到达时运行其 service 方法，service 方法自动派遣运行与请求对应的 doXxx 方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其 destroy 方法。  </p>
</blockquote>
<blockquote>
<p>web 容器加载 Servlet，生命周期开始。通过调用 Servlet 的 init() 方法进行 Servlet 的初始化。通过调用 service() 方法实现，根据请求的不同调用不同的 do***() 方法。结束服务，web 容器调用 Servlet 的 destroy() 方法。  </p>
</blockquote>
<p><strong>139. Servlet API 中 forward() 与 redirect() 的区别？</strong></p>
<blockquote>
<p>前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量使用 forward() 方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用 sendRedirect() 方法。  </p>
</blockquote>
<p><strong>140. request.getAttribute() 和 request.getParameter() 有何区别?</strong></p>
<blockquote>
<p>getParameter 是用来接受用 post 或 get 方法传递过来的参数的。  </p>
</blockquote>
<blockquote>
<p>getAttribute 必须先 setAttribute。  </p>
</blockquote>
<blockquote>
<p>request.getParameter() 取得是通过容器的实现来取得通过类似 post，get 等方式传入的数据，request.setAttribute() 和 getAttribute() 只是在 web 容器内部流转，仅仅是请求处理阶段。  </p>
</blockquote>
<blockquote>
<p>request.getParameter() 方法传递的数据，会从 Web 客户端传到 Web 服务器端，代表 HTTP 请求数据。request.getParameter() 方法返回 String 类型的数据。  </p>
</blockquote>
<blockquote>
<p>request.setAttribute() 和 getAttribute() 方法传递的数据只会存在于 Web 容器内部。还有一点就是，HttpServletRequest 类有 setAttribute() 方法，而没有 setParameter() 方法。  </p>
</blockquote>
<p><strong>141. JSP 有哪些动作? 作用分别是什么?</strong></p>
<blockquote>
<p>JSP 共有以下 6 种基本动作：  </p>
</blockquote>
<ul>
<li><p>jsp:include：在页面被请求的时候引入一个文件。</p>
</li>
<li><p>jsp:useBean：寻找或者实例化一个 JavaBean。</p>
</li>
<li><p>jsp:setProperty：设置 JavaBean 的属性。</p>
</li>
<li><p>jsp:getProperty：输出某个 JavaBean 的属性。</p>
</li>
<li><p>jsp:forward：把请求转到一个新的页面。</p>
</li>
<li><p>jsp:plugin：根据浏览器类型为 Java 插件生成 OBJECT 或 EMBED 标记。</p>
</li>
</ul>
<p><strong>142. JSP 的常用指令。</strong></p>
<blockquote>
<p>常用的指令有三个：page、include、taglib;  </p>
</blockquote>
<ul>
<li><strong>page</strong> 指令<blockquote>
<p>&lt;%@page language=”java” contentType=”text/html;charset=gb2312” session=”true” buffer=”64kb” autoFlush=”true” isThreadSafe=”true” info=”text” errorPage=”error.jsp” isErrorPage=”true” isELIgnored=” true” pageEncoding=”gb2312” import=”java.sql.*”%&gt;  </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>说明: isErrorPage(是否能使用 Exception 对象)，isELIgnored(是否忽略表达式)  </p>
</blockquote>
<ul>
<li><p><strong>include</strong> 指令</p>
<blockquote>
<p>&lt;%@ include file=”filename”%&gt;  </p>
</blockquote>
</li>
<li><p><strong>taglib</strong> 指令</p>
<blockquote>
<p>&lt;%@ taglib prefix=”c”uri=”http://……”%&gt;  </p>
</blockquote>
</li>
</ul>
<p><strong>143. JSP 和 Servlet 有哪些相同点和不同点，他们之间的联系是什么？</strong></p>
<blockquote>
<p>JSP 是 Servlet 技术的扩展，本质上是 Servlet 的简易方式，更强调应用的外表表达。JSP 编译后是 “类 servlet”。Servlet 和 JSP 最主要的不同点在于，Servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 HTML 里分离开来。而 JSP 的情况是 Java 和 HTML 可以组合成一个扩展名为. jsp 的文件。JSP 侧重于视图，Servlet 主要用于控制逻辑。  </p>
</blockquote>
<p><strong>144. MVC 的各个部分都有那些技术来实现? 如何实现?</strong></p>
<blockquote>
<p>MVC 是 Model－View－Controller 的简写。Model 代表的是应用的业务逻辑（通过 JavaBean，EJB 组件实现）， View 是应用的表示面（由 JSP 页面产生），Controller 是提供应用的处理过程控制（一般是一个 Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。  </p>
</blockquote>
<h3 id="企业级框架"><a href="#企业级框架" class="headerlink" title="企业级框架"></a>企业级框架</h3><p><strong>145. 谈谈你对 Spring 的理解。</strong></p>
<ul>
<li><p>Spring 实现了 <strong>工厂模式的工厂类</strong> （在这里有必要解释清楚什么是工厂模式），这个类名为 BeanFactory（实际上是一个接口），在程序中通常 BeanFactory 的子类 ApplicationContext。Spring 相当于一个大的工厂类，在其配置文件中通过 <bean> 元素配置用于创建实例对象的类名和实例对象的属性。</p>
</li>
<li><p>Spring 提供了对** IOC** 良好支持，IOC 是一种编程思想，是一种架构艺术，利用这种思想可以很好地实现模块之间的解耦。IOC 也称为 DI（Depency Injection），什么叫依赖注入呢？譬如：</p>
</li>
</ul>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Programmer &#123;</span><br><span class="line">    Computer computer &#x3D; null;</span><br><span class="line">    public void code()&#123;</span><br><span class="line">        &#x2F;&#x2F;Computer computer &#x3D; new IBMComputer();</span><br><span class="line">        &#x2F;&#x2F;Computer computer &#x3D; beanfacotry.getComputer();</span><br><span class="line">        computer.write();</span><br><span class="line">    &#125;</span><br><span class="line">    public void setComputer(Computer computer)</span><br><span class="line">    &#123;</span><br><span class="line">        this.computer &#x3D; computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>另外两种方式都由依赖，第一个直接依赖于目标类，第二个把依赖转移到工厂上，第三个彻底与目标和工厂解耦了。在 spring 的配置文件中配置片段如下：</li>
</ul>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;”computer” class&#x3D;”cn.itcast.interview.Computer”&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;bean id&#x3D;”programmer” class&#x3D;”cn.itcast.interview.Programmer”&gt;</span><br><span class="line">    &lt;property name&#x3D;”computer”  ref&#x3D;”computer”&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>Spring 提供了对 AOP 技术的良好封装， AOP 称为 <strong>面向切面编程</strong> ，就是系统中有很多各不相干的类的方法，在这些众多方法中要加入某种系统功能的代码，例如， <strong>加入日志，加入权限判断，加入异常处理</strong> ，这种应用称为 AOP。实现 AOP 功能采用的是代理技术，客户端程序不再调用目标，而调用代理类，代理类与目标类对外具有相同的方法声明，有两种方式可以实现相同的方法声明，一是实现相同的接口，二是作为目标的子类在，JDK 中采用 Proxy 类产生动态代理的方式为某个接口生成实现类，如果要为某个类生成子类，则可以用 CGLI B。在生成的代理类的方法中加入系统功能和调用目标类的相应方法，系统功能的代理以 Advice 对象进行提供，显然要创建出代理对象，至少需要目标类和 Advice 类。spring 提供了这种支持，只需要在 spring 配置文件中配置这两个元素即可实现代理和 aop 功能，例如:</li>
</ul>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;”proxy” type&#x3D;”org.spring.framework.aop.ProxyBeanFactory”&gt;</span><br><span class="line">    &lt;property name&#x3D;”target” ref&#x3D;””&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property name&#x3D;”advisor” ref&#x3D;””&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p><strong>146. 什么是 Spring 框架？Spring 框架有哪些主要模块？</strong></p>
<blockquote>
<p>Spring 框架是一个为 Java 应用程序的开发提供了 <strong>综合、广泛</strong> 的基础性支持的 Java 平台。Spring 帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring 框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成 Spring 框架，不必担心 Spring 是如何在后台进行工作的。  </p>
</blockquote>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//upload-images.jianshu.io/upload_images/127268-985d9d2db86e9e92?imageMogr2/auto-orient/strip%257CimageView2/2/w/1000/format/webp" alt=""></p>
<blockquote>
<p>enter image description here  </p>
</blockquote>
<blockquote>
<p>Spring 框架至今已集成了 20 多个模块。这些模块主要被分如下图所示的核心容器、数据访问 / 集成、Web、AOP（面向切面编程）、工具、消息和测试模块。  </p>
</blockquote>
<p><strong>147. 什么是控制反转 (IOC)？什么是依赖注入？</strong></p>
<blockquote>
<p>控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。而绑定的过程是通过 “依赖注入” 实现的。  </p>
</blockquote>
<blockquote>
<p>控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。  </p>
</blockquote>
<blockquote>
<p>依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？  </p>
</blockquote>
<blockquote>
<p>在 Java 中依然注入有以下三种实现方式：  </p>
</blockquote>
<ul>
<li><p>构造器注入</p>
</li>
<li><p>Setter 方法注入</p>
</li>
<li><p>接口注入</p>
</li>
</ul>
<p><strong>148. BeanFactory 和 ApplicationContext 有什么区别？</strong></p>
<blockquote>
<p>BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，以便在接收到客户端请求时将对应的 bean 实例化。  </p>
</blockquote>
<blockquote>
<p>BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的配置中解放出来。BeanFactory 还包含了 bean 生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。  </p>
</blockquote>
<blockquote>
<p>从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，根据请求分发 bean 的功能。但 application context 在此基础上还提供了其他的功能。  </p>
</blockquote>
<ol>
<li><p>提供了支持国际化的文本消息</p>
</li>
<li><p>统一的资源文件读取方式</p>
</li>
<li><p>已在监听器中注册的 bean 的事件</p>
</li>
</ol>
<blockquote>
<p>以下是三种较常见的 <strong>ApplicationContext</strong> 实现方式：  </p>
</blockquote>
<blockquote>
<p>1、<strong>ClassPathXmlApplicationContext</strong> ：从 classpath 的 XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(“bean.xml”);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2、<strong>FileSystemXmlApplicationContext</strong> ：由文件系统中的 XML 配置文件读取上下文。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context &#x3D; new FileSystemXmlApplicationContext(“bean.xml”);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3、<strong>XmlWebApplicationContext</strong> ：由 Web 应用的 XML 文件读取上下文。  </p>
</blockquote>
<p><strong>149. 谈谈你对 Hibernate 的理解。</strong></p>
<blockquote>
<p>Hibernate 是一个 ORM 框架，是对 JDBC 的封装。目的就是简化对数据库表访问的操作。 ORM 的意思是对象关系的映射，通过实体类与数据表建立映射，就可以通过持久层操作来代替 sql 语句操作数据库。  </p>
</blockquote>
<blockquote>
<p>hibernate 的核心原理就是对象关系映射（ORM），就是通过 java 的反射机制来实现。  </p>
</blockquote>
<blockquote>
<p>java 反射机制：在 java 运行状态中，对于任何一个类，都能够知道这个类的所有属性和方法，就是对于任意一个对象都能够调用他的任意属性和方法，这种动态获取信息以及动态调用的方法就是功能就是 java 的反射机制。  </p>
</blockquote>
<blockquote>
<p>以上这些就是 hibernate 的核心原理。  </p>
</blockquote>
<ul>
<li><p>使用 Hibernate 的基本流程是：配置 Configuration 对象、产生 SessionFactory、创建 session 对象，启动事务，完成 CRUD 操作，提交事务，关闭 session。</p>
</li>
<li><p>使用 Hibernate 时，先要配置 hibernate.cfg.xml 文件，其中配置数据库连接信息和方言等，还要为每个实体配置相应的 hbm.xml 文件，hibernate.cfg.xml 文件中需要登记每个 hbm.xml 文件。</p>
</li>
<li><p>在应用 Hibernate 时，重点要了解 Session 的缓存原理，级联，延迟加载和 hql 查询。</p>
</li>
</ul>
<p><strong>150. Hibernate 中的 update() 和 saveOrUpdate() 的区别，session 的 load() 和 get() 的区别。</strong></p>
<blockquote>
<p><strong>saveorupdate()</strong> 如果传入的对象在数据库中有就做 update 操作，如果没有就做 save 操作。  </p>
</blockquote>
<blockquote>
<p><strong>save()</strong> 在数据库中生成一条记录，如果数据库中有，会报错说有重复的记录。  </p>
</blockquote>
<blockquote>
<p><strong>Hibernate</strong> 中 <strong>get</strong> 方法和 <strong>load</strong> 方法的根本区别如下。  </p>
</blockquote>
<blockquote>
<p>如果你使用 load 方法，hibernate 认为该 id 对应的对象（数据库记录）在数据库中是一定存在的，所以它可以放心的使用，它可以放心的使用代理来延迟加载该对象。在用到对象中的其他属性数据时才查询数据库，但是万一数据库中不存在该记录，那没办法，只能抛异常 ObjectNotFoundException，所说的 load 方法抛异常是指在使用该对象的数据时，数据库中不存在该数据时抛异常，而不是在创建这个对象时。由于 session 中的缓存对于 hibernate 来说是个相当廉价的资源，所以在 load 时会先查一下 session 缓存看看该 id 对应的对象是否存在，不存在则创建代理。所以如果你知道该 id 在数据库中一定有对应记录存  </p>
</blockquote>
<blockquote>
<p>在就可以使用 load 方法来实现延迟加载。  </p>
</blockquote>
<blockquote>
<p>对于 get 方法，hibernate 会确认一下该 id 对应的数据是否存在，首先在 session 缓存中查找，然后在二级缓存中查找，还没有就查数据库，数据库中没有就返回 null。  </p>
</blockquote>
<blockquote>
<p>虽然好多书中都这么说：“get() 永远只返回实体类”，但实际上这是不正确的，get 方法如果在 session 缓存中找到了该 id 对应的对象，如果刚好该对象前面是被代理过的，如被 load 方法使用过，或者被其他关联对象延迟加载过，那么返回的还是原先的代理对象，而不是实体类对象，如果该代理对象还没有加载实体数据（就是 id 以外的其他属性数据），那么它会查询二级缓存或者数据库来加载数据，但是返回的还是代理对象，只不过已经加载了实体数据。  </p>
</blockquote>
<blockquote>
<p>前面已经讲了，get 方法首先查询 session 缓存，没有的话查询二级缓存，最后查询数据库；反而 load 方法创建时首先查询 session 缓存，没有就创建代理，实际使用数据时才查询二级缓存和数据库。  </p>
</blockquote>
<blockquote>
<p>总之对于 get 和 load 的根本区别，一句话，Hibernate 对于 load 方法认为该数据在数据库中一定存在，可以放心的使用代理来延迟加载，如果在使用过程中发现了问题，就抛异常；而对于 get 方法，Hibernate 一定要获取到真实的数据，否则返回 null。  </p>
</blockquote>
<p><strong>151. Hibernate 的 inverse 属性的作用？</strong></p>
<blockquote>
<p>inverse 属性，是在维护关联关系的时候起作用的。表示控制权是否转移。（在一方起作用）  </p>
</blockquote>
<blockquote>
<p>inverse , 控制反转。inverse = false 不反转，当前方有控制权；true 控制反转，当前方没有控制权。  </p>
</blockquote>
<blockquote>
<p>维护关联关系中，是否设置 inverse 属性：  </p>
</blockquote>
<ol>
<li><p>保存数据有影响。</p>
<blockquote>
<p>如果设置控制反转，即 inverse=true，然后通过部门方维护关联关系。在保存部门的时候，同时保存员工，数据会保存，但关联关系不会维护。即外键字段为 NULL。  </p>
</blockquote>
</li>
<li><p>获取数据无</p>
</li>
<li><p>解除关联关系？有影响。</p>
</li>
</ol>
<blockquote>
<p>inverse = false，可以解除关联  </p>
</blockquote>
<blockquote>
<p>inverse = true，当前方（部门）没有控制权，不能解除关联关系（不会生成 update 语句，也不会报错）。  </p>
</blockquote>
<ol>
<li>删除数据对关联关系的影响？有影响。<blockquote>
<p>inverse=false，有控制权。可以删除。先清空外键引用，再删除数据。  </p>
</blockquote>
</li>
</ol>
<blockquote>
<p>inverse=true，没有控制权。如果删除的记录有被外键引用，会报错，违反主外键引用约束！如果删除的记录没有被引用，可以直接删除。  </p>
</blockquote>
<p><strong>152. 介绍一下 Hibernate 的二级缓存</strong></p>
<blockquote>
<p>按照以下思路来回答：（1）首先说清楚什么是缓存，（2）再说有了 Hibernate 的 Session 就是一级缓存，即有了一级缓存，为什么还要有二级缓存，（3）最后再说如何配置 Hibernate 的二级缓存。  </p>
</blockquote>
<blockquote>
<p>（1）缓存就是把以前从数据库中查询出来和使用过的对象保存在内存中（一个数据结构中），这个数据结构通常是或类似 Hashmap，当以后要使用某个对象时，先查询缓存中是否有这个对象，如果有则使用缓存中的对象，如果没有则去查询数据库，并将查询出来的对象保存在缓存中，以便下次使用。下面是缓存的伪代码：  </p>
</blockquote>
<blockquote>
<p>引出 Hibernate 的第二级缓存，用下面的伪代码分析了 Cache 的实现原理：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Dao&#123;</span><br><span class="line">  hashmap map &#x3D; new map();</span><br><span class="line">  User getUser(integer id)  &#123;</span><br><span class="line">      User user &#x3D; map.get(id)</span><br><span class="line">      if(user &#x3D;&#x3D; null)</span><br><span class="line">      &#123;</span><br><span class="line">          user &#x3D; session.get(id);</span><br><span class="line">          map.put(id,user);</span><br><span class="line">      &#125;</span><br><span class="line">      return user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dao</span><br><span class="line">&#123;</span><br><span class="line">Cache cache &#x3D; null</span><br><span class="line">  setCache(Cache cache)</span><br><span class="line">  &#123;</span><br><span class="line">      this.cache &#x3D; cache</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  User getUser(int id)</span><br><span class="line">  &#123;</span><br><span class="line">      if(cache!&#x3D;null)</span><br><span class="line">      &#123;</span><br><span class="line">          User user &#x3D; cache.get(id);</span><br><span class="line">          if(user &#x3D;&#x3D;null)</span><br><span class="line">          &#123;</span><br><span class="line">              user &#x3D; session.get(id);</span><br><span class="line">              cache.put(id,user);</span><br><span class="line">          &#125;</span><br><span class="line">          return user;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return session.get(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>（2）Hibernate 的 Session 就是一种缓存，我们通常将之称为 Hibernate 的一级缓存，当想使用 session 从数据库中查询出一个对象时，Session 也是先从自己内部查看是否存在这个对象，存在则直接返回，不存在才去访问数据库，并将查询的结果保存在自己内部。由于 Session 代表一次会话过程，一个 Session 与一个数据库连接相关连，所以 Session 最好不要长时间保持打开，通常仅用于一个事务当中，在事务结束时就应关闭。并且 Session 是线程不安全的，被多个线程共享时容易出现问题。通常只有那种全局意义上的缓存才是真正的缓存应用，才有较大的缓存价值，因此，Hibernate 的 Session 这一级缓存的缓存作用并不明显，应用价值不大。Hibernate 的二级缓存就是要为 Hibernate 配置一种全局缓存，让多个线程和多个事务都可以共享这个缓存。我们希望的是一个人使用过，其他人也可以使用，session 没有这种效果。  </p>
</blockquote>
<blockquote>
<p>（3）二级 <strong>缓存是独立于</strong> Hibernate 的软件部件，属于第三方的产品，多个厂商和组织都提供有缓存产品，例如，EHCache 和 OSCache 等等。在 Hibernate 中使用二级缓存，首先就要在 hibernate.cfg.xml 配置文件中配置使用哪个厂家的缓存产品，接着需要配置该缓存产品自己的配置文件，最后要配置 Hibernate 中的哪些实体对象要纳入到二级缓存的管理中。明白了二级缓存原理和有了这个思路后，很容易配置起 Hibernate 的二级缓存。扩展知识：一个 SessionFactory 可以关联一个二级缓存，也即一个二级缓存只能负责缓存一个数据库中的数据，当使用 Hibernate 的二级缓存后，注意不要有其他的应用或 SessionFactory 来更改当前数据库中的数据，这样缓存的数据就会与数据库中的实际数据不一致。  </p>
</blockquote>
<p><strong>153. 简单的谈一下 Spring MVC 的工作流程。</strong></p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//upload-images.jianshu.io/upload_images/127268-a11583a4fa458bd1?imageMogr2/auto-orient/strip%257CimageView2/2/w/1000/format/webp" alt=""></p>
<blockquote>
<p>enter image description here  </p>
</blockquote>
<blockquote>
<p>流程  </p>
</blockquote>
<ol>
<li>用户发送请求至前端控制器 DispatcherServlet。</li>
<li>DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。</li>
<li>处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器（如果有则生成）一并返回给 DispatcherServlet。</li>
<li>DispatcherServlet 调用 HandlerAdapter 处理器适配器。</li>
<li>HandlerAdapter 经过适配调用具体的处理器（Controller，也叫后端控制器）。</li>
<li>Controller 执行完成返回 ModelAndView。</li>
<li>HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。</li>
<li>DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。</li>
<li>ViewReslover 解析后返回具体 View。</li>
<li>DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。</li>
<li>DispatcherServlet 响应用户。</li>
</ol>
<p><strong>154. Spring MVC Framework 的特点。</strong></p>
<ul>
<li><p>它是基于组件技术的全部的应用对象，无论控制器和视图，还是业务对象之类的都是 Java 组件，并且和 Spring 提供的其他基础结构紧密集成。</p>
</li>
<li><p>不依赖于 Servlet API（目标虽是如此，但是在实现的时候确实是依赖于 Servlet 的）。</p>
</li>
<li><p>可以任意使用各种视图技术，而不仅仅局限于 JSP。</p>
</li>
<li><p>支持各种请求资源的映射策略。</p>
</li>
<li><p>它应是易于扩展的。</p>
</li>
</ul>
<p><strong>155. @ModelAttribute 如何使用？</strong></p>
<ul>
<li><p>定义一个方法，该方法用来返回要填充到模型数据中的对象。</p>
</li>
<li><p>给该方法添加 @ModelAttribute 注解。</p>
</li>
<li><p>添加 @ModelAttribute 注解的方法，会在 Spring MVC 在调用任何一个业务方法之前被自动调用。</p>
</li>
</ul>
<p><strong>156. 说说你对自定义数据类型转换器的理解。</strong></p>
<blockquote>
<p>通过自定义数据类型转换器可以根据需求对 HTTP 请求中的参数进行解析，转换成需要的数据类型。具体操作是创建一个 Java 类，实现 org.springframework.core.convert.converter.Converter 接口，这样自定义的 Java 类就具备了转换数据的功能，然后在 convert 方法中完成转换的具体业务流程。  </p>
</blockquote>
<blockquote>
<p>当服务器接收到一个请求之后，Spring MVC 首先将请求分发到数据类型转换器进行格式转换，然后再进入相应的业务方法。  </p>
</blockquote>
<p><strong>157. 什么是 MyBatis 的接口绑定，有什么好处？</strong></p>
<blockquote>
<p>接口映射就是在 IBatis 中任意定义接口, 然后把接口里面的方法和 SQL 语句绑定，我们直接调用接口方法就可以，这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选择和设置。  </p>
</blockquote>
<p><strong>158. 接口绑定有几种实现方式, 分别是怎么实现的？</strong></p>
<blockquote>
<p>接口绑定有两种实现方式，一种是通过注解绑定，就是在接口的方法上面加上 @Select@Update 等注解里面包含 Sql 语句来绑定，另外一种就是通过 xml 里面写 SQL 来绑定，在这种情况下，要指定 xml 映射文件里面的 namespace 必须为接口的全路径名。  </p>
</blockquote>
<p><strong>159. MyBatis 实现一对一有几种方式，具体怎么操作的？</strong></p>
<blockquote>
<p>有联合查询和嵌套查询，联合查询是几个表联合查询，只查询一次，通过在 resultMap 里面配置 association 节点配置一对一的类就可以完成；  </p>
</blockquote>
<blockquote>
<p>嵌套查询是先查一个表，根据这个表里面的结果的外键 id，去再另外一个表里面查询数据，也是通过 association 配置，但另外一个表的查询通过 select 属性配置。  </p>
</blockquote>
<p><strong>160. MyBatis 实现一对多有几种方式，怎么操作的？</strong></p>
<blockquote>
<p>有联合查询和嵌套查询, 联合查询是几个表联合查询, 只查询一次, 通过在 resultMap 里面配置 collection 节点配置一对多的类就可以完成;  </p>
</blockquote>
<blockquote>
<p>嵌套查询是先查一个表, 根据这个表里面的结果的外键 id，去再另外一个表里面查询数据, 也是通过配置 collection，但另外一个表的查询通过 select 节点配置。  </p>
</blockquote>
<p><strong>161. MyBatis 里面的动态 Sql 是怎么设定的？用什么语法？</strong></p>
<blockquote>
<p>MyBatis 里面的动态 Sql 一般是通过 if 节点来实现, 通过 OGNL 语法来实现, 但是如果要写的完整, 必须配合 where,trim 节点, where 节点是判断包含节点有内容就插入 where, 否则不插入, trim 节点是用来判断如果动态语句是以 and 或 or 开始, 那么会自动把这个 and 或者 or 取掉。  </p>
</blockquote>
<p><strong>162. JDO 是什么?</strong></p>
<blockquote>
<p>JDO 是 Java 对象 <strong>持久化</strong> 的新的规范，为 java data object 的简称, 也是一个用于存取某种数据仓库中的对象的标准化 API。JDO 提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如 JDBC API 的使用）。这些繁琐的例行工作已经转移到 JDO 产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO 很灵活，因为它可以在任何数据底层上运行。JDBC 只是面向关系数据库（RDBMS）JDO 更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML 以及对象数据库（ODBMS）等等，使得应用可移植性更强。  </p>
</blockquote>
<blockquote>
<p>应用程序的开发人员通过访问 JDO Instance , 达到访问 JDO Instance 所代表的数据对象, 包括: ERP，数据库系统等. 使数据的存储介质对于应用的开发人员完全透明。  </p>
</blockquote>
<blockquote>
<p>JDO 最早是由 Sun 召集众多的** O/R Mappin**g 开发团队集中起来共同提出的，首先是通过会议确定了 JDO 需要包括的内容，然后正式提出一个 Java 规范请求（JSR-12），正式开始了 JDO 规范的制定。  </p>
</blockquote>
<p><strong>163. Spring、Spring Boot 和 Spring Cloud 的关系。</strong></p>
<blockquote>
<p>Spring Boot 是在Spring生态基础上面发展而来，发明 Spring Boot是为了简化Spring的开发。所以说没有 Spring 作为基础，就不会有Spring Boot，Spring Boot 使用约定优于配置的理念，重新重构了 Spring 的使用，让 Spring 后续的发展更有生命力。  </p>
</blockquote>
<blockquote>
<p>Spring Cloud 是一系列框架的有序集合，它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发。服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。为了解决微服务架构中服务治理而提供的具备一系列功能的开发框架，并且 Spring Cloud 是完全基于 Spring Boot 而开发，Spring Cloud 利用 Spring Boot 特性整合了开源行业中优秀的组件，整体对外提供了一套在微服务架构中服务治理的解决方案。  </p>
</blockquote>
<p><strong>164. 什么是数据校验？</strong></p>
<blockquote>
<p>应用程序必须通过某种手段来确保输入进来的数据从语义上来讲是正确的。在 Java 应用程序中，必须要对输入进来的数据从语义上分析是有效的，也就是数据校验。  </p>
</blockquote>
<blockquote>
<p>输入验证是最重要的 Web 开发任务之一，在 Spring MVC 中有两种方式可以验证输入：一种是 Spring 自带的验证框架，另外一种是利用 JSR 实现。  </p>
</blockquote>
<blockquote>
<p>JSR 是一个规范文档，指定了一整套 API，通过标注给对象属性添加约束。Hibernate Validator 就是 JSR 规范的具体实现，Hibernate Validator 提供了 JSR 规范中所有内置约束注解的实现，以及一些附加的约束注解，除此之外用户还可以自定义约束注解。  </p>
</blockquote>
<blockquote>
<p>Spring Boot 的参数校验依赖于 hibernate-validator 来进行。使用 Hibernate Validator 校验数据，需要定义一个接收的数据模型，使用注解的形式描述字段校验的规则。  </p>
</blockquote>
<p><strong>165. Thymeleaf 特点。</strong></p>
<blockquote>
<p>Thymeleaf 是一个可以完全替代 JSP的模版。与其他的模板引擎相比较，它有如下三个特点。  </p>
</blockquote>
<ul>
<li><p>Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 HTML 原型，然后在 HTML 标签里增加额外的属性来达到模板 + 数据的展示方式。浏览器解释 HTML 时会忽略未定义的标签属性，所以 Thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</p>
</li>
<li><p>Thymeleaf 开箱即用的特性。它支持标准方言和 Spring 方言，可以直接套用模板实现 JSTL、 OGNL 表达式效果，避免每天套模板、改 JSTL、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。</p>
</li>
<li><p>Thymeleaf 提供 Spring 标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速地实现表单绑定、属性编辑器、国际化等功能。</p>
</li>
</ul>
<p><strong>166. 什么是 Druid？</strong></p>
<blockquote>
<p>Druid 是阿里巴巴开源平台上的一个项目，整个项目由数据库连接池、插件框架和 SQL 解析器组成，该项目主要是为了扩展 JDBC 的一些限制，可以让程序员实现一些特殊的需求，比如向密钥服务请求凭证、统计 SQL 信息、SQL 性能收集、SQL 注入检查、SQL 翻译等，程序员可以通过定制来实现自己需要的功能。  </p>
</blockquote>
<blockquote>
<p>Druid 首先是一个数据库连接池，但它不仅仅是一个数据库连接池，还包含了一个 ProxyDriver，一系列内置的 JDBC 组件库，一个 SQL Parser。在 Java 的世界中 Druid 是监控做的最好的数据库连接池。  </p>
</blockquote>
<p><strong>167. Druid 有什么作用？</strong></p>
<ul>
<li><p>替换其他 Java 连接池，Druid 提供了一个高效、功能强大、可扩展性好的数据库连接池。</p>
</li>
<li><p>可以监控数据库访问性能，Druid 内置提供了一个功能强大的 StatFilter 插件，能够详细统计 SQL 的执行性能，这对于线上分析数据库访问性能有很大帮助。</p>
</li>
<li><p>数据库密码加密。直接把数据库密码写在配置文件中，这是不好的行为，容易导致安全问题，DruidDruiver 和 DruidDataSource 都支持 PasswordCallback。</p>
</li>
<li><p>SQL 执行日志，Druid 提供了不同的 LogFilter，能够支持 Common-Logging、Log4j 和 JdkLog，可以按需要选择相应的 LogFilter，监控应用的数据库访问情况。</p>
</li>
<li><p>扩展 JDBC，如果你要对 JDBC 层有编程的需求，可以通过 Druid 提供的 Filter 机制，很方便编写 JDBC 层的扩展插件。</p>
</li>
</ul>
<p><strong>168. 什么是 Spring Data JPA？</strong></p>
<blockquote>
<p>JPA（Java Persistence API）是 Sun 官方提出的 Java 持久化规范。它为 Java 开发人员提供了一种对象 / 关联映射工具来管理 Java 应用中的关系数据。它的出现主要是为了简化现有的持久化开发工作和整合 ORM 技术，结束现在 Hibernate、TopLink、JDO 等 ORM 框架各自为营的局面。JPA 是在充分吸收了现有的 Hibernate、TopLink、JDO 等 ORM 框架的基础上发展而来的，具有易于使用、伸缩性强等优点。  </p>
</blockquote>
<blockquote>
<p>Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套 JPA 应用框架，可以让开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增、删、改、查等在内的常用功能，且易于扩展，学习并使用 Spring Data JPA 可以极大提高开发效率。Spring Data JPA 其实就是 Spring 基于 Hibernate 之上构建的 JPA 使用解决方案，方便在 Spring Boot 项目中使用 JPA 技术。  </p>
</blockquote>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ol>
<li>LINUX 下线程、GDI 类的解释。</li>
</ol>
<ul>
<li><p>LINUX 实现的就是基于核心轻量级进程的”一对一”线程模型，一个线程实体对应一个核心轻量级进程，而线程之间的管理在核外函数库中实现。</p>
</li>
<li><p>GDI 类为图像设备编程接口类库。</p>
</li>
</ul>
<p><strong>170. 绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？</strong></p>
<ul>
<li><p>绝对路径： 如/etc/init.d</p>
</li>
<li><p>当前目录和上层目录： ./ ../</p>
</li>
<li><p>主目录： ~/</p>
</li>
<li><p>切换目录： cd</p>
</li>
<li><p><em>171. 怎么查看当前进程？怎么执行退出？怎么查看当前路径？*</em></p>
</li>
<li><p>查看当前进程： ps</p>
</li>
<li><p>执行退出： exit</p>
</li>
<li><p>查看当前路径： pwd</p>
</li>
<li><p><em>172. 怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户 id？查看指定帮助用什么命令？*</em></p>
</li>
<li><p>清屏： clear</p>
</li>
<li><p>退出当前命令： ctrl+c</p>
</li>
<li><p>彻底退出</p>
</li>
<li><p>执行睡眠 ： ctrl+z 挂起当前进程 fg 恢复后台</p>
</li>
<li><p>查看当前用户 id： ”id“：查看显示目前登陆账户的 uid 和 gid 及所属分组及用户名</p>
</li>
<li><p>查看指定帮助： 如 man adduser 这个很全 而且有例子； adduser –help 这个告诉你一些常用参数； info adduesr；</p>
</li>
<li><p><em>173. Ls 命令执行什么功能？ 可以带哪些参数，有什么区别？*</em></p>
</li>
<li><p>ls 执行的功能： 列出指定目录中的目录，以及文件。</p>
</li>
<li><p>哪些参数以及区别： a 所有文件 l 详细信息，包括大小字节数，可读可写可执行的权限等。</p>
</li>
<li><p><em>174. 建立软链接（快捷方式），以及硬链接的命令。*</em></p>
</li>
<li><p>软链接： ln -s slink source</p>
</li>
<li><p>硬链接： ln link source</p>
</li>
<li><p><em>175. 目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？*</em></p>
</li>
</ul>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">创建目录： mkdir</span><br><span class="line">创建文件：典型的如 touch，vi 也可以创建文件，其实只要向一个不存在的文件输出，都会创建文件</span><br><span class="line">复制文件： cp 7. 文件权限修改用什么命令？格式是怎么样的？</span><br><span class="line">文件权限修改： chmod</span><br><span class="line">格式如下：</span><br><span class="line">$ chmod u+x file 给 file 的属主增加执行权限</span><br><span class="line">$ chmod 751 file 给 file 的属主分配读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限</span><br><span class="line">$ chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x file 上例的另一种形式</span><br><span class="line">$ chmod &#x3D;r file 为所有用户分配读权限</span><br><span class="line">$ chmod 444 file 同上例</span><br><span class="line">$ chmod a-wx,a+r file 同上例</span><br><span class="line">$ chmod -R u+r directory 递归地给 directory 目录下所有文件和子目录的属主分配读的权限</span><br></pre></td></tr></table></figure>

<p><strong>176. 查看文件内容有哪些命令可以使用？</strong></p>
<ul>
<li><p>vi 文件名 ＃编辑方式查看，可修改</p>
</li>
<li><p>cat 文件名 ＃显示全部文件内容</p>
</li>
<li><p>more 文件名 ＃分页显示文件内容</p>
</li>
<li><p>less 文件名 ＃与 more 相似，更好的是可以往前翻页</p>
</li>
<li><p>tail 文件名 ＃仅查看尾部，还可以指定行数</p>
</li>
<li><p>head 文件名 ＃仅查看头部,还可以指定行数</p>
</li>
<li><p><em>177. Linux 下命令有哪几种可使用的通配符？分别代表什么含义？*</em></p>
</li>
<li><p>“?”可替代单个字符。</p>
</li>
<li><p>“*”可替代任意多个字符。</p>
</li>
<li><p>方括号“[charset]”可替代 charset 集中的任何单个字符，如 [a-z]、[abABC]</p>
</li>
<li><p><em>178. Grep 命令有什么用？ 如何忽略大小写？ 如何查找不含该串的行？*</em></p>
</li>
</ul>
<blockquote>
<p>是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [stringSTRING] filename grep [^string] filename</span><br></pre></td></tr></table></figure>

<p><strong>179. Linux 中进程有哪几种状态？在 ps 显示出来的信息中，分别用什么符号表示的？</strong></p>
<ul>
<li>不可中断状态：进程处于睡眠状态，但是此刻进程是不可中断的。不可中断， 指进程不响应异步信号。</li>
<li>暂停状态/跟踪状态：向进程发送一个 SIGSTOP 信号，它就会因响应该信号 而进入 TASK <em>STOPPED 状态;当进程正在被跟踪时，它处于 TASK</em> TRACED 这个特殊的状态。 “正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。</li>
<li>就绪状态：在 run_queue 队列里的状态。</li>
<li>运行状态：在 run_queue 队列里的状态。</li>
<li>可中断睡眠状态：处于这个状态的进程因为等待某某事件的发生（比如等待 socket 连接、等待信号量），而被挂起。</li>
<li>zombie 状态（僵尸）：父亲没有通过 wait 系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。</li>
<li>退出状态。</li>
<li>D 不可中断 Uninterruptible（usually IO）</li>
<li>R正在运行，或在队列中的进程</li>
<li>S处于休眠状态</li>
<li>T停止或被追踪</li>
<li>Z 僵尸进程</li>
<li>W 进入内存交换（从内核 2.6 开始无效）</li>
<li>X死掉的进程</li>
<li><em>180. 把后台任务调到前台执行使用什么命令?把停下的后台任务在后台执行起来用什么命令？*</em></li>
</ul>
<blockquote>
<p>fg。例如：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># jobs</span><br><span class="line"></span><br><span class="line">[1]+ Running &#x2F;root&#x2F;bin&#x2F;rsync.sh &amp;</span><br><span class="line"></span><br><span class="line"># fg 1 bg 类似</span><br></pre></td></tr></table></figure>

<p><strong>181. 查看当前谁在使用该主机用什么命令? 查找自己所在的终端信息用什么命令?</strong></p>
<ul>
<li><p>w：用户名称；用户的机器名称或 tty 号；远程主机地址；用户登录系统的时间；空闲时间（作用不大）;附加到 tty（终端）的进程所用的时间（JCPU 时间）；当前进程所用时间（PCPU时间）；用户当前正在使用的命令。</p>
</li>
<li><p>who：用户名、tty 号、时间日期、主机地址。</p>
</li>
<li><p>whoami,id -un：命令用于显示登入的用户名。</p>
</li>
<li><p>last：命令可用于显示特定用户登录系统的历史记录（last jason）；用户名称；tty 设备号；历史登录时间日期；登出时间日期；总工作时间。</p>
</li>
<li><p>查找自己所在终端信息：who am i。</p>
</li>
<li><p><em>182. 通过什么命令指定命令提示符？*</em></p>
</li>
<li><p>\u 显示当前用户账号 \h 显示当前主机名</p>
</li>
<li><p>\W 只显示当前路径最后一个目录 \w 显示当前绝对路径（当前用户目录会以 ~代替） <code>$PWD</code> 显示当前全路径 <code>\$</code> 显示命令行 ’$’ 或者 ’#’ 符号 # ：下达的第几个命令</p>
</li>
<li><p>\d：代表日期，格式为 weekday month date，例如：”Mon Aug 1”</p>
</li>
<li><p>\t：显示时间为 24 小时格式，如：HH：MM：SS \T ：显示时间为 12 小时格式 \A ：显示时间为 24 小时格式：HH：MM \v ：BASH 的版本信息，如 <code>export PS1=’[\u@\h \w\#]\$‘</code></p>
</li>
<li><p><em>183. du 和 df 的定义，以及区别？ du 显示目录或文件的大小。*</em></p>
</li>
</ul>
<blockquote>
<p>df 显示每个&lt;文件&gt;所在的文件系统的信息，默认是显示所有文件系统。 （文件系统分配其中的一些磁盘块用来记录它自身的一些数据，如 i 节点，磁盘分布图，间接块，超级块等。 这些数据对大多数用户级的程序来说是不可见的，通常称为 Meta Data。） du 命令是用户级的程序，它不考虑 Meta Data，而 df 命令则查看文件系统的磁盘分配 图并考虑 Meta Data。 df 命令获得真正的文件系统数据，而 du 命令只查看文件系统的部分情况。  </p>
</blockquote>
<p><strong>184. AWK 详解。</strong></p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#39;&#123;pattern + action&#125;&#39; &#123;filenames&#125;</span><br><span class="line"> \#cat &#x2F;etc&#x2F;passwd |awk -F &#39;:&#39; &#39;&#123;print $1&quot;\t&quot;$7&#125;&#39; &#x2F;&#x2F;-F 的意思是以&#39;:&#39;分隔 root &#x2F;bin&#x2F;bash</span><br><span class="line"> daemon &#x2F;bin&#x2F;sh 搜索&#x2F;etc&#x2F;passwd 有 root 关键字的所有行</span><br><span class="line"></span><br><span class="line">\#awk -F: &#39;&#x2F;root&#x2F;&#39; &#x2F;etc&#x2F;passwd root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<h3 id="软件工程与设计模式"><a href="#软件工程与设计模式" class="headerlink" title="软件工程与设计模式"></a>软件工程与设计模式</h3><p><strong>185. UML 方面。</strong></p>
<blockquote>
<p>标准建模语言 UML。用例图、静态图（包括类图、对象图和包图)、行为图、交互图（顺序图、合作图）、实现图。  </p>
</blockquote>
<p><strong>186. J2EE 常用的设计模式？说明工厂模式。</strong></p>
<blockquote>
<p>总共 23 种，分为三大类：创建型、结构型、行为型。我只记得其中常用的 6、7 种，分别是：创建型（工厂、工厂方法、抽象工厂、单例），结构型（包装、适配器、组合、代理），行为（观察者，模版，策略），然后再针对你熟悉的模式谈谈你的理解即可。  </p>
</blockquote>
<blockquote>
<p>Java 中的 23 种设计模式：  </p>
</blockquote>
<ul>
<li>Factory（工厂模式）</li>
<li>Builder（建造模式）</li>
<li>Factory Method（工厂方法模式）</li>
<li>Prototype（原始模型模式）</li>
<li>Singleton（单例模式）</li>
<li>Facade（门面模式）</li>
<li>Adapter（适配器模式）</li>
<li>Bridge（桥梁模式）</li>
<li>Composite（合成模式）</li>
<li>Decorator（装饰模式）</li>
<li>Flyweight（享元模式）</li>
<li>Proxy（代理模式）</li>
<li>Command（命令模式）</li>
<li>Interpreter（解释器模式）</li>
<li>Visitor（访问者模式）</li>
<li>Iterator（迭代子模式）</li>
<li>Mediator（调停者模式）</li>
<li>Memento（备忘录模式）</li>
<li>Observer（观察者模式）</li>
<li>State（状态模式）</li>
<li>Strategy（策略模式）</li>
<li>Template Method（模板方法模式）</li>
<li>Chain Of Responsibleity（责任链模式）<blockquote>
<p>工厂模式：工厂模式是一种经常被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。  </p>
</blockquote>
</li>
</ul>
<p><strong>187. 开发中都用到了那些设计模式?用在什么场合？</strong></p>
<blockquote>
<p>每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。主要用到了 MVC 的设计模式。用来开发 JSP/Servlet 或者 J2EE 的相关应用。简单工厂模式等。  </p>
</blockquote>
<h3 id="Web-Service"><a href="#Web-Service" class="headerlink" title="Web Service"></a>Web Service</h3><p><strong>188. Web Service 名词解释，JSWDL 开发包的介绍，JAXP、JAXM 的解释，SOAP、UDDI、WSDL 解释。</strong></p>
<blockquote>
<p><strong>Web ServiceWeb Service</strong> 是基于网络的、分布式的模块化组件，它执行特定的任务，遵守具体的技术规范，这些规范使得Web Service能与其他兼容的组件进行互操作。   </p>
</blockquote>
<blockquote>
<p>JAXP（Java API for XML Parsing）定义了在 Java 中使用 DOM、SAX、XSLT 的通用的接口。这样在你的程序中你只要使用这些通用的接口，当你需要改变具体的实现时候也不需要修改代码。  </p>
</blockquote>
<blockquote>
<p><strong>JAXM（Java API for XML Messaging）</strong> 是为 SOAP 通信提供访问方法和传输机制的 API。   </p>
</blockquote>
<blockquote>
<p><strong>WSDL</strong> 是一种 XML 格式，用于将网络服务描述为一组端点，这些端点对包含面向文档信息或面向过程信息的消息进行操作。这种格式首先对操作和消息进行抽象描述，然后将其绑定到具体的网络协议和消息格式上以定义端点。相关的具体端点即组合成为抽象端点（服务）。   </p>
</blockquote>
<blockquote>
<p><strong>SOAP</strong> 即简单对象访问协议（Simple Object Access Protocol），它是用于交换 XML 编码信息的轻量级协议。   </p>
</blockquote>
<blockquote>
<p><strong>UDDI</strong> 的目的是为电子商务建立标准；UDDI 是一套基于 Web 的、分布式的、为 Web Service 提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的 Web Service 注册，以使别的企业能够发现的访问协议的实现标准。  </p>
</blockquote>
<p><strong>189. CORBA 是什么？用途是什么？</strong></p>
<blockquote>
<p><strong>CORBA</strong>  </p>
</blockquote>
<blockquote>
<p>标准是公共对象请求代理结构（Common Object Request Broker Architecture），由对象管理组织（Object Management Group，缩写为 OMG）标准化。它的组成是接口定义语言（IDL），语言绑定（binding 也译为联编）和允许应用程序间互操作的协议。 其目的为：用不同的程序设计语言书写在不同的进程中运行，为不同的操作系统开发。  </p>
</blockquote>
<p>190、JSWDL 开发包的介绍。</p>
<ul>
<li><strong>JAXP</strong> （Java API for XML Parsing）：定义了在 Java 中使⽤ DOM、SAX、XSLT 的通⽤的接⼝。</li>
<li><strong>JAXM</strong> （Java API for XML Messaging）：是为 SOAP 通信提供访问方法和传输机制的 API。</li>
<li><strong>SOAP</strong> ：简单对象访问协议（Simple Object Access Protocol），它是用于交换 XML 编码信息的轻量级协议。</li>
<li><strong>UDDI</strong> ：基于 Web 的、分布式的、为 Web Service 提供的、信息注册中心的实现标准规范 。</li>
<li><strong>WSDL</strong> ：是一种 XML 格式，⽤于将⽹络服务描述为一组端点，这些端点对包含面向文档信息或⾯向过程信息的消息进⾏操作。<h3 id="答题技巧"><a href="#答题技巧" class="headerlink" title="答题技巧"></a>答题技巧</h3></li>
</ul>
<blockquote>
<p>回答问题的思路：先正面叙述一些 <strong>基本的核心知识</strong> ，然后描述一些 <strong>特殊的东西</strong> ，最后再来一些 <strong>锦上添花的东西</strong> 。要注意有些不是锦上添花，而是画蛇添足的东西，不要随便写上。把答题像写书一样写。我要回答一个新技术的问题大概思路和步骤是：我们想干什么，怎么干，干的过程中遇到了什么问题，现在用什么方式来解决。其实我们讲课也是这样一个思路。  </p>
</blockquote>
<blockquote>
<p>例如，讲 AJAX 时，我们希望不改变原来的整个网页，而只是改变网页中的局部内容，如用户名校验、级联下拉列表、下拉树状菜单。用传统方式，就是浏览器自己直接向服务器发请求，服务器返回新页面会盖掉老页面，这样就不流畅了。  </p>
</blockquote>
<blockquote>
<p>答题时，先答是什么，再答有什么作用和要注意什么（这部分最重要，展现自己的心得）。  </p>
</blockquote>
<blockquote>
<p>答案的段落分别，层次分明，条理清晰都非常重要，从这些表面的东西也可以看出一个人的习惯、办事风格、条理等。  </p>
</blockquote>
<blockquote>
<p>要讲你做出答案的思路过程，或者说你记住答案的思想都写下来。把答题想着是辩论赛。答题就是给别人讲道理、摆事实。答题不局限于什么格式和形式，就是要将自己的学识展现出来！  </p>
</blockquote>
<blockquote>
<p>别因为人家题目本来就模棱两可，你就心里胆怯和没底气了，不敢回答了。你要大胆地指出对方题目很模糊和你的观点，不要把面试官想得有多高，其实他和你就是差不多的，你想想，如果他把你招进去了，你们以后就是同事了，可不是差不多的吗？  </p>
</blockquote>
<blockquote>
<p>关于就业薪水，如果你是应届生，那不能要高工资，好比大饼的故事，没有文凭还想拿高工资，就去中关村缺什么补什么吧！少数人基础确实很好，在校期间确实又做过一些项目，那仍然是可以要到相对高的工资的。  </p>
</blockquote>
<blockquote>
<p><strong>公司招聘程序员更看重的要用到的编码技术、而不是那些业务不太相关的所谓项目经历。</strong>  </p>
</blockquote>
<ol>
<li>公司想招什么样的；</li>
<li>公司面试会问什么；</li>
<li>简历怎么写；</li>
<li>怎样达到简历上的标准（培训中心教项目的目的）。<blockquote>
<p>对于一些公司接到了一些项目，想招聘一些初中级的程序员过来帮助写代码，完成这个项目，你更看重的是他的专业技术功底，还是以前做过几个项目的经历呢？我们先排除掉那些编码技术功底好，又正好做过相似项目的情况，实际上，这种鱼和熊掌兼得的情况并不常见。  </p>
</blockquote>
</li>
</ol>
<blockquote>
<p>其实公司很清楚，只要招聘进来的人技术真的很明白，那他什么项目都可以做出来，公司招人不是让你去重复做你以前的项目，而是做一个新项目，业务方面，你只要进了项目团队，自然就能掌握。所以，大多数招聘单位在招聘那些编码级别的程序员时也没指望能招聘到做过类似项目的人，也不会刻意去找做过类似项目的人，用人单位也不是想把你招进，然后把你以前做过的项目重做一遍。  </p>
</blockquote>
<blockquote>
<p>所以，用人单位更看重招进来的人对要用到的编码技术的功底到底怎样，技术扎实不扎实，项目则只要跟着开发团队走，自然就没问题。除非是一些非常专业的行业，要招聘特别高级的开发人员和系统分析师，招聘单位才特别注重他的项目经验和行业经验，要去找到行业高手，公司才关心项目和与你聊项目的细节，这样的人通常都不是通过常规招聘渠道去招聘进来的，而是通过各种手段挖过来的，这情况不再我今天要讨论的范围中。  </p>
</blockquote>
<blockquote>
<p>技术学得明白不明白，人家几个问题就把你的深浅问出来了，只要问一些具体的技术点，就很容易看出你是真懂还是假懂，很容看出你的技术深度和实力，所以，技术是来不得半点虚假的，必须扎扎实实。  </p>
</blockquote>
<blockquote>
<p>由于项目的种类繁多，涉及到现实生活中的各行各业，什么五花八门的业务都有，例如，酒店房间预定管理，公司车辆调度管理，学校课程教室管理，超市进销存管理，知识内容管理，等等……成千上万等等，但是，不管是什么项目，采用的无非都是我们学习的那些目前流行和常用的技术。  </p>
</blockquote>
<blockquote>
<p>技术好、经验丰富，则项目做出来的效率高些，程序更稳定和更容易维护些；技术差点，碰碰磕磕最后也能把项目做出来，无非是做的周期长点、返工的次数多点，程序代码写得差些，用的技术笨拙点。如果一个人不是完完全全做过某个项目，他是不太关心该项目的业务的，对其中的一些具体细节更是一窍不知（如果我招你来做图书管理，你项目经历说你做过汽车调度，那我能问你汽车调度具体怎么回事吗？不会，所以，你很容易蒙混过去的）。  </p>
</blockquote>
<blockquote>
<p>而一个程序员的整个职业生涯中能实实在在和完完整整做出来的项目没几个，更别说在多个不同行业的项目了，有的程序员更是一辈子都只是在做某一个行业的项目，结果他就成了这个行业的专家（专门干一件事的家伙）。所以，技术面试官通常没正好亲身经历过你简历写的那些项目，他不可能去问你写的那些项目的具体细节，而是只能泛泛地问你这个项目是多少人做的，做了多长时间，开发的过程，你在做项目的过程中有什么心得和收获，用的什么技术等面上的问题，所以，简历上的项目经历可以含有很多水分，很容易作假，技术面试官也无法在项目上甄别你的真伪。  </p>
</blockquote>
<blockquote>
<p>简历该怎么写： <strong>精通那些技术，有一些什么项目经历</strong>  </p>
</blockquote>
<blockquote>
<p>讲的项目应该真实可靠才有价值，否则，表面上是项目，实际上还是知识点的整合，对巩固技术点和增强学习的趣味性，但无法获得实际的项目经验。（项目主要是增加你经验的可信度，获得更多面试机会，真正能不能找到工作，找到好工作，主要看你键盘上的功夫了），好的面试官几下就能面出你是否真有工作经验，他们问技术以外的公司的人和事，并且问开始、过程、结果，看你怎么编。  </p>
</blockquote>
<blockquote>
<p>建议大家尽量开自己的 blog，坚持每天写技术 blog。在简历上写上自己的 blog 地址，可以多转载一些技术文章。  </p>
</blockquote>
<h3 id="人事问题"><a href="#人事问题" class="headerlink" title="人事问题"></a>人事问题</h3><p><strong>191. 请讲一下这样一个经历：尽管其他人反对，但是你还是坚持自己的观点，并把事情继续做下去。</strong></p>
<blockquote>
<p>【思路】从自己积极方面回答，比如家人和老师都希望我报考会计专业，而我对会计就是不感兴趣，毅然选择了计算机专业。我现在毕业，专业技能很强，而且有自己成熟的作品，计算机是我的事业，将继续做下去。  </p>
</blockquote>
<p><strong>192. 你的一位领导脾气比较急，批评下属时常常不留情面，大家的工作情绪经常受到影响。作为职员，你该怎么办？</strong></p>
<blockquote>
<p>【思路】首先对领导的批评应该认真接受，不能因为领导严厉的批评而产生逆反心理，以致影响工作； 其次可以私下找机会和领导沟通，向领导反映下属因此产生的意见和情绪，婉转地说明这种情绪可能会影响工作的正常开展，至于是否接受建议、改变方法，由领导自己决定。  </p>
</blockquote>
<p><strong>193. 与上级意见不一是，你将怎么办？</strong></p>
<blockquote>
<p>正确回答：首先呢，作为一个员工我的是不会和上级产生争执的，如果真有意见不一致的时候，我想我会服从领导安排的。  </p>
</blockquote>
<blockquote>
<p>【思路】  </p>
</blockquote>
<ol>
<li>一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”</li>
<li>如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。”</li>
</ol>
<p><strong>194. 你是应届毕业生，缺乏经验，如何能胜任这项工作？</strong></p>
<blockquote>
<p>正确回答：作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。  </p>
</blockquote>
<blockquote>
<p>【思路】  </p>
</blockquote>
<ol>
<li>如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘单位并不真正在乎“经验”，关键看应聘者怎样回答。</li>
<li>对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。</li>
</ol>
<p><strong>195. 你为什么觉得自己能够在这个职位上取得成就？</strong></p>
<blockquote>
<p>正确回答： 从我的经历来看，这是我的职业生涯中最适合我的一份工作。几年来，我一直在研究这个领域并且关注贵公司，一直希望能有这样的面试机会。我拥有必备的技能（简单讲述一个故事来加以说明），我非常适合这一职位，也确实能做好这份工作。  </p>
</blockquote>
<blockquote>
<p>【思路】这是一个相当宽泛的问题，它给求职者提供了一个机会，可以让求职者表明自己的热情和挑战欲。对这个问题的回答将为面试人在判断求职者是否对这个职位有足够的动力和自信心方面提供关键信息。  </p>
</blockquote>
<p><strong>196. 你希望 5 年后达到什么成就？</strong></p>
<ul>
<li>A. 做一天和尚敲一天钟，尽人事听天命、顺其自然。</li>
<li>B. 依我的机灵及才干，晋升到部门经理是我的中期目标。</li>
<li>C. 自己独当一面开公司。</li>
<li>D. “全力以赴”是我的座右铭，希望能随着经验的增加，被赋予更多的职责及挑战。<blockquote>
<p>解答：最理想的回答是 D。  </p>
</blockquote>
</li>
</ul>
<p><strong>197. 5 年之内你想处于什么位置？</strong></p>
<blockquote>
<p>正确回答：我希望有机会在工厂或国内办事处工作。我也希望通过管理一个小团体发展我的管理技能。  </p>
</blockquote>
<blockquote>
<p>【思路】不要给出具体的时限或工作头衔。谈你喜欢的东西，你天生的技能，实际的问题和在你所选的领域或行业里你希望有什么机会，你希望从那些经验中学点什么。不要谈论你在那些与你所应聘的工作无关的领域或行业里的目标。这是听起来很明显的道理，但是很多求职者会犯这个错误。不经意间你就表现出了对当前的领域或行业缺乏真正的兴趣。不用说，一失言马上就会把你从进一步的考虑中淘汰掉。  </p>
</blockquote>
<p><strong>198. 如果你有无限的时间和经济来源，你会怎样使用它们呢？</strong></p>
<blockquote>
<p>正确回答：我希望能参加几次不针对金融专家的有关金融管理的行政研讨会。我还希望能让我的部门放长假，把每一个人都派去参加外界的一些活动。最后，我很可能去旅游并考察一下外国竞争者，同时一路享受当地的美食，您呢？  </p>
</blockquote>
<blockquote>
<p>【思路】虽然娱乐的事情谈起来很有诱惑力，但一定要紧扣工作或与行业相关的事务，或者紧扣与你应聘的这份工作的技能相关的努力上。例如，你正在应聘教书工作，你可能对义务教授成年人读书识字的项目感兴趣。这就证明了你对自己的工作领域的激情，即对教育重要性的一种信仰，即使是作为一种兴趣而毫无报酬都无所谓。  </p>
</blockquote>
<p><strong>199. 假如现在是你在我们公司做首次年度总结，我该告诉你一些什么呢？</strong></p>
<blockquote>
<p>正确回答：您要感谢我把工作完成得很好，并说明您渴望能够继续看到我工作的好成绩。更重要的是，我希望您能告诉我，您很欣赏我为一些重要项目加班加点工作的行为，还有我富有创造性的思维是如何有助于对存在的问题提出改革方案的。  </p>
</blockquote>
<blockquote>
<p>【思路】很明显，在回答该问题时，你想给人留下积极的印象。“但愿您能更准时地出现”绝对不是一个好答案。记住，重点谈一两点你个人的优势。  </p>
</blockquote>
<p><strong>200. 为什么你想在这里工作？</strong></p>
<blockquote>
<p>正确回答：我几年前就错过了你们公司的一次招标，之后我意识到电脑产品变得越来越相近了，且零售价格的竞争愈趋激烈，以致服务成为了一家公司在竞争中脱颖而出的最好的方法。贵公司在所有的竞争者中享有最好的服务记录，而我相信从长远看，它将主宰这个行业。你的准备和调查研究工作应在这里明显表现出来。  </p>
</blockquote>
<blockquote>
<p>【思路】给出一到两个你对该公司感兴趣的原因，并表明什么最激发你的兴趣。什么是你可以叙述来表明你个人对该公司的认识的最有说服力的事情呢？它的产品还是它的员工？答案包括公司的信誉、对该工作本身的描述，或者是跻身于该企业的欲望。  </p>
</blockquote>
<p><strong>201. 你对加班的看法。</strong></p>
<blockquote>
<p>正确回答：首先我想确认下，是何种性质的加班？ 如果是我个人的工作量是在规定的时间内没有完成的话，这种情况是不会发生的，我是个注重工作效率的人。其次如果是公司业务量临时增加的话，我会接受加班。  </p>
</blockquote>
<blockquote>
<p>【思路】首先，明确的告诉对方，如果是因为自己在规定的时间内没有完成工作任务的话 ，需要加班的情况是几乎不可能出现的，“我是个注重工作效率的人”其次，如果是因为公司业务情况或者其他的一些紧急工作的话是可以适应加班的。  </p>
</blockquote>
<p><strong>202. 你能给公司带来什么？</strong></p>
<blockquote>
<p>【思路】一般外企很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。外企喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。”等等。  </p>
</blockquote>
<p><strong>203. 你认为你在学校属于好学生吗？</strong></p>
<blockquote>
<p>【思路】企业的招聘者很精明，问这个问题可以试探出很多问题：如果求职者学习成绩好，就会说：“是的，我的成绩很好，所有的成绩都很优异。当然，判断一个学生是不是好学生有很多标准，在学校期间我认为成绩是重要的，其他方面包括思想道德、实践经验、团队精神、沟通能力也都是很重要的，我在这些方面也做得很好，应该说我是一个全面发展的学生。”如果求职者成绩不尽理想，便会说：“我认为是不是一个好学生的标准是多元化的，我的学习成绩还可以，在其他方面我的表现也很突出，比如我去很多地方实习过，我很喜欢在快节奏和压力下工作，我在学生会组织过××活动，锻炼了我的团队合作精神和组织能力。” 有经验的招聘者一听就会明白，企业喜欢诚实的求职者。  </p>
</blockquote>
<p><strong>204. 有人说“成功是对人有益的”，也有人说“失败是对人有益的”，你怎么看？</strong></p>
<blockquote>
<p>【思路】成功是对努力的一种回报，一种肯定，能使人们认识到自身的价值，对自身是一种动力，能激发人们继续创新、学习的勇气！当然，成功是对人有益的。 “失败是对人有益的”，俗话说“失败乃成功之母”，它给予人们更多的是经验与坚韧顽强的精神和永不认输的斗志，所以说“失败是对人有益的”。 这类题的应对方法：辩证地看、联系地看，肯定一方但不否定另一方，两者是有机的统一。  </p>
</blockquote>
<p><strong>205. 如果我们单位录用了你，但工作一段时间却发现你根本不适合这个职位你怎么办？</strong></p>
<blockquote>
<p>【思路】一段时间发现工作不适合我，有两种情况：  </p>
</blockquote>
<ol>
<li>如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；</li>
<li>你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。</li>
</ol>
<p><strong>206. 你最大的长处和弱点分别是什么？这些长处和弱点对你在企业的业绩会有什么样的影响？</strong></p>
<blockquote>
<p>【思路】这个问题的最大陷阱在于，第一个问题实际上是两个问题，而且还要加上一个后续问题。这两个问题的陷阱并不在于你是否能认真地看待自己的长处，也不在于你是否能正确认识自己的弱点。记住，你的回答不仅是向面试人说明你的优势和劣势，也能在总体上表现你的价值观和对自身价值的看法。  </p>
</blockquote>
<blockquote>
<p>长处来说，我相信我最大的优点是我有一个高度理性的头脑，能够从混乱中整理出头绪来。我最大的弱点是，对那些没有秩序感的人，可能缺乏足够的耐心。我相信我的组织才能可以帮助企业更快地实现目标，而且有时候，我处理复杂问题的能力也能影响我的同事。  </p>
</blockquote>
<p><strong>207. 除了工资，还有什么福利最吸引你？</strong></p>
<blockquote>
<p>【思路】尽可能诚实，如果你做足了功课，你就知道他们会提供什么，回答尽可能和他们提供的相配。如果你觉得自己该得到更多，也可以多要一点。  </p>
</blockquote>
<p><strong>208. 有人说，善意的谎言是对的，你如何看？</strong></p>
<blockquote>
<p>【思路】这个问题不能一概而论的， 它仅仅动机是善意的， 但是造成的后果好不好呢， 如果反而引起更大的伤害， 那么就得不偿失了；其次是对象，如果对象意志毅力很强，能够接受突如其来的打击，并且不喜欢别人骗他哪怕是善意的，那么善意的谎言便毫无意义，有时反而造成误会。但是善意的谎言在更多程度上都是对的可以接受的，它可以最大地减少不必要的痛苦，能够起到积极的作用。  </p>
</blockquote>
<p><strong>209. 领导要你 4 天完成一件工作，突然要你 2 天完成，你该怎么办？</strong></p>
<blockquote>
<p>【思路】  </p>
</blockquote>
<ol>
<li>首先分析一下提前完成工作的可能性。</li>
<li>如果确定完不成的，那么去跟领导详谈，跟他讲道理摆事实，说明没法完成的理由。一定要有充足的理由，才能说服他。</li>
<li>如果可以完成，但是需要其他条件的配合的，那么找领导说明情况。请领导给于支持。</li>
<li>如果经过自己努力可以完成的，那么就努力完成吧。</li>
</ol>
<p><strong>210. 你认为这些年来同事对你怎么样？</strong></p>
<blockquote>
<p>【思路】：面试官问这个问题的目的，主要想从你的同事对你的态度和评价上推测你这个人是什么样的，对于你来说回答这个问题要谨慎。比如：同事对我都很热心（从侧面反衬你对同事也很热心）；同事们有棘手的工作我会主动去帮助他们，所以我有事情的时候他们都来帮助我等等。  </p>
</blockquote>
<p><strong>211. 向面试官提出的问题。</strong></p>
<blockquote>
<p>贵公司对这项职务的工作内容和期望目标为何？有没有什么部分是我可以努力的地方？  </p>
</blockquote>
<blockquote>
<p>贵公司是否有正式或非正式教育训练？  </p>
</blockquote>
<blockquote>
<p>贵公司的升迁管道如何？  </p>
</blockquote>
<blockquote>
<p>贵公司的多角化经营，而且在海内外都设有分公司，将来是否有外派、轮调的机会？  </p>
</blockquote>
<blockquote>
<p>贵公司能超越同业的最大利基点为何？  </p>
</blockquote>
<blockquote>
<p>贵公司强调的团队合作中，其它的成员素质和特性如何？  </p>
</blockquote>
<blockquote>
<p>能否为我介绍一下工作环境，或者是否有机会能参观一下贵公司？  </p>
</blockquote>
<blockquote>
<p>【思路】在面试结束前，大多数的主考官都会丢问题给求职者，最常见的就是：你有没有什么问题或疑问，想要提出来的？无论求职者是否有提出问题，其实，这个问题背后的真正含意，通常是主考官用来测试你对这份工作有多大的企图心、决心和热情。  </p>
</blockquote>
<blockquote>
<p>因此，如果你害怕发问不妥当，或是不知道该从何问起，甚至回答没有问题时，都很可能会让主考官认为，你想要这份工作的企图心、决心还不够强。  </p>
</blockquote>
<blockquote>
<p>相反地，求职者应该更积极、主动的利用面试最后一关的机会，适时的提出问题，这不但有助于主考官对你的印象能够加深，而且你也能趁此机会进一步了解这家公司的背景、企业文化是否适合你。  </p>
</blockquote>
<blockquote>
<p>最重要的是，如果能够在面试时，提出漂亮的问题，录取的机率将会大大提高。所以，无论如何，前往面试前，先谨记10个可以反问主考官的问题，以便到时候可以提出。  </p>
</blockquote>
<blockquote>
<p>至于薪水待遇、年假天数、年终奖金、福利措施等问题，有些公司的主考官在面试时，会直接向求职者提出。如果对方没有提及，对社会新鲜人来说，在找第一份工作时，比较不适合提出，除非你有对方不得不录取你的条件。另外，也有人在结束前，谦虚的请教主考官：您认为我今天的表现如何？录取的机率有多大？通常，这个问题也会让对方认为，你对这份工作抱有很大的决心和企图心，而你也可以试着从对方的回答中，约略猜测出自己成功的机率有多大，并且作为下一次面试时表现的参考！  </p>
</blockquote>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>非常感谢各位读者的支持，笔者水平有限，知识点上难免会有遗漏的地方，如果大家有更好的想法或者建议，欢迎留言。也可加我微信：nnsouthwind，进行更进一步的交流。</p>
<p>最后祝大家工作顺利，薪资翻倍，附上本文 PDF 资源的下载链接。</p>
<blockquote>
<p>链接: <a href="https://pan.baidu.com/s/1jfVHaaXDMWYeNloGgG1-Dg">https://pan.baidu.com/s/1jfVHaaXDMWYeNloGgG1-Dg</a> 提取码: dnak  </p>
</blockquote>
<hr>
<p>本文首发于 GitChat，未经授权不得转载，转载需与 GitChat 联系。</p>
<p>登录后订阅Chat<br><a href="#">24</a> <a href="#">3</a><br>写评论<br><a href="#">向作者提问</a></p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/6644ecb0-b559-11e8-9a21-09295a3d7e19" alt=""></p>
<p>One<br>先不说别的，先来个赞<br>2018年12月4日</p>
<p>11</p>
<p>1</p>
<p>宁楠: 感谢支持。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/0d41f040-d336-11e8-83c4-93b72872a9ed" alt=""></p>
<p>民<br>很好的chat,首先从内容数量上就该点赞了。<br>2018年12月4日</p>
<p>7</p>
<p>1</p>
<p>宁楠: 感谢支持。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/f5d017a0-ac40-11e8-8a14-814e96ebc1f4" alt=""></p>
<p>Nono.c.Rook<br>说拼凑来的 真的是不知道什么想法，在我看来这边文章就算是拼凑来的，但是只要有你不懂的，看这篇文章记住了的知识点就是不亏的，更何况还是大佬辛辛苦苦平时积累，总结的。5块钱，一张地铁票钱，可能你面试的时候就因为这里的一个点你记住了，能回答上面试官的某个问题了。所以你觉得亏吗？多点感恩，少点戾气吧。<br>2018年12月5日</p>
<p>7</p>
<p>1</p>
<p>宁楠: 正能量满满，感谢支持。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/6a05a260-f9ae-11e8-9b6b-a5fce06a523c?imageView2/1/w/200/h/200" alt=""></p>
<p>快乐<br>对我来说很好很有用，覆盖了我的知识漏洞，非常感谢作者，这么多内容光整理排版就很不容易，真不知道那些鸡蛋里挑骨头的人脑子都是咋想的。<br>2018年12月5日</p>
<p>6</p>
<p>1</p>
<p>宁楠: 感谢支持，吸收对自己有用的就行了。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/f4a6ed10-f9b4-11e8-9a77-a1dd83a1c487?imageView2/1/w/200/h/200" alt=""></p>
<p>岁月静好<br>整体来说不错，虽然知识点上有遗漏，但是一篇文章能汇总这么多内容，已经很好了。提个小建议，有些问题的答案篇幅过长，可以适当精简一下，感谢作者提供这么好的一份资料。至于说东拼西凑的那些人，呵呵，无论文章写的怎么样，总会有人挑毛病，众口难调，但是起码应该尊重别人的劳动成果，心怀感恩。<br>2018年12月5日</p>
<p>6</p>
<p>1</p>
<p>宁楠: 建议收到，感谢。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/5851b530-b7ba-11e8-9d9d-aba50ff29480" alt=""></p>
<p>安于她梦<br>这从哪儿东拼西凑来的？<br>2018年12月4日</p>
<p>3</p>
<p>1</p>
<p>宁楠: 收集自网络，书，日常工作等渠道。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/e63b2960-f9d4-11e8-bf62-7b30373320ba" alt=""></p>
<p>四年<br>很不错<br>2018年12月5日</p>
<p>2</p>
<p>1</p>
<p>宁楠: 感谢支持。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/2abdf580-f175-11e8-af10-4396b0560f7c" alt=""></p>
<p>木叶<br>算法<br>2018年12月5日</p>
<p>1</p>
<p>1</p>
<p>宁楠: 开篇就是算法。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/68e23d20-5898-11e7-8049-a5327097ea48" alt=""></p>
<p>一枝花算不算浪漫<br>感觉是各种东拼西凑的东西。都什么年代了还有hibernate的面试题。<br>2018年12月4日</p>
<p>0</p>
<p>3</p>
<p>谢工: 找有用的部分有选择的看看<br>宁楠: 看你需要的，不需要的就直接忽略好么。<br>别来无恙ζ: 我就用hibernate 有什么不好么</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/d9c89ac0-76cf-11e7-bbea-b5e384e58415" alt=""></p>
<p>别来无恙ζ<br>这份Chat最适合应聘什么职位的人来看<br>2018年12月5日</p>
<p>0</p>
<p>1</p>
<p>宁楠: 无论哪个阶段的Java开发都能有所借鉴，每个人都有知识盲点。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/90089410-f45c-11e8-9bf4-dfe2abdfb7f1" alt=""></p>
<p>@<br>比较适合初学者<br>2018年12月5日</p>
<p>0</p>
<p>1</p>
<p>宁楠: 对，初学者应该好好看看。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/4950d680-f6dd-11e8-8106-33a106efcb0b" alt=""></p>
<p>Nyx<br>一般吧 跟预期有差距<br>2018年12月1日</p>
<p>0</p>
<p>1</p>
<p>宁楠: 好的。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/2d730370-ee40-11e8-875e-f9c063aa1910" alt=""></p>
<p>Mark<br>感觉不值。<br>2018年12月1日</p>
<p>0</p>
<p>1</p>
<p>宁楠: 211道题你认为多少钱值？</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/8be9d290-fda8-11e8-bc51-a7b1de7ce4f3" alt=""></p>
<p>杨丹<br>好多都是面试宝典里的内容<br>2018年12月3日</p>
<p>0</p>
<p>1</p>
<p>宁楠: 211道题，内容多了难免会有重叠。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/d9c89ac0-76cf-11e7-bbea-b5e384e58415" alt=""></p>
<p>别来无恙ζ<br>看会了一半，会有人要嘛<br>2018年12月3日</p>
<p>0</p>
<p>0</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/b2817c90-ccef-11e7-a2c1-9126334b1dc9" alt=""></p>
<p>Safari<br>43. switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上? JDK 1.7以后switch支持String类型了<br>2018年12月4日</p>
<p>0</p>
<p>1</p>
<p>宁楠: 对，答案写错了，抱歉，感谢指正。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/6e331340-f2ba-11e8-9572-13f523650544" alt=""></p>
<p>Emine<br>第一题就明显不对。Pattern p2 = Pattern.compile(“\d{6}(\d{8}).*”);，只适合18位的身份证号。15位的身份证，日期一共就6位，要这么写Pattern.compile(“\d{6}(\d{6}).*”)<br>7天前</p>
<p>0</p>
<p>0</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/faa618c0-1643-11e9-9167-29294e8d9945" alt=""></p>
<p>鼎晟<br>很棒 ^ _ ^😍<br>1天前</p>
<p>0</p>
<p>0</p>
<p>×</p>
<h4 id="文章评论"><a href="#文章评论" class="headerlink" title="文章评论"></a>文章评论</h4><p>0/200</p>
<p>提交</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FjUg5IGe5ThyN4F3BgPwVLtNUH6z?imageView2/1/h/500" alt=""><br>Chat<br>免费订</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/Frl6G1w68QeqEpWzShYkZkF0ehqs?imageView2/1/h/500" alt=""><br>课程<br>随心学</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/Fiyy0OVXYs6dh8eIcTFz0eC_PZeG?imageView2/1/h/500" alt=""><br>好书<br>每月领</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FtpKeUnInA1OgvIFtJjDKmOBO30g?imageView2/1/h/500" alt=""><br>专家<br>畅快聊</p>
<p>成为会员</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FlCRq4HauzLPJ4HG__hQg68Dutqf" alt=""><br> 热门分类</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FjgoMiaOzWmUU3JgdX3qvkBGGQ91" alt=""><br><a href="/gitchat/categories/58e84f875295227534aad506/1">前端</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FuPwXhHD3AxVmjsNdsmwGMK2Snxm" alt=""><br><a href="/gitchat/categories/58e84f53ec8e9e7b34457809/2">人工智能</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FmfNJDcE5rxC2X8GjgH8cfc8sFdW" alt=""><br><a href="/gitchat/categories/58e84f6bad952d6b3428af9a/3">架构</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/Fikw2zHy2kEE5fDxXgnH6aznmCEw" alt=""><br><a href="/gitchat/categories/5953698a3d38293ecceacb89/4">区块链</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FkEA14MZoO2nVDHiO2hRZcNASz14" alt=""><br><a href="/gitchat/categories/58e84f1584c651693437f27c/5">职场</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FidoaTbc4rvNKqFISPUs_0_NC1Xd" alt=""><br><a href="/gitchat/categories/59c491948fee063dc3c447ab/6">编程语言</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FuMNvLb25yJ4RiEg_2OnS8jpI8aB" alt=""><br><a href="/gitchat/categories/58e84f31ad952d6b3428af99/7">技术管理</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FsAwwVyxgMp5jrw3V1OzBAFRlZXd" alt=""><br><a href="/gitchat/categories/58e84f7bec8e9e7b3445780d/8">大数据</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FvClrIKCKLu4pj4tys0BMpr3IEy_" alt=""><br><a href="/gitchat/categories/591171a3e692d5280d8157b6/9">移动开发</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FhpGxdtnPjzRslCSUnNKdBXdjGLQ" alt=""><br><a href="/gitchat/categories/58e84f2284c651693437f27d/10">产品与运营</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FiDhwLN1jdKDRmYqdySCaKcw-1R3" alt=""><br><a href="/gitchat/categories/58e84f425295227534aad502/11">测试</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FrRYtPEGuW_ZbSEIUIQRHOPlzVPc" alt=""><br><a href="/gitchat/categories/591f073981be962a981acf18/12">安全</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/Fjz0BDR-Wh44YkTpn0nnZj7jqyyz" alt=""><br><a href="/gitchat/categories/5901bd477b61a76bc4016423/13">运维</a><br>Chat 是什么？ <a href="/books/5b398139328f856827673b50/index.html">了解更多</a><br>Chat 是一种全新的阅读/写作互动体验产品。一场 Chat 包含一篇文章和一场为该文章的读者和作者准备的专属线上交流。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FugaAUCJPglWvm7ZO6Vldhc6Iq6h" alt=""></p>
<p>关注 GitChat 微信公众号</p>
<ul>
<li>获得 Chat 邀请</li>
<li>与作者实时互动</li>
<li>限时特惠不错过</li>
</ul>
<p><a href="/new/gitchat/activity">创建一场 Chat</a> <a href="/application/column">成为达人课作者</a> <a href="http://gitbook.cn/books/5ad965d38ba0ed4ba9410f27/index.html">加入我们</a> | <a href="/books/5b398139328f856827673b50/index.html">常见问题</a> | <a href="#contactUsModal">联系客服</a></p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FjUg5IGe5ThyN4F3BgPwVLtNUH6z?imageView2/1/h/500" alt=""><br>Chat<br>免费订</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/Frl6G1w68QeqEpWzShYkZkF0ehqs?imageView2/1/h/500" alt=""><br>课程<br>随心学</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/Fiyy0OVXYs6dh8eIcTFz0eC_PZeG?imageView2/1/h/500" alt=""><br>好书<br>每月领</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FtpKeUnInA1OgvIFtJjDKmOBO30g?imageView2/1/h/500" alt=""><br>专家<br>畅快聊</p>
<p>成为会员</p>
<p>热门分类</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FjgoMiaOzWmUU3JgdX3qvkBGGQ91" alt=""><br><a href="/gitchat/categories/58e84f875295227534aad506/1">前端</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FuPwXhHD3AxVmjsNdsmwGMK2Snxm" alt=""><br><a href="/gitchat/categories/58e84f53ec8e9e7b34457809/2">人工智能</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FmfNJDcE5rxC2X8GjgH8cfc8sFdW" alt=""><br><a href="/gitchat/categories/58e84f6bad952d6b3428af9a/3">架构</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/Fikw2zHy2kEE5fDxXgnH6aznmCEw" alt=""><br><a href="/gitchat/categories/5953698a3d38293ecceacb89/4">区块链</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FkEA14MZoO2nVDHiO2hRZcNASz14" alt=""><br><a href="/gitchat/categories/58e84f1584c651693437f27c/5">职场</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FidoaTbc4rvNKqFISPUs_0_NC1Xd" alt=""><br><a href="/gitchat/categories/59c491948fee063dc3c447ab/6">编程语言</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FuMNvLb25yJ4RiEg_2OnS8jpI8aB" alt=""><br><a href="/gitchat/categories/58e84f31ad952d6b3428af99/7">技术管理</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FsAwwVyxgMp5jrw3V1OzBAFRlZXd" alt=""><br><a href="/gitchat/categories/58e84f7bec8e9e7b3445780d/8">大数据</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FvClrIKCKLu4pj4tys0BMpr3IEy_" alt=""><br><a href="/gitchat/categories/591171a3e692d5280d8157b6/9">移动开发</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FhpGxdtnPjzRslCSUnNKdBXdjGLQ" alt=""><br><a href="/gitchat/categories/58e84f2284c651693437f27d/10">产品与运营</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FiDhwLN1jdKDRmYqdySCaKcw-1R3" alt=""><br><a href="/gitchat/categories/58e84f425295227534aad502/11">测试</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FrRYtPEGuW_ZbSEIUIQRHOPlzVPc" alt=""><br><a href="/gitchat/categories/591f073981be962a981acf18/12">安全</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/Fjz0BDR-Wh44YkTpn0nnZj7jqyyz" alt=""><br><a href="/gitchat/categories/5901bd477b61a76bc4016423/13">运维</a></p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/logo.png" alt=""></p>
<p>微信扫描登录</p>
<p>×</p>
<h4 id="帐号设置"><a href="#帐号设置" class="headerlink" title="帐号设置"></a>帐号设置</h4><p>头像<br><a href="javascript:;">选择头像</a></p>
<p>最佳分辨率：200*200像素</p>
<p>昵 称:</p>
<p>微信号:</p>
<p>头 衔:</p>
<p>背景介绍:</p>
<p>正在上传头像，请稍等……<br>正在更新，请稍等……<br>邮件地址格式不正确，请重新填写<br>此邮件地址已经被其他用户使用</p>
<p>取消保存</p>
<p>×Java 开发必备面试题详解（技术+人事）</p>
<p>请写下您的意见：</p>
<p>提交</p>
<h4 id="提-示"><a href="#提-示" class="headerlink" title="提 示"></a>提 示</h4><p>购买Chat后即可去读者圈向作者提问！</p>
<p>去购买</p>
<p><a href="https://gitbook.cn/books/5bf63a0e00fee84c8f6ad257/index.html"></a></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-02T06:48:51.081Z">2019-08-02</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    6 minutes read (About 845 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/02/10%E9%81%93%E8%85%BE%E8%AE%AF%E7%9A%84Java%E9%9D%A2%E8%AF%95%E9%A2%98/">10道腾讯的Java面试题</a>
            
        </h1>
        <div class="content">
            <h1 id="10道腾讯的Java面试题"><a href="#10道腾讯的Java面试题" class="headerlink" title="10道腾讯的Java面试题"></a>10道腾讯的Java面试题</h1><p>下面总结10道面试腾讯的Java面试题。<br>1、说几种常见的攻击方式及预防手段。<br>    - XSS/CSRF/DDOS具体参考之前的文章。 </p>
<p>2、http1.x和http2.x的区别。<br>    - http2.0增加多路复用、二进制分帧、首部压缩、服务器推送。 </p>
<p>3、mysql查询语句怎么做性能分析。<br>    - 使用explain或者profile命令，具体参考之前的文章。 </p>
<p>4、你知道哪几种排序算法？<br>    - 冒泡、选择、插入、希尔、快速、堆、归并、桶排序。 </p>
<p>5、HashMap和HashTable的区别，并说明其底层实现数据结构。<br>    - HashMap非线程安全，HashTable线程安全，具体参考之间的文章。</p>
<p>6、HashMap满了之后怎么扩容？<br>    - loadfactor为扩容因子，当数据容量超过最大容量*loadfactor时容量自动扩大2倍，并将当前的数据重新放入新的hashmap中，所以初始的定义大小为2^n的大小最佳。</p>
<p>7、Linux中远程传输文件有什么方式？<br>    - SCP、FTP等。 </p>
<p>8、说说Java中异常的分类。<br>    - Throwable子类Exception、Error。 </p>
<p>9、TCP和UDP的区别，TCP为什么是三次握手，不是两次。<br>    - 1.基于连接与无连接 2.TCP要求系统资源较多，UDP较少。 3.UDP程序结构较简单。 4.流模式（TCP）与数据报模式(UDP)。 5.TCP保证数据正确性，UDP可能丢包。 6.TCP保证数据顺序，UDP不保证。 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误，即重要的事情说三遍</p>
<p>10、说说数据库设计的三范式，可以违反三范式吗？<br>    - 第一范式，又称1NF，它指的是在一个应用中的数据都可以组织成由行和列的表格形式，且表格的任意一个行列交叉点即单元格，都不可再划分为行和列的形式，实际上任意一张表格都满足1NF； 第二范式，又称2NF，它指的是在满足1NF的基础上，一张数据表中的任何非主键字段都全部依赖于主键字段，没有任何非主键字段只依赖于主键字段的一部分。即，可以由主键字段来唯一的确定一条记录。比如学号+课程号的联合主键，可以唯一的确定某个成绩是哪个学员的哪门课的成绩，缺少学号或者缺少课程号，都不能确定成绩的意义。 第三范式，又称3NF，它是指在满足2NF的基础上，数据表的任何非主键字段之间都不产生函数依赖，即非主键字段之间没有依赖关系，全部只依赖于主键字段。例如将学员姓名和所属班级名称放在同一张表中是不科学的，因为学员依赖于班级，可将学员信息和班级信息单独存放，以满足3NF。 某些业务设计可以违反三范式。</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-02T06:48:51.081Z">2019-08-02</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    2 minutes read (About 359 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/02/2017%E6%B4%BE%E5%8D%A7%E5%BA%95%E5%8E%BB%E9%98%BF%E9%87%8C%E3%80%81%E4%BA%AC%E4%B8%9C%E3%80%81%E7%BE%8E%E5%9B%A2%E3%80%81%E6%BB%B4%E6%BB%B4%E5%B8%A6%E5%9B%9E%E6%9D%A5%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/">2017派卧底去阿里、京东、美团、滴滴带回来的面试题及答案</a>
            
        </h1>
        <div class="content">
            <h1 id="2017派卧底去阿里、京东、美团、滴滴带回来的面试题及答案"><a href="#2017派卧底去阿里、京东、美团、滴滴带回来的面试题及答案" class="headerlink" title="2017派卧底去阿里、京东、美团、滴滴带回来的面试题及答案"></a>2017派卧底去阿里、京东、美团、滴滴带回来的面试题及答案</h1><p>最近有很多朋友去目前主流的大型互联网公司面试（阿里巴巴、京东、美团、滴滴），面试回来之后会发给我一些面试题。有些朋友轻松过关，拿到offer，但是有一些是来询问我答案的。</p>
<p>我特意整理了一下，有很多问题不是靠几句话能讲清楚，所以干脆找朋友录制了一些视频，用来回来这些面试题。很多问题其实答案很简单，但是背后的思考和逻辑不简单，要做到知其然还要知其所以然。</p>
<p>先来看下用手机记录的面试材料：</p>
<p><strong>一，阿里巴巴面试题</strong></p>
<p><strong>二，京东面试题</strong></p>
<p><strong>三，美团面试题</strong></p>
<p><strong>四，滴滴面试题</strong></p>
<p><strong>五，本次卧底面试得到的结论</strong></p>
<p>通过面试题来看，可以看出目前互联网公司面试考点为：</p>
<p>1.性能调优、算法数据机构</p>
<p>2.高并发下数据安全、接口冪等性、原子性等</p>
<p>3.分布式下协同、已经锁的处理</p>
<p>4.数据库的分库分表、项目之间的垂直拆分</p>
<p>出现频率高的技术点有：</p>
<p>1.HashMap</p>
<p>2.JVM</p>
<p>3.Dubbo</p>
<p>4.Mybatis</p>
<p>5.Zookeeper</p>
<p>6.http tcp/ip</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-02T06:48:51.079Z">2019-08-02</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    7 minutes read (About 1076 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/02/%E9%AB%98%E5%AD%A6%E5%8E%86%E5%AE%B6%E9%95%BF%E5%92%8C%E4%BD%8E%E5%AD%A6%E5%8E%86%E5%AE%B6%E9%95%BF%E5%9C%A8%E6%95%99%E8%82%B2%E5%AD%A9%E5%AD%90%E6%96%B9%E9%9D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B7%AE%E5%88%AB%EF%BC%9F/">高学历家长和低学历家长在教育孩子方面有哪些差别？</a>
            
        </h1>
        <div class="content">
            <h1 id="高学历家长和低学历家长在教育孩子方面有哪些差别？"><a href="#高学历家长和低学历家长在教育孩子方面有哪些差别？" class="headerlink" title="高学历家长和低学历家长在教育孩子方面有哪些差别？"></a>高学历家长和低学历家长在教育孩子方面有哪些差别？</h1><p>提供些数据支持。Pew Research Center 在2015年对近2000名美国学龄儿童家长进了调查。调查发现：高学历父母对子女教育的参与度更高。他们注意培养子女的兴趣爱好（如：芭蕾、足球等），投入大量时间教孩子阅读，并更关心孩子的心理健康。同时，他们采取更温和的教育方式，较少体罚孩子。</p>
<p>特别需要注意的是，高学历家长往往同时收入水平较高，其中白人家庭、双亲家庭比例更大。所以这些数据同时也反映了家庭资源和教育观念的差异，不要过分解读。</p>
<p>以下是具体调查结果。</p>
<p><strong>体罚行为</strong></p>
<p>在接受调查的高学历（研究生以上）家庭中，只有8%偶尔或有时体罚孩子，低学历（高中或以下），22%偶尔或有时体罚孩子。</p>
<p><img src="%E9%AB%98%E5%AD%A6%E5%8E%86%E5%AE%B6%E9%95%BF%E5%92%8C%E4%BD%8E%E5%AD%A6%E5%8E%86%E5%AE%B6%E9%95%BF%E5%9C%A8%E6%95%99%E8%82%B2%E5%AD%A9%E5%AD%90%E6%96%B9%E9%9D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B7%AE%E5%88%AB%EF%BC%9F/v2-f4fabf3e3149e0205c565a0856e72637_b.png" alt=""></p>
<p><strong>课外活动</strong></p>
<p>调查发现，在过去12个月里，高收入家庭（家庭年收入75000美元以上）中，84%孩子曾参加集体体育项目，64%参与志愿公益活动，62%曾接受音乐、舞蹈或艺术方面的培训。低收入（家庭年薪低于30000美元）家庭中，以上三项数据分别是59%， 37%，41%。</p>
<p><img src="%E9%AB%98%E5%AD%A6%E5%8E%86%E5%AE%B6%E9%95%BF%E5%92%8C%E4%BD%8E%E5%AD%A6%E5%8E%86%E5%AE%B6%E9%95%BF%E5%9C%A8%E6%95%99%E8%82%B2%E5%AD%A9%E5%AD%90%E6%96%B9%E9%9D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B7%AE%E5%88%AB%EF%BC%9F/v2-617a42805af71ecf7bba216e30bcdb24_b.png" alt=""></p>
<p><strong>教育焦虑</strong></p>
<p>白人家长最关注的孩子的焦虑、抑郁情绪（58% v.s 35%），而黑人家长最担心的是孩子的人身安全问题（校园暴力、枪支）（39% v.s 22%）。</p>
<p><img src="%E9%AB%98%E5%AD%A6%E5%8E%86%E5%AE%B6%E9%95%BF%E5%92%8C%E4%BD%8E%E5%AD%A6%E5%8E%86%E5%AE%B6%E9%95%BF%E5%9C%A8%E6%95%99%E8%82%B2%E5%AD%A9%E5%AD%90%E6%96%B9%E9%9D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B7%AE%E5%88%AB%EF%BC%9F/v2-e18bcd3a1a5e5ee1d5429bb379c91bfe_b.png" alt=""></p>
<p><strong>对邻里环境的评价</strong></p>
<p>高收入家庭（家庭年收入75000美元以上）中，78%被访家长认为他们的邻里环境非常适宜孩子成长，而低收入家庭（家庭年收入30000美元以下）中，该数据只有42%。</p>
<p><img src="%E9%AB%98%E5%AD%A6%E5%8E%86%E5%AE%B6%E9%95%BF%E5%92%8C%E4%BD%8E%E5%AD%A6%E5%8E%86%E5%AE%B6%E9%95%BF%E5%9C%A8%E6%95%99%E8%82%B2%E5%AD%A9%E5%AD%90%E6%96%B9%E9%9D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B7%AE%E5%88%AB%EF%BC%9F/v2-055bc69033abd35f3df89dcaaf124f86_b.png" alt=""></p>
<p><strong>更新：</strong> 针对评论/私信中提到的问题一并回复如下</p>
<p><strong>“为什么不控制父母收入这个变量呢？”</strong></p>
<p>简单来讲，我们要考察x变量（父母教育程度）对y变量（教育子女方式）的影响， <strong>而相对x变量，z变量（父母收入）是个内生变量，因而无法从根本上加以控制。</strong> 在这种情况下，我们解读“x对y的影响”时，应该明确这种影响包含x通过z对y的间接影响，即，x不是孤立于z存在的。</p>
<p>至于为什么控制内生变量是不可取的，感兴趣的读者可参考Angrist &amp; Pischke 的书 Mostly Harmless Econometrics中的相关分析，因涉及一些计量方法上的技术细节，这里不做赘述。</p>
<p>图片/数据来源： “Parenting in America: Outlook, worries, aspirations are strongly linked to financial situation” (Pew Research Center, 2015).</p>
<p><a href="https://www.zhihu.com/question/20800942/answer/188815415">高学历家长和低学历家长在教育孩子方面有哪些差别？</a></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-02T06:48:51.079Z">2019-08-02</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    22 minutes read (About 3231 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/02/%E9%80%82%E5%90%88%E5%88%9B%E4%B8%9A%E5%9B%A2%E9%98%9F%E7%9A%84%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%E6%A0%88/">适合创业团队的必备工具栈</a>
            
        </h1>
        <div class="content">
            <h1 id="适合创业团队的必备工具栈"><a href="#适合创业团队的必备工具栈" class="headerlink" title="适合创业团队的必备工具栈"></a>适合创业团队的必备工具栈</h1><blockquote>
<p>Ariel Diaz，Blissfully 的创始人兼 CEO，连续创业者。Blissfully 致力于为企业提供最优的 SaaS 解决方案，以及 IT 外包服务。本文由魏佳翻译。  </p>
</blockquote>
<p>创业公司是为了解决具体问题而建立的。所以我们应当把全部精力完全放在“如何去解决这个具体问题”上。</p>
<p>选择合适的软件或工具也是如此，如今各种优秀工具层出不穷，但重要的是如何快速得选择一些会让你事半功倍的软件或工具。</p>
<p>通过过去十年中创立多家公司的过程，我对于如何挑选“正确的”工具积累了很多的经验，本文是我对于这些工具的分享。</p>
<h2 id="关键因素"><a href="#关键因素" class="headerlink" title="关键因素"></a><em>关键因素</em></h2><p>任何人在着手考虑软件或工具的选型时应当首先明确的第一个问题是：你到底希望解决或改进什么？这里面需要做出很多取舍和权衡，比如成本与功能，安全与速度，易用性以及集成能力。</p>
<ul>
<li><p>成本 - 早期不要增加支出的负担。</p>
</li>
<li><p>速度 - 快速得配置和用起来，这样才能更专注业务本身的发展。</p>
</li>
<li><p>易用 - 没人希望在软件或工具本身的设置、部署或管理上花费时间和精力。</p>
</li>
<li><p>灵活 - 不用担心被绑定在某种工具上。</p>
</li>
<li><p>整合 - 各种工具之间应能集成起来。</p>
</li>
<li><p>生产力 - 最重要的，应能显著提高效率及生产力。</p>
</li>
</ul>
<p>以下的内容就是围绕上述 6 点。</p>
<h2 id="适合初创期的基础工具栈"><a href="#适合初创期的基础工具栈" class="headerlink" title="适合初创期的基础工具栈"></a><em>适合初创期的基础工具栈</em></h2><p>在组织刚建立初期，一切事情都需要快速且低成本得跑起来。<br><img src="%E9%80%82%E5%90%88%E5%88%9B%E4%B8%9A%E5%9B%A2%E9%98%9F%E7%9A%84%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%E6%A0%88/08827975-0F4F-42A8-8ADF-7321159CDD5D.png" alt=""></p>
<ul>
<li><p>Google 套件：基本套餐每月每用户 $5（美元，下同）。这包括了电子邮件，文件共享，办公套件，简单的身份认证等功能。这基本覆盖了创业公司早期阶段的基本问题，如果您需要更强大丰富的功能，它也提供其他套餐。</p>
</li>
<li><p>Quickbooks Online：大约每月 $40。Quickbooks Online 为财务或会计角色提供了非常的棒的管理公司营收、开支等账务相关功能，而且价格低廉，非常易于使用。它与 Gusto 和其他许多工具都能无缝集成，同时它拥有非常活跃的开发者生态。 相比更专业全面的商业软件或解决方案，Quickbooks 是更灵活，更低成本的最佳选择。</p>
</li>
<li><p>Gusto：每 6 用户 $39。当需要向员工或外部承包商支付工资或酬劳时，就需要工资单。Gusto 就是这样的平台和工具，不仅如此，Gusto 上可以管理各种员工薪酬和福利，还能将完整的工资单数据同步到 Quickbook 中去，能自动缴纳州和联邦税费等。Gusto 还提供一整套基本且常用的公司信函模版，比如录用信，商业合同，律师函等。</p>
</li>
<li><p>Hubspot CRM：为了寻找完美的 CRM 系统，你可能需要花费非常多的时间。Salesforce 非常棒，同时差不多是行业标准了，但它是非常昂贵，最少需要签约 1 年。这就是为什么我们推荐 Hubspot CRM。首先它是免费的，易于使用，同时可以通过 Zaiper 去集成其他系统以实现自动化。</p>
</li>
</ul>
<h2 id="团队协作工具栈"><a href="#团队协作工具栈" class="headerlink" title="团队协作工具栈"></a><em>团队协作工具栈</em></h2><p>尽管 G Suite 中提供了团队协作的相关产品，但在这一领域，还有其他很多优秀的产品（比如以下推荐的三个产品），它们的免费套餐就提供了更加强大的功能，同时可以非常快速容易得上手。</p>
<ul>
<li><p><em>Slack：基本是目前团队通讯平台的标杆产品。</em> 免费套餐就能满足初创期团队的使用需求，同时具备非常强大的插件扩展及第三方集成的能力。</p>
</li>
<li><p><em>Zoom</em> ：如果团队有视频或屏幕共享的需求，可以试试 Zoom。几乎没有任何限制的免费套餐，高素质的音／视频质量，广泛的跨平台支持等等。</p>
</li>
<li><p><em>Trello：提供可视化的、灵活的方式来组织管理项目和任务</em> ，既可以用来管理市场营销计划，也可以管理软件项目开发。对于初创团队来说，免费套餐就足够强大去组织和管理一个复杂的工作流程。</p>
</li>
</ul>
<h2 id="适合软件初创公司的工具栈"><a href="#适合软件初创公司的工具栈" class="headerlink" title="适合软件初创公司的工具栈"></a><em>适合软件初创公司的工具栈</em></h2><p>如果你们团队正在打造软件产品，那就需要一套工具来帮助进行构建，测试，迭代等。下面这些工具在满足上文的六个属性之外，还具备其他强大的功能。<br><img src="%E9%80%82%E5%90%88%E5%88%9B%E4%B8%9A%E5%9B%A2%E9%98%9F%E7%9A%84%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%E6%A0%88/E6E16069-99E6-48B2-BB8D-3DB12BD4B286.png" alt=""></p>
<h2 id="产品-工程方面"><a href="#产品-工程方面" class="headerlink" title="产品+工程方面"></a><em>产品+工程方面</em></h2><ul>
<li><p><em>设计：</em> Sketch + InvisionApp，Sketch 近些年快速成为业界标准的设计工具，它具备非常强大的矢量/位图混合模型，同时相对实惠的价格（$100 的单独许可，加上可选的每年 $69 的版本升级）。它还能和 InVision 等工具集成，帮助你更方便的协作和分享设计原型。</p>
</li>
<li><p><em>统计分析：</em> ：Mixpanel + Google Analytics + Segment，通常产品发布前，就需要建立和数据收集统计和分析的基础设施。即使还没有多少数据需要来“分析”，建立基准也是有必要的。Google Analytics 是衡量网站流量和记录用户行为／事件的事实标准，但是除非设计并自定义了大量行为／事件，否则 Google Analytics 除了做简单得记录、统计和展示，并不能提供其他“有价值的洞察数据”。为了更深入地分析产品数据，Mixpanel 是个非常棒的选择，它内置了大量开箱即用的标准的工具。此外，Segment 能提供一种 single multiplexers，怎么理解呢，就是你可以编写一次用于 tracking 的代码，然后它能非常容易得自动与其他分析工具集成。</p>
</li>
<li><p><em>编码：</em> GitHub，无须多言，代码管理事实标准。</p>
</li>
<li><p><em>托管：</em> AWS，提供大量开箱即用的 PaaS 产品，再加上相对实惠的价格。</p>
</li>
<li><p><em>支付：</em> Stripe，易于集成，易于管理，同时功能强大。</p>
</li>
</ul>
<h2 id="产品支持方面"><a href="#产品支持方面" class="headerlink" title="产品支持方面"></a><em>产品支持方面</em></h2><ul>
<li>产品／用户支持：Intercom，通常产品早期你并不需要一个全面的反馈及派单（feedback&amp;ticketing）系统来应对客户反馈及产品缺陷。Intercom 可以非常轻松地集成到网站或移动应用中，从而快速作出响应。</li>
</ul>
<h2 id="运营支撑方面"><a href="#运营支撑方面" class="headerlink" title="运营支撑方面"></a><em>运营支撑方面</em></h2><ul>
<li><p>EShares：通常创业公司会向员工发行期权。但自己管理这件事十分繁琐和棘手，甚至可能引起法律层面的纠纷或麻烦。试试 EShares 吧，轻松管理期权授予和整个期权池规模，也能管理融资或财务相关的文书，先不要担心它的价格，长期来看是很合算和值得的。</p>
</li>
<li><p>Bill.com：如它的名字一样，它能帮你解决支票／发票等各种票据的所有事宜。把 PDF 形式的发票邮件转发给它，它会自动解析保存，并生成可快速付款的支付链接，一切就是这么简单。基本套餐 $39，帮你节省处理各种票据的时间，十分值得。</p>
</li>
<li><p>Zapier：Zapier 支持超过 750 种产品或平台的集成和自动化。它能帮你节约大量的时间，同时省去了直接与各种各样的系统和平台打交道，之后你也可以快速的切换。</p>
</li>
</ul>
<h2 id="适合成熟的创业公司：审计与合规"><a href="#适合成熟的创业公司：审计与合规" class="headerlink" title="适合成熟的创业公司：审计与合规"></a><em>适合成熟的创业公司：审计与合规</em></h2><p>SOC2 审计对于 SaaS 公司越来越普遍。相比自己动手来做一个，不如采用一些现成的解决方案，尽可能的节约时间，帮助你更专注于产品和业务，更迅速的迭代。<br><img src="%E9%80%82%E5%90%88%E5%88%9B%E4%B8%9A%E5%9B%A2%E9%98%9F%E7%9A%84%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%E6%A0%88/BF8ED753-0E36-4130-8259-F8C41AE19D36.png" alt=""></p>
<ul>
<li><p><em>应用安全和单点登录：Okta</em> ，首先 Okta 不是简单的密码管理器，它是一个身份和认证／鉴权管理器。将公司内各种应用、工具、平台的安全认证集中到一起，除此之外，还能记录和管理登录频率，登录位置等各种报告，所以它对于安全审计非常有用。Okta 是目前这类产品的领导者，对流行和成熟的各类产品可以一键集成。</p>
</li>
<li><p><em>MDM</em> ：G Suite MDM，假设你已经在使用 G Suite，那么直接使用内置的 MDM 方便且免费。对于各类移动设备的访问控制都变得十分容易，通过简单的安装和注册，所有员工在手机上访问公司电子邮件和数据都可以得到管理和控制。如果设备丢失，MDM 也可帮助你最大程度地保护公司敏感数据的泄漏。</p>
</li>
<li><p><em>计算机资产与策略管理</em> ：JAMF，JAMF 提供 2 层产品，最基本的套餐只需要每设备每月 $2。你可以对所有的 MacBook 等资产进行集中管理和跟踪，包括密码保护，硬盘加密等关键安全策略。需要注意的是，JAMF 只是针对 Mac 产品系列，一般来说对于科技创业公司，Mac 产品更强大，更易于维护，所以最好的办法是尽早将计算机资产统一为 Mac 产品。</p>
</li>
<li><p><em>HRIS</em> ：BambooHR，人力资源信息系统（HRIS）以前通常被认为是大型企业才需要的，但越来越多的轻量级、体验友好，同时便宜实惠的 HRIS 产品可以帮助中小企业更好得管理人员。可以跟踪员工入职，文书审批，政策通知和其他人力资源流程。BambooHR 是非常好的选择，价格相对便宜，易于与其他系统集成，内置大量标准功能，包括应聘者跟踪，入职清单，文件签名等。</p>
</li>
<li><p><em>文档：Quip</em> ，安全性和合规性的关键之一是将内部流程文档化。因此，需要易于创建，编辑，共享和索引。Quip 是这类产品的优秀代表，比使用 Google 文档（过于简单）或 Google Sites / Wikis（体验不够简单直观）更好。</p>
</li>
</ul>
<h2 id="Blissfully-能帮助你什么"><a href="#Blissfully-能帮助你什么" class="headerlink" title="Blissfully 能帮助你什么"></a><em>Blissfully 能帮助你什么</em></h2><p>如果你想跟踪已在使用的各种 SaaS 工具的使用状况，优化支出，提高安全性；或是了解其他初创公司使用了哪些 SaaS 产品，来 Blissfully 看看吧。</p>
<p><em>参考链接</em></p>
<ul>
<li><p>G Suite <a href="https://gsuite.google.com/">https://gsuite.google.com/</a></p>
</li>
<li><p>Quickbooks <a href="https://quickbooks.intuit.com/">https://quickbooks.intuit.com/</a></p>
</li>
<li><p>Gusto <a href="https://gusto.com/">https://gusto.com/</a></p>
</li>
<li><p>HubSpot CRM <a href="http://www.hubspot.com/CRM">www.hubspot.com/CRM</a></p>
</li>
<li><p>Slack <a href="https://slack.com/">https://slack.com/</a></p>
</li>
<li><p>Zoom <a href="https://zoom.us/">https://zoom.us/</a></p>
</li>
<li><p>Trello <a href="https://trello.com/">https://trello.com/</a></p>
</li>
<li><p>Sketch <a href="https://www.sketchapp.com/">https://www.sketchapp.com/</a></p>
</li>
<li><p>InVision <a href="https://www.invisionapp.com/">https://www.invisionapp.com/</a></p>
</li>
<li><p>Mixpanel <a href="https://mixpanel.com/">https://mixpanel.com/</a></p>
</li>
<li><p>Segment <a href="https://segment.com/">https://segment.com/</a></p>
</li>
<li><p>Stripe <a href="https://stripe.com/">https://stripe.com/</a></p>
</li>
<li><p>Intercom <a href="https://www.intercom.com">https://www.intercom.com</a></p>
</li>
<li><p>EShare <a href="https://eshare.co.uk/">https://eshare.co.uk/</a></p>
</li>
<li><p>Bill.com <a href="https://www.bill.com/">https://www.bill.com/</a></p>
</li>
<li><p>Zapier <a href="https://zapier.com/">https://zapier.com/</a></p>
</li>
<li><p>Okta <a href="https://www.okta.com/">https://www.okta.com/</a></p>
</li>
<li><p>MDM <a href="https://en.wikipedia.org/wiki/Mobile_device_management">https://en.wikipedia.org/wiki/Mobile_device_management</a></p>
</li>
<li><p>JAMF <a href="https://www.jamf.com/">https://www.jamf.com/</a></p>
</li>
<li><p>BambooHR <a href="https://www.bamboohr.com/">https://www.bamboohr.com/</a></p>
</li>
<li><p>Quip <a href="https://quip.com/">https://quip.com/</a></p>
</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=2653548870&idx=1&sn=9dab4a1f06e57adb2ac0393bac479c0c&chksm=813a60deb64de9c833b7e871b8c50148bb481f7b438c51f254e94faf44d3ad86be5d0b958128&scene=0&key=41aba78a08e0c639e242c69aea837b62638334481a6f1b3e6c87881ab75280bd59018728596c61ace0d5e45c6efe10b630b5bee760f8d97ec46ae398db84193fadff1c40450685da610a15e8f67bfe33&ascene=0&uin=ODAzMDQyMjU%3D&devicetype=iMac+MacBookPro10%2C2+OSX+OSX+10.12.4+build(16E195)&version=12020810&nettype=WIFI&fontScale=100&pass_ticket=dTxldytHdhcQaY1TnQtwuE8G7NACsZdhs6UvSRJ9XE4%3D">适合创业团队的必备工具栈</a></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-02T06:48:51.079Z">2019-08-02</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    23 minutes read (About 3477 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/02/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/">阿里巴巴1582.73亿背后的持续交付如何玩</a>
            
        </h1>
        <div class="content">
            <h1 id="阿里巴巴1582-73亿背后的持续交付如何玩"><a href="#阿里巴巴1582-73亿背后的持续交付如何玩" class="headerlink" title="阿里巴巴1582.73亿背后的持续交付如何玩"></a>阿里巴巴1582.73亿背后的持续交付如何玩</h1><p><img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/39A40B2B-5FB5-4C30-8E15-EA93553A153D.png" alt=""><br>摘要： 北京时间2017年5月18日晚，阿里巴巴集团公布2017财年第四季度财报及2017财年全年业绩。财年第四季度，阿里巴巴集团收入同比增长60％，达到385.79亿元人民币；全年阿里巴巴集团收入为 <em>1582.73</em> 亿元人民币，同比增长56％。中国零售平台年度活跃买家增至4.54亿，移动端月度活跃用户高达5.07亿</p>
<p>在2017在线技术峰会——首届阿里巴巴研发效能嘉年华上，来自阿里研发效能事业部技术专家崔力强分享了《阿里巴巴1582.73亿背后的持续交付如何玩》。他详细介绍了阿里巴巴的企业级持续交付，从研发参与者的各个角色解析阿里持续交付的流程和环节，并对RDC的理念进行了解析。<br><img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/FBA1A6EE-4413-4DBC-8F65-F6BD2B5456CD.png" alt=""><br>以下内容根据直播视频整理而成。</p>
<p>直播视频：<a href="https://yq.aliyun.com/edu/lesson/547">https://yq.aliyun.com/edu/lesson/547</a></p>
<p>PDF下载：<a href="https://yq.aliyun.com/attachment/download/?id=1840">https://yq.aliyun.com/attachment/download/?id=1840</a></p>
<h2 id="持续交付的目标"><a href="#持续交付的目标" class="headerlink" title="持续交付的目标"></a>持续交付的目标</h2><p>新的业务需要新的应用来承载，所以我们希望能够快速上线新的应用。有了代码之后，希望其构建过程是标准的，不需要针对每个环境、应用再去调构建过程。</p>
<p>当应用上线之后，需要有新的功能来迭代，功能被提出来之后希望能够快速高效的完成，并且可以在各个环境中进行验证，最后可以一键发布到线上。</p>
<h2 id="阿里巴巴的企业级持续交付"><a href="#阿里巴巴的企业级持续交付" class="headerlink" title="阿里巴巴的企业级持续交付"></a>阿里巴巴的企业级持续交付</h2><p>最开始，阿里巴巴也是使用开源套件的，比如Jenkins，但是逐渐难以满足需求：不能满足如此大的规模，资源管理、持续交付在运维的过程中使用Jenkins很难串起来，使用开源套件难以和现有的系统有机结合。</p>
<p>所以，研发了自研平台，今年将这套体系推到阿里云上供阿里云的用户使用。RDC和内部平台的核心是一致的，不同的是内部平台有自己的机房，有自己的资源管理方式。但是上云之后，数据库、负载均衡等基础设施都会使用阿里云上的。</p>
<p>持续交付中有三种角色：开发人员，把需求实现，保证其可以交付上线；开发负责人，团队建设，保证团队在指定时间内完成高优先级的任务；运维人员，负责发布和运维。</p>
<h2 id="开发人员：日常开发feature"><a href="#开发人员：日常开发feature" class="headerlink" title="开发人员：日常开发feature"></a>开发人员：日常开发feature</h2><p><img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/4AFC18A0-28A8-4648-AF3D-725C0C8291F2.png" alt=""><br><img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/EB5043AC-8736-4959-A8C5-1A85AE1C13FE.png" alt=""><br>开发人员开发一个新的feature需要上图所示的工作。首先需要拉分支来开发新的功能，然后为分支配置持续集成，开发测试完成之后需要合入集成分支。<br>此时需要从主干分支拉取release分支出来，把需要合并的一个或者多个分支合并进入。解决冲突的过程中需要对集成分支上部署的版本进行测试，需要为新的分支创建集成分支的配置。</p>
<p>测试完成后使用集成分支进行发布到预发环境、线上。最后，再将其合并回主干。</p>
<p>实际上，开发人员需要花时间做的只有开发测试和在集成分支上测试，上图中除了这两个步骤，其他步骤都是可以自动化完成的。<br><img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/F79BA582-D16B-45B7-8554-7AC888E28928.png" alt=""><br>这样流程的好处是能够灵活掌握开发节奏。</p>
<p>分支模式不是真正的数据集成，因为一定要等到所有的东西都集成到一个分支之后才知道是不是可行。</p>
<p>即使在一个fetch分支上测试好也不代表集成分支上也能工作。</p>
<p>主干模式是指随时想做任何变动，则调用某个方法的所有地方都需要做一个改变，主干模式做这件事情比较简单，结果可以立即看出，而分支模式则需要集成之后才知道结果。</p>
<p>RDC提供了自由模式（一种主干模式）、分支模式、Git flow模式（所有的用户都在develop分支上开发，进入之前需要code review来实现）。<br><img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/7E2B2AC3-2593-4AEC-A377-2766B7BBDE9A.png" alt=""><br>自由模式和develop模式有几个环节：版本制作、日常、预发、灰度。日常和预发之间有一个按钮用于在制作好之后预发布。</p>
<h2 id="开发人员：可怕的发布"><a href="#开发人员：可怕的发布" class="headerlink" title="开发人员：可怕的发布"></a>开发人员：可怕的发布</h2><p><img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/6C758F12-6FB1-43C1-A891-F60068F7A48C.png" alt=""><br>首先，我们需要有充分的测试，包括单元测试、API测试、阶段检查。此外，发明了另外一种测试方法，截取线上的一部分流量进行存储，在预发环境进行回放，看结果是否一致。<br><img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/285154E6-6242-4F36-896F-8D63B6703B29.png" alt=""><br>人工的代码review更多涉及到代码架构，所以希望每次的代码提交都能经过代码review过程。灵活的发布工具也很重要，规模小的时候怎么发布都可以，但是当规模比较大时灵活发布很重要。发布方式目前支持分批发布，分布策略可以根据分组、机房来分。<br><img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/2C0FECB0-5536-4A88-A4CF-16772E4119E0.png" alt=""><br>发布一定要是可靠的，一定是可重复的，一个包发100次一定是同样的结果。如果发布之后发现线上有问题，则需要回滚代码，只需要把发了的部分进行回滚即可。回滚包括发布中回滚和发布后回滚。<br><img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/CF4C9ABC-68C6-4213-8DDB-B4D53D35D0D5.png" alt=""><br>所有的过程一定要减少人为的介入，让这些都自动化的发生，所以希望有一个流程和卡点，如果不满足此刻要求就不能继续往下走。<br><img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/9ED1380C-D719-4D46-A06E-3748F7AD0C45.png" alt=""><br>发布的问题总结来说：使用单元测试，功能测试，接口测试等多层保护；通过系统卡点的方式保证上述测试真的被执行，且真正有效；提供灵活，可靠的发布方案；提供灵活，可靠的回滚方案；使用和线上的环境进行测试（预发）。</p>
<h2 id="开发人员：定位问题"><a href="#开发人员：定位问题" class="headerlink" title="开发人员：定位问题"></a>开发人员：定位问题</h2><p><img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/A6AD9433-9AA1-43BF-BBF7-BE49B8A395A7.png" alt=""><br>定位问题花费的时间往往比编码还要多，问题可能出现在测试环境，也可能出现在线上。<br><img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/7B745472-B9D6-4E52-8093-55EE3DFC67C5.png" alt=""><br>线上版本和上次发布之间有哪些变化？这些都要考虑清楚才能进一步定位问题。<br><img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/FBB99CC6-1DEB-48F8-AF83-157E42AC3A02.png" alt=""><br>平台有统一的流程将这些问题记录下来：创建分支，提交集成区，提交发布。在这样整个标准的变更流程中，会把很多信息记录下来。<br>上图中的列表是一个发布的列表，包括发布内容、发布结果、操作人、版本详情等内容。所有信息都可以帮助追溯之前发生的事情，并且进行问题解决。</p>
<h2 id="运维人员：线上变更充满危险"><a href="#运维人员：线上变更充满危险" class="headerlink" title="运维人员：线上变更充满危险"></a>运维人员：线上变更充满危险</h2><p>最初的时候采用了脚本批量执行，后来使用了声明式的基线管理，但是还是难以避免线上的基线被人手工篡改，而且不能保证基线变更失败后如何处理。<br><img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/CA50821F-36F6-479F-96E1-AED17DBE52D2.png" alt=""><br>2016年开始，阿里使用Docker容器镜像，问题变得迎刃而解，因为每次部署的都是新的镜像，环境保证一模一样。Docker化基础设施是在阿里内部的，而RDC在阿里云上怎么办？我们会去对接阿里云上的基础设施、已有服务，使用其整个服务来对接前面RDC的研发。<br><img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/3ED660AB-EBB3-45CE-8A4A-A16656990D68.png" alt=""><br>RDC发源于阿里内部，扎根于阿里云，后面所有的生态建设都会围绕阿里云已有的生态来建设。</p>
<p>上图中，企业入驻RDC企业级研发协同平台后就可以享受整个阿里云的基础设施。EDAS也是阿里云正在做的事情，ECS、SLB等资源也可以通过RDC进行整合。<br><img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/F2675342-FA9E-48EB-9BFC-9AF0FF5BFF41.png" alt=""><br>RDC是一个SaaS产品，不是私有云产品。由于没有部署到机房里，所以它可能访问不到VPC里面的机器，但是有时却有这样的需求。有时需要做预发、API测试，这些需要在公网里进行，但是公网却没有访问权限。目前的一个可行方案是，可以通过代理享受更多的服务。<br><img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/361ADAE7-C99C-4564-81EC-842459867188.png" alt=""><br>上图中蓝色部分是已经发布上线的。构建和发布目前是基于关联ECS并且自定义脚本的方式来发布。EDAS和容器正在对接。<br><img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/0A34C370-8375-4499-94D4-EA365F599143.png" alt=""><br>这样，开发过程的角色会有一定的转变。企业的现状是，有开发会做本地、测试环境的编码和日常测试，有专门的测试在QA环境进行功能验证，有运维去专门管理staging环境和正式环境。</p>
<p>DevOps是开发自运维，运维人员做好了很好的平台，开发可以进行测试，可以从发布流水线收到反馈，自己去编写测试用例，做新应用的发布上线，做日常功能的开发、线上变更、扩容缩容、线上故障处理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>RDC的理念是自动化一切可以自动化的事情，提供尽量多的模式，有安全、灵活的发布流程，使用工具流程来保证开发团队按照最佳实践工作，对开发过程的数据提供足够的可追溯性，依托阿里云基础设施，助力企业的Devops。</p>
<p>（来源：云栖社区 <a href="https://yq.aliyun.com/articles/118713）">https://yq.aliyun.com/articles/118713）</a></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-02T06:48:51.079Z">2019-08-02</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    an hour read (About 6822 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/02/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%20%7C%20%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84TIME_WAIT%E5%92%8CCLOSE_WAIT/">高性能网络 | 你所不知道的TIME_WAIT和CLOSE_WAIT</a>
            
        </h1>
        <div class="content">
            <h1 id="高性能网络-你所不知道的TIME-WAIT和CLOSE-WAIT"><a href="#高性能网络-你所不知道的TIME-WAIT和CLOSE-WAIT" class="headerlink" title="高性能网络 | 你所不知道的TIME_WAIT和CLOSE_WAIT"></a>高性能网络 | 你所不知道的TIME_WAIT和CLOSE_WAIT</h1><blockquote>
<p>本文是我将最近两篇文章，重新整理成一篇，方便收藏。如果你已经阅读过前两篇，并且已经做了收藏，可以重新收藏本文即可。  </p>
</blockquote>
<blockquote>
<p>你有收藏和整理文章的习惯吗？好好利用Evernote或者印象笔记，不要吝啬那点年费，你值得购买，并养成收藏和整理的习惯！  </p>
</blockquote>
<p>本文源于大家在公众号里面的留言，既然很多人都搞不清楚TIME_WAIT和CLOSE_WAIT，那么小胖哥今天还是抽个时间，统一帮大家理理概念吧。</p>
<p><strong>你遇到过TIME_WAIT的问题吗？</strong></p>
<p>我相信很多都遇到过这个问题。一旦有用户在喊：网络变慢了。第一件事情就是，netstat -a | grep TIME_WAIT | wc -l 一下。哎呀妈呀，几千个TIME_WAIT.</p>
<p>然后，做的第一件事情就是：打开Google或者Bing，输入关键词：too many time wait。一定能找到解决方案，而排在最前面或者被很多人到处转载的解决方案一定是：</p>
<blockquote>
<p>打开 sysctl.conf 文件，修改以下几个参数：  </p>
</blockquote>
<ul>
<li>net.ipv4.tcp_tw_recycle = 1</li>
<li>net.ipv4.tcp_tw_reuse = 1</li>
<li>net.ipv4.tcp_timestamps = 1</li>
</ul>
<p>你也会被告知，开启tw_recylce和tw_reuse一定需要timestamps的支持，而且这些配置一般不建议开启，但是对解决TIME_WAIT很多的问题，有很好的用处。</p>
<p>接下来，你就直接修改了这几个参数，reload一下，发现，咦，没几分钟，TIME_WAIT的数量真的降低了，也没发现哪个用户说有问题，然后就没有然后了。</p>
<p>做到这一步，相信50%或者更高比例的开发就已经止步了。问题好像解决了，但是，要彻底理解并解决这个问题，可能就没这么简单，或者说，还有很长的路要走！</p>
<p><strong>什么是TIME-WAIT和CLOSE-WAIT?</strong></p>
<p>所谓，要解决问题，就要先理解问题。随便改两行代码，发现bug“没有了”，也不是bug真的没有了，只是隐藏在更深的地方，你没有发现，或者以你的知识水平，你无法发现而已。</p>
<p>大家知道，由于socket是全双工的工作模式，一个socket的关闭，是需要四次握手来完成的。</p>
<ul>
<li><p>主动关闭连接的一方，调用close()； <strong>协议层发送FIN包</strong></p>
</li>
<li><p><strong>被动关闭的一方收到FIN包后，协议层回复ACK</strong> ；然后 <strong>被动关闭的一方，进入CLOSE_WAIT状态，</strong> 主动关闭的一方等待对方关闭，则进入FIN_WAIT_2状态；此时，主动关闭的一方 等待 被动关闭一方的应用程序，调用close操作</p>
</li>
<li><p>被动关闭的一方在完成所有数据发送后，调用close()操作；此时， <strong>协议层发送FIN包给主动关闭的一方，等待对方的ACK，被动关闭的一方进入LAST_ACK状态</strong> ；</p>
</li>
<li><p><strong>主动关闭的一方收到FIN包，协议层回复ACK</strong> ；此时， <strong>主动关闭连接的一方，进入TIME_WAIT状态；而被动关闭的一方，进入CLOSED状态</strong></p>
</li>
<li><p>等待2MSL时间，主动关闭的一方，结束TIME_WAIT，进入CLOSED状态</p>
</li>
</ul>
<p>通过上面的一次socket关闭操作，你可以得出以下几点：</p>
<ol>
<li><p>主动关闭连接的一方 - 也就是主动调用socket的close操作的一方，最终会进入TIME_WAIT状态</p>
</li>
<li><p>被动关闭连接的一方，有一个中间状态，即CLOSE_WAIT，因为协议层在等待上层的应用程序，主动调用close操作后才主动关闭这条连接</p>
</li>
<li><p>TIME_WAIT会默认等待2MSL时间后，才最终进入CLOSED状态；</p>
</li>
<li><p>在一个连接没有进入CLOSED状态之前，这个连接是不能被重用的！</p>
</li>
</ol>
<p>所以，这里凭你的直觉，TIME_WAIT并不可怕（not really，后面讲），CLOSE_WAIT才可怕，因为CLOSE_WAIT很多，表示说要么是你的应用程序写的有问题，没有合适的关闭socket；要么是说，你的服务器CPU处理不过来（CPU太忙）或者你的应用程序一直睡眠到其它地方(锁，或者文件I/O等等)，你的应用程序获得不到合适的调度时间，造成你的程序没法真正的执行close操作。</p>
<p>这里又出现两个问题：</p>
<ol>
<li><p>上文提到的连接重用，那连接到底是个什么概念？</p>
</li>
<li><p>协议层为什么要设计一个TIME_WAIT状态？这个状态为什么默认等待2MSL时间才会进入CLOSED</p>
</li>
</ol>
<p>先解释清楚这两个问题，我们再来看，开头提到的几个网络配置究竟有什么用，以及TIME_WAIT的后遗症问题。</p>
<p><strong>Socket连接到底是个什么概念？</strong></p>
<p>大家经常提socket，那么，到底什么是一个socket？其实，socket就是一个 五元组，包括：</p>
<ol>
<li>源IP</li>
<li>源端口</li>
<li>目的IP</li>
<li>目的端口</li>
<li>类型：TCP or UDP</li>
</ol>
<p>这个五元组，即标识了一条可用的连接。注意，有很多人把一个socket定义成四元组，也就是 源IP:源端口 + 目的IP:目的端口，这个定义是不正确的。</p>
<p>例如，如果你的本地出口IP是180.172.35.150，那么你的浏览器在连接某一个Web服务器，例如百度的时候，这条socket连接的四元组可能就是：</p>
<blockquote>
<p>[180.172.35.150:45678, tcp, 180.97.33.108:80]  </p>
</blockquote>
<p>源IP为你的出口IP地址 180.172.35.150，源端口为随机端口 45678，目的IP为百度的某一个负载均衡服务器IP 180.97.33.108，端口为HTTP标准的80端口。</p>
<p>如果这个时候，你再开一个浏览器，访问百度，将会产生一条新的连接：</p>
<blockquote>
<p>[180.172.35.150:43678, tcp, 180.97.33.108:80]  </p>
</blockquote>
<p>这条新的连接的源端口为一个新的随机端口 43678。</p>
<p>如此来看，如果你的本机需要压测百度，那么，你最多可以创建多少个连接呢？我在文章《云思路 | 轻松构建千万级投票系统》里也稍微提过这个问题，没有阅读过本文的，可以发送“投票系统”阅读。</p>
<p><strong>第二个问题，TIME_WAIT有什么用？</strong></p>
<p>如果我们来做个类比的话，TIME_WAIT的出现，对应的是你的程序里的异常处理，它的出现，就是为了解决网络的丢包和网络不稳定所带来的其他问题： </p>
<p>第一，防止前一个连接【五元组，我们继续以 180.172.35.150:45678, tcp, 180.97.33.108:80 为例】上延迟的数据包或者丢失重传的数据包，被后面复用的连接【前一个连接关闭后，此时你再次访问百度，新的连接可能还是由180.172.35.150:45678, tcp, 180.97.33.108:80 这个五元组来表示，也就是源端口凑巧还是45678】错误的接收（异常：数据丢了，或者传输太慢了），参见下图：<br><img src="%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%20%7C%20%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84TIME_WAIT%E5%92%8CCLOSE_WAIT/5C34D31F-CEA8-4F80-B26E-D73537B836B7.png" alt=""></p>
<ul>
<li><p>SEQ=3的数据包丢失，重传第一次，没有得到ACK确认</p>
</li>
<li><p>如果没有TIME_WAIT，或者TIME_WAIT时间非常端，那么关闭的连接【180.172.35.150:45678, tcp, 180.97.33.108:80 的状态变为了CLOSED，源端口可被再次利用】，马上被重用【对180.97.33.108:80新建的连接，复用了之前的随机端口45678】，并连续发送SEQ=1,2 的数据包</p>
</li>
<li><p>此时，前面的连接上的SEQ=3的数据包再次重传，同时，seq的序号刚好也是3（这个很重要，不然，SEQ的序号对不上，就会RST掉），此时，前面一个连接上的数据被后面的一个连接错误的接收</p>
</li>
</ul>
<p>第二，确保连接方能在时间范围内，关闭自己的连接。其实，也是因为丢包造成的，参见下图：<br><img src="%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%20%7C%20%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84TIME_WAIT%E5%92%8CCLOSE_WAIT/9DA87743-E891-40D7-9E41-3DD2ED015ACA.png" alt=""></p>
<ul>
<li><p>主动关闭方关闭了连接，发送了FIN；</p>
</li>
<li><p>被动关闭方回复ACK同时也执行关闭动作，发送FIN包；此时，被动关闭的一方进入LAST_ACK状态</p>
</li>
<li><p>主动关闭的一方回去了ACK，主动关闭一方进入TIME_WAIT状态；</p>
</li>
<li><p>但是最后的ACK丢失，被动关闭的一方还继续停留在LAST_ACK状态</p>
</li>
<li><p>此时，如果没有TIME_WAIT的存在，或者说，停留在TIME_WAIT上的时间很短，则主动关闭的一方很快就进入了CLOSED状态，也即是说，如果此时新建一个连接，源随机端口如果被复用，在connect发送SYN包后，由于被动方仍认为这条连接【五元组】还在等待ACK，但是却收到了SYN，则被动方会回复RST</p>
</li>
<li><p>造成主动创建连接的一方，由于收到了RST，则连接无法成功</p>
</li>
</ul>
<p>所以，你看到了，TIME_WAIT的存在是很重要的，如果强制忽略TIME_WAIT，还是有很高的机率，造成数据粗乱，或者短暂性的连接失败。</p>
<p>那么，为什么说，TIME_WAIT状态会是持续2MSL（2倍的max segment lifetime）呢？这个时间可以通过修改内核参数调整吗？第一，这个2MSL，是RFC 793里定义的，参见RFC的截图标红的部分：<br><img src="%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%20%7C%20%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84TIME_WAIT%E5%92%8CCLOSE_WAIT/116A09E1-A9D6-453A-A62A-8F43EE181FD2.png" alt=""></p>
<p>这个定义，更多的是一种保障（IP数据包里的TTL，即数据最多存活的跳数，真正反应的才是数据在网络上的存活时间），确保最后丢失了ACK，被动关闭的一方再次重发FIN并等待回复的ACK，一来一去两个来回。内核里，写死了这个MSL的时间为：30秒（有读者提醒，RFC里建议的MSL其实是2分钟，但是很多实现都是30秒），所以TIME_WAIT的即为1分钟：</p>
<p>所以，再次回想一下前面的问题，如果一条连接，即使在四次握手关闭了，由于TIME_WAIT的存在，这个连接，在1分钟之内，也无法再次被复用，那么，如果你用一台机器做压测的客户端，你一分钟能发送多少并发连接请求？如果这台是一个负载均衡服务器，一台负载均衡服务器，一分钟可以有多少个连接同时访问后端的服务器呢？</p>
<p><strong>TIME_WAIT很多，可怕吗？</strong></p>
<p>如果你通过 ss -tan state time-wait | wc -l 发现，系统中有很多TIME_WAIT，很多人都会紧张。多少算多呢？几百几千？如果是这个量级，其实真的没必要紧张。第一，这个量级，因为TIME_WAIT所占用的内存很少很少；因为记录和寻找可用的local port所消耗的CPU也基本可以忽略。</p>
<p><strong>会占用内存吗？当然</strong> <strong>！</strong> 任何你可以看到的数据，内核里都需要有相关的数据结构来保存这个数据啊。一条Socket处于TIME_WAIT状态，它也是一条“存在”的socket，内核里也需要有保持它的数据：</p>
<ol>
<li><p>内核里有保存所有连接的一个hash table，这个hash table里面既包含TIME_WAIT状态的连接，也包含其他状态的连接。主要用于有新的数据到来的时候，从这个hash table里快速找到这条连接。不同的内核对这个hash table的大小设置不同，你可以通过dmesg命令去找到你的内核设置的大小：</p>
</li>
<li><p>还有一个hash table用来保存所有的bound ports，主要用于可以快速的找到一个可用的端口或者随机端口：</p>
</li>
</ol>
<p>由于内核需要保存这些数据，必然，会占用一定的内存。</p>
<p><strong>会消耗CPU吗？</strong> <strong>当然！</strong> 每次找到一个随机端口，还是需要遍历一遍bound ports的吧，这必然需要一些CPU时间。</p>
<p>TIME_WAIT很多，既占内存又消耗CPU，这也是为什么很多人，看到TIME_WAIT很多，就蠢蠢欲动的想去干掉他们。其实，如果你再进一步去研究，1万条TIME_WAIT的连接，也就多消耗1M左右的内存，对现代的很多服务器，已经不算什么了。至于CPU，能减少它当然更好，但是不至于因为1万多个hash item就担忧。<br>如果，你真的想去调优，还是需要搞清楚别人的调优建议，以及调优参数背后的意义！</p>
<p><strong>TIME_WAIT调优，你必须理解的几个调优参数</strong></p>
<p>在具体的图例之前，我们还是先解析一下相关的几个参数存在的意义。</p>
<p><strong>net.ipv4.tcp_timestamps</strong></p>
<blockquote>
<p>RFC 1323 在 TCP Reliability一节里，引入了timestamp的TCP option，两个4字节的时间戳字段，其中第一个4字节字段用来保存发送该数据包的时间，第二个4字节字段用来保存最近一次接收对方发送到数据的时间。有了这两个时间字段，也就有了后续优化的余地。  </p>
</blockquote>
<blockquote>
<p>tcp_tw_reuse 和 tcp_tw_recycle就依赖这些时间字段。<br><strong>net.ipv4.tcp_tw_reuse</strong></p>
</blockquote>
<blockquote>
<p>字面意思，reuse TIME_WAIT状态的连接。  </p>
</blockquote>
<blockquote>
<p>时刻记住一条socket连接，就是那个五元组，出现TIME_WAIT状态的连接，一定出现在主动关闭连接的一方。所以，当主动关闭连接的一方，再次向对方发起连接请求的时候（例如，客户端关闭连接，客户端再次连接服务端，此时可以复用了；负载均衡服务器，主动关闭后端的连接，当有新的HTTP请求，负载均衡服务器再次连接后端服务器，此时也可以复用），可以复用TIME_WAIT状态的连接。  </p>
</blockquote>
<blockquote>
<p>通过字面解释，以及例子说明，你看到了，tcp_tw_reuse应用的场景：某一方，需要不断的通过“短连接”连接其他服务器，总是自己先关闭连接(TIME_WAIT在自己这方)，关闭后又不断的重新连接对方。  </p>
</blockquote>
<blockquote>
<p>那么，当连接被复用了之后，延迟或者重发的数据包到达，新的连接怎么判断，到达的数据是属于复用后的连接，还是复用前的连接呢？那就需要依赖前面提到的两个时间字段了。复用连接后，这条连接的时间被更新为当前的时间，当延迟的数据达到，延迟数据的时间是小于新连接的时间，所以，内核可以通过时间判断出，延迟的数据可以安全的丢弃掉了。  </p>
</blockquote>
<blockquote>
<p>这个配置，依赖于连接双方，同时对timestamps的支持。同时，这个配置，仅仅影响outbound连接，即做为客户端的角色，连接服务端[connect(dest_ip, dest_port)]时复用TIME_WAIT的socket。  </p>
</blockquote>
<p><strong>net.ipv4.tcp_tw_recycle</strong></p>
<blockquote>
<p>字面意思，销毁掉 TIME_WAIT。  </p>
</blockquote>
<blockquote>
<p>当开启了这个配置后，内核会快速的回收处于TIME_WAIT状态的socket连接。多快？不再是2MSL，而是一个RTO（retransmission timeout，数据包重传的timeout时间）的时间，这个时间根据RTT动态计算出来，但是远小于2MSL。  </p>
</blockquote>
<blockquote>
<p>有了这个配置，还是需要保障 丢失重传或者延迟的数据包，不会被新的连接(注意，这里不再是复用了，而是之前处于TIME_WAIT状态的连接已经被destroy掉了，新的连接，刚好是和某一个被destroy掉的连接使用了相同的五元组而已)所错误的接收。在启用该配置，当一个socket连接进入TIME_WAIT状态后，内核里会记录包括该socket连接对应的五元组中的对方IP等在内的一些统计数据，当然也包括从该对方IP所接收到的最近的一次数据包时间。当有新的数据包到达，只要时间晚于内核记录的这个时间，数据包都会被统统的丢掉。  </p>
</blockquote>
<blockquote>
<p>这个配置，依赖于连接双方对timestamps的支持。同时，这个配置，主要影响到了inbound的连接（对outbound的连接也有影响，但是不是复用），即做为服务端角色，客户端连进来，服务端主动关闭了连接，TIME_WAIT状态的socket处于服务端，服务端快速的回收该状态的连接。  </p>
</blockquote>
<blockquote>
<p>由此，如果客户端处于NAT的网络(多个客户端，同一个IP出口的网络环境)，如果配置了tw_recycle，就可能在一个RTO的时间内，只能有一个客户端和自己连接成功(不同的客户端发包的时间不一致，造成服务端直接把数据包丢弃掉)。  </p>
</blockquote>
<p>我尽量尝试用文字解释清楚，但是，来点案例和图示，应该有助于我们彻底理解。</p>
<p>我们来看这样一个网络情况：<br><img src="%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%20%7C%20%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84TIME_WAIT%E5%92%8CCLOSE_WAIT/5E23D0D9-4566-48E3-9705-11861704230E.png" alt=""></p>
<ol>
<li><p>客户端IP地址为：180.172.35.150，我们可以认为是浏览器</p>
</li>
<li><p>负载均衡有两个IP，外网IP地址为 115.29.253.156，内网地址为10.162.74.10；外网地址监听80端口</p>
</li>
<li><p>负载均衡背后有两台Web服务器，一台IP地址为 10.162.74.43，监听80端口；另一台为 10.162.74.44，监听 80 端口</p>
</li>
<li><p>Web服务器会连接数据服务器，IP地址为 10.162.74.45，监听 3306 端口</p>
</li>
</ol>
<p>这种简单的架构下，我们来看看，在不同的情况下，我们今天谈论的tw_reuse/tw_recycle对网络连接的影响。</p>
<p>先做个假定：</p>
<ol>
<li><p>客户端通过HTTP/1.1连接负载均衡，也就是说，HTTP协议投Connection为keep-alive，所以我们假定，客户端 对 负载均衡服务器 的socket连接，客户端会断开连接，所以，TIME_WAIT出现在客户端</p>
</li>
<li><p>Web服务器和MySQL服务器的连接，我们假定，Web服务器上的程序在连接结束的时候，调用close操作关闭socket资源连接，所以，TIME_WAIT出现在 Web 服务器端。</p>
</li>
</ol>
<p>那么，在这种假定下：</p>
<ol>
<li><p>Web服务器上，肯定可以配置开启的配置：tcp_tw_reuse；如果Web服务器有很多连向DB服务器的连接，可以保证socket连接的复用。</p>
</li>
<li><p>那么，负载均衡服务器和Web服务器，谁先关闭连接，则决定了我们怎么配置tcp_tw_reuse/tcp_tw_recycle了</p>
</li>
</ol>
<p><strong>方案一：负载均衡服务器 首先关闭连接</strong></p>
<p>在这种情况下，因为负载均衡服务器对Web服务器的连接，TIME_WAIT大都出现在负载均衡服务器上，所以，在负载均衡服务器上的配置：</p>
<ul>
<li><p>net.ipv4.tcp_tw_reuse = 1 //尽量复用连接</p>
</li>
<li><p>net.ipv4.tcp_tw_recycle = 0 //不能保证客户端不在NAT的网络啊</p>
</li>
</ul>
<p>在Web服务器上的配置为：</p>
<ul>
<li><p>net.ipv4.tcp_tw_reuse = 1 //这个配置主要影响的是Web服务器到DB服务器的连接复用</p>
</li>
<li><p>net.ipv4.tcp_tw_recycle： 设置成1和0都没有任何意义。想一想，在负载均衡和它的连接中，它是服务端，但是TIME_WAIT出现在负载均衡服务器上；它和DB的连接，它是客户端，recycle对它并没有什么影响，关键是reuse</p>
</li>
</ul>
<p><strong>方案二：Web服务器首先关闭来自负载均衡服务器的连接</strong></p>
<p>在这种情况下，Web服务器变成TIME_WAIT的重灾区。负载均衡对Web服务器的连接，由Web服务器首先关闭连接，TIME_WAIT出现在Web服务器上；Web服务器对DB服务器的连接，由Web服务器关闭连接，TIME_WAIT也出现在它身上，此时，负载均衡服务器上的配置：</p>
<ul>
<li><p>net.ipv4.tcp_tw_reuse：0 或者 1 都行，都没有实际意义</p>
</li>
<li><p>net.ipv4.tcp_tw_recycle=0 //一定是关闭recycle</p>
</li>
</ul>
<p>在Web服务器上的配置：</p>
<ul>
<li><p>net.ipv4.tcp_tw_reuse = 1 //这个配置主要影响的是Web服务器到DB服务器的连接复用</p>
</li>
<li><p>net.ipv4.tcp_tw_recycle=1 //由于在负载均衡和Web服务器之间并没有NAT的网络，可以考虑开启recycle，加速由于负载均衡和Web服务器之间的连接造成的大量TIME_WAIT</p>
</li>
</ul>
<p><strong>回答几个大家提到的几个问题</strong></p>
<ol>
<li>请问我们所说连接池可以复用连接，是不是意味着，需要等到上个连接time wait结束后才能再次使用?</li>
</ol>
<blockquote>
<p>所谓连接池复用，复用的一定是活跃的连接，所谓活跃，第一表明连接池里的连接都是ESTABLISHED的，第二，连接池做为上层应用，会有定时的心跳去保持连接的活跃性。既然连接都是活跃的，那就不存在有TIME_WAIT的概念了，在上篇里也有提到，TIME_WAIT是在主动关闭连接的一方，在关闭连接后才进入的状态。既然已经关闭了，那么这条连接肯定已经不在连接池里面了，即被连接池释放了。  </p>
</blockquote>
<ol start="2">
<li>想请问下，作为负载均衡的机器随机端口使用完的情况下大量time_wait，不调整你文字里说的那三个参数，有其他的更好的方案吗？</li>
</ol>
<blockquote>
<p>第一，随机端口使用完，你可以通过调整/etc/sysctl.conf下的net.ipv4.ip_local_port_range配置，至少修改成 net.ipv4.ip_local_port_range=1024 65535，保证你的负载均衡服务器至少可以使用6万个随机端口，也即可以有6万的反向代理到后端的连接，可以支持每秒1000的并发（想一想，因为TIME_WAIT状态会持续1分钟后消失，所以一分钟最多有6万，每秒1000）；如果这么多端口都使用完了，也证明你应该加服务器了，或者，你的负载均衡服务器需要配置多个IP地址，或者，你的后端服务器需要监听更多的端口和配置更多的IP（想一下socket的五元组）  </p>
</blockquote>
<blockquote>
<p>第二，大量的TIME_WAIT，多大量？如果是几千个，其实不用担心，因为这个内存和CPU的消耗有一些，但是是可以忽略的。  </p>
</blockquote>
<blockquote>
<p>第三，如果真的量很大，上万上万的那种，可以考虑，让后端的服务器主动关闭连接，如果后端服务器没有外网的连接只有负载均衡服务器的连接（主要是没有NAT网络的连接），可以在后端服务器上配置tw_recycle，然后同时，在负载均衡服务器上，配置tw_reuse。  </p>
</blockquote>
<ol start="3">
<li>如果想深入的学习一下网络方面的知识，有什么推荐的？</li>
</ol>
<blockquote>
<p>学习网络比学一门编程语言“难”很多。所谓难，其实，是因为需要花很多的时间投入。我自己不算精通，只能说入门和理解。基本书可以推荐：《TCP/IP 协议详解》，必读；《TCP/IP高效编程：改善网络程序的44个技巧》，必读；《Unix环境高级编程》，必读；《Unix网络编程：卷一》，我只读过卷一；另外，还需要熟悉一下网络工具，tcpdump以及wireshark，我的notes里有一个一站式学习Wireshark：<a href="https://github.com/dafang/notebook/issues/114，也值得一读。有了这些积累，可能就是一些实践以及碎片化的学习和积累了。">https://github.com/dafang/notebook/issues/114，也值得一读。有了这些积累，可能就是一些实践以及碎片化的学习和积累了。</a>  </p>
</blockquote>
<p><strong>写在最后</strong></p>
<p>这篇文章我断断续续写了两天，内容找了多个地方去验证，包括看到Vincent Bernat的一篇文章以及Vincent在多个地方和别人的讨论。期间，我也花了一些时间和Vincent探讨了几个我没在tcp源码里翻找到的有疑问的地方。</p>
<p>我力求比散布在网上的文章做到准确并尽量整理的清晰一些。但是，也难免会</p>
<p>有疏漏或者有错误的地方，高手看到可以随时指正，并和我讨论，大家一起研究！<br>感谢您阅读。</p>
<p>用一点赞赏，来鼓励作者继续撰写干货</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4MjA4ODU0Ng==&mid=402415747&idx=1&sn=2458ba4fe1830eecdb8db725d3f395fa&mpshare=1&scene=1&srcid=0710ehXQ8Ie8dBtv7RGfraxj&key=dd608d91fd702d6445d20498afa18b8b719e095009b5c4681969c9b4cc5ccb4932d014b5101216c783f4ed13fda6408e87751fa23ab82ba32352b1feb0bf5800ae5b33d9e710d5cb79dba99af1fec435&ascene=0&uin=ODAzMDQyMjU%3D&devicetype=iMac+MacBookPro10%2C2+OSX+OSX+10.12.4+build(16E195)&version=12020810&nettype=WIFI&fontScale=100&pass_ticket=Cc9juYHNJFxAOsrB75olHFYxSRYnY82R1kRuvr8ZyAA%3D">高性能网络 | 你所不知道的TIME_WAIT和CLOSE_WAIT</a></p>

        </div>
        
        
        
    </div>
</div>









    
<div class="card card-transparent">
    <nav class="pagination is-centered" role="navigation" aria-label="pagination">
        <div class="pagination-previous">
            <a class="is-flex-grow has-text-black-ter" href="/">Previous</a>
        </div>
        <div class="pagination-next">
            <a class="is-flex-grow has-text-black-ter" href="/page/3/">Next</a>
        </div>
        <ul class="pagination-list is-hidden-mobile">
            
            <li><a class="pagination-link has-text-black-ter" href="/">1</a></li>
            
            <li><a class="pagination-link is-current" href="/page/2/">2</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/page/3/">3</a></li>
            
            <li><span class="pagination-ellipsis has-text-black-ter">&hellip;</span></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/page/6/">6</a></li>
            
        </ul>
    </nav>
</div>
</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                    <figure class="image is-128x128 has-mb-6">
                        <img class="" src="/images/avatar.png" alt="Robynn-D">
                    </figure>
                    
                    <p class="is-size-4 is-block">
                        Robynn-D
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        社長大人
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>中國台灣</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Posts
                    </p>
                    <a href="/archives">
                        <p class="title has-text-weight-normal">
                            60
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Categories
                    </p>
                    <a href="/categories">
                        <p class="title has-text-weight-normal">
                            0
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Tags
                    </p>
                    <a href="/tags">
                        <p class="title has-text-weight-normal">
                            0
                        </p>
                    </a>
                </div>
            </div>
        </nav>
        
        
        
    </div>
</div>
    
        
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Links
        </h3>
        <ul class="menu-list">
        
            <li>
                <a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener">
                    <span class="level-left">
                        <span class="level-item">Hexo</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">hexo.io</span>
                    </span>
                </a>
            </li>
        
        </ul>
        </div>
    </div>
</div>

    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Categories
            </h3>
            <ul class="menu-list">
            
            </ul>
        </div>
    </div>
</div>
    
        
    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
            <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Recent
        </h3>
        
        <article class="media">
            
            <a href="/2020/02/26/%E6%B5%AA%E6%BC%AB%E5%8C%BB%E7%94%9F%E9%87%91%E5%B8%88%E5%82%852%20-%20%E4%B8%8D%E5%AE%B9%E6%98%93%E7%9A%84%E4%BA%BA%E7%94%9F%E9%87%8C%EF%BC%8C%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%BA%BA%E9%83%BD%E5%80%BC%E5%BE%97%E8%A2%AB%E7%8F%8D%E6%83%9C/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="浪漫医生金师傅2 - 不容易的人生里，每一个人都值得被珍惜">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-02-26T06:23:36.973Z">2020-02-26</time></div>
                    <a href="/2020/02/26/%E6%B5%AA%E6%BC%AB%E5%8C%BB%E7%94%9F%E9%87%91%E5%B8%88%E5%82%852%20-%20%E4%B8%8D%E5%AE%B9%E6%98%93%E7%9A%84%E4%BA%BA%E7%94%9F%E9%87%8C%EF%BC%8C%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%BA%BA%E9%83%BD%E5%80%BC%E5%BE%97%E8%A2%AB%E7%8F%8D%E6%83%9C/" class="title has-link-black-ter is-size-6 has-text-weight-normal">浪漫医生金师傅2 - 不容易的人生里，每一个人都值得被珍惜</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/02/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%88%98%E7%95%A5/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="领域驱动设计战略">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-02T06:48:51.089Z">2019-08-02</time></div>
                    <a href="/2019/08/02/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%88%98%E7%95%A5/" class="title has-link-black-ter is-size-6 has-text-weight-normal">领域驱动设计战略</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/02/%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1DDD/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="领域建模DDD">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-02T06:48:51.089Z">2019-08-02</time></div>
                    <a href="/2019/08/02/%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1DDD/" class="title has-link-black-ter is-size-6 has-text-weight-normal">领域建模DDD</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/02/%E5%8E%BBBAT%E9%9D%A2%E8%AF%95%E5%AE%8C%E7%9A%84Mysql%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="去BAT面试完的Mysql面试题总结">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-02T06:48:51.085Z">2019-08-02</time></div>
                    <a href="/2019/08/02/%E5%8E%BBBAT%E9%9D%A2%E8%AF%95%E5%AE%8C%E7%9A%84Mysql%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" class="title has-link-black-ter is-size-6 has-text-weight-normal">去BAT面试完的Mysql面试题总结</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/02/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="史上最全Java多线程面试题及答案">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-02T06:48:51.085Z">2019-08-02</time></div>
                    <a href="/2019/08/02/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/" class="title has-link-black-ter is-size-6 has-text-weight-normal">史上最全Java多线程面试题及答案</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Archives
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2020/02/">
                <span class="level-start">
                    <span class="level-item">February 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">August 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">59</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Tags
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
            </div>
        </div>
    </div>
</div>
        
        </div>
    
</div>

                




<div class="column is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only has-order-3 column-right ">
    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Recent
        </h3>
        
        <article class="media">
            
            <a href="/2020/02/26/%E6%B5%AA%E6%BC%AB%E5%8C%BB%E7%94%9F%E9%87%91%E5%B8%88%E5%82%852%20-%20%E4%B8%8D%E5%AE%B9%E6%98%93%E7%9A%84%E4%BA%BA%E7%94%9F%E9%87%8C%EF%BC%8C%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%BA%BA%E9%83%BD%E5%80%BC%E5%BE%97%E8%A2%AB%E7%8F%8D%E6%83%9C/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="浪漫医生金师傅2 - 不容易的人生里，每一个人都值得被珍惜">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-02-26T06:23:36.973Z">2020-02-26</time></div>
                    <a href="/2020/02/26/%E6%B5%AA%E6%BC%AB%E5%8C%BB%E7%94%9F%E9%87%91%E5%B8%88%E5%82%852%20-%20%E4%B8%8D%E5%AE%B9%E6%98%93%E7%9A%84%E4%BA%BA%E7%94%9F%E9%87%8C%EF%BC%8C%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%BA%BA%E9%83%BD%E5%80%BC%E5%BE%97%E8%A2%AB%E7%8F%8D%E6%83%9C/" class="title has-link-black-ter is-size-6 has-text-weight-normal">浪漫医生金师傅2 - 不容易的人生里，每一个人都值得被珍惜</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/02/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%88%98%E7%95%A5/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="领域驱动设计战略">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-02T06:48:51.089Z">2019-08-02</time></div>
                    <a href="/2019/08/02/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%88%98%E7%95%A5/" class="title has-link-black-ter is-size-6 has-text-weight-normal">领域驱动设计战略</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/02/%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1DDD/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="领域建模DDD">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-02T06:48:51.089Z">2019-08-02</time></div>
                    <a href="/2019/08/02/%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1DDD/" class="title has-link-black-ter is-size-6 has-text-weight-normal">领域建模DDD</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/02/%E5%8E%BBBAT%E9%9D%A2%E8%AF%95%E5%AE%8C%E7%9A%84Mysql%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="去BAT面试完的Mysql面试题总结">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-02T06:48:51.085Z">2019-08-02</time></div>
                    <a href="/2019/08/02/%E5%8E%BBBAT%E9%9D%A2%E8%AF%95%E5%AE%8C%E7%9A%84Mysql%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" class="title has-link-black-ter is-size-6 has-text-weight-normal">去BAT面试完的Mysql面试题总结</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/02/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="史上最全Java多线程面试题及答案">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-02T06:48:51.085Z">2019-08-02</time></div>
                    <a href="/2019/08/02/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/" class="title has-link-black-ter is-size-6 has-text-weight-normal">史上最全Java多线程面试题及答案</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Archives
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2020/02/">
                <span class="level-start">
                    <span class="level-item">February 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">August 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">59</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Tags
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
            </div>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.svg" alt="柠檬资源社" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2020 Robynn-D&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a>
                
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("en");</script>


<script>
var IcarusThemeSettings = {
    site: {
        url: 'http://yoursite.com',
        external_link: {"enable":true,"exclude":[]}
    },
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>





<script src="/js/animation.js"></script>



<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>



<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>


<a id="back-to-top" title="Back to Top" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>














<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>