<!DOCTYPE html>
<html  lang="en">
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 4.2.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>Java 开发必备面试题详解（技术+人事） - 柠檬资源社</title>


    <meta name="description" content="Java 开发必备面试题详解（技术+人事）大家好，我是宁楠，之前出了一个达人课《Spring MVC 实战手册》，在跟读者的交流过程中，不断有朋友谈到关于面试的问题，可见大家对这部分的需求还是比较大的。所以我就将平时积累的 Java 面试题进行详细地筛选，并在某些地方加入解题思路和对知识点的理解，整理成文章分享给大家。共计 211 道题，涉及到 Java 面试的高频考点，以及相关人事问题，希望对大">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 开发必备面试题详解（技术+人事）">
<meta property="og:url" content="http://yoursite.com/2019/08/02/Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89/index.html">
<meta property="og:site_name" content="柠檬资源社">
<meta property="og:description" content="Java 开发必备面试题详解（技术+人事）大家好，我是宁楠，之前出了一个达人课《Spring MVC 实战手册》，在跟读者的交流过程中，不断有朋友谈到关于面试的问题，可见大家对这部分的需求还是比较大的。所以我就将平时积累的 Java 面试题进行详细地筛选，并在某些地方加入解题思路和对知识点的理解，整理成文章分享给大家。共计 211 道题，涉及到 Java 面试的高频考点，以及相关人事问题，希望对大">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/images/og_image.png">
<meta property="article:published_time" content="2019-08-02T06:48:51.082Z">
<meta property="article:modified_time" content="2019-08-02T06:48:51.084Z">
<meta property="article:author" content="Robynn-D">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/og_image.png">







<link rel="icon" href="/images/favicon.svg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    
    
    
    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.svg" alt="Java 开发必备面试题详解（技术+人事）" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">Home</a>
                
                <a class="navbar-item"
                href="/archives">Archives</a>
                
                <a class="navbar-item"
                href="/categories">Categories</a>
                
                <a class="navbar-item"
                href="/tags">Tags</a>
                
                <a class="navbar-item"
                href="/about">About</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    <a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                
                <a class="navbar-item search" title="Search" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-6-widescreen has-order-2 column-main">
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-08-02T06:48:51.082Z">2019-08-02</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    7 hours read (About 60103 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                Java 开发必备面试题详解（技术+人事）
            
        </h1>
        <div class="content">
            <h1 id="Java-开发必备面试题详解（技术-人事）"><a href="#Java-开发必备面试题详解（技术-人事）" class="headerlink" title="Java 开发必备面试题详解（技术+人事）"></a>Java 开发必备面试题详解（技术+人事）</h1><p>大家好，我是宁楠，之前出了一个达人课《Spring MVC 实战手册》，在跟读者的交流过程中，不断有朋友谈到关于面试的问题，可见大家对这部分的需求还是比较大的。所以我就将平时积累的 Java 面试题进行详细地筛选，并在某些地方加入解题思路和对知识点的理解，整理成文章分享给大家。共计 211 道题，涉及到 Java 面试的高频考点，以及相关人事问题，希望对大家的求职面试有所帮助。</p>
<h3 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><p><strong>1. 判断身份证：要么是 15 位，要么是 18 位，最后一位可以为字母，并写程序提出其中的年月日。</strong></p>
<blockquote>
<p>我们可以用正则表达式来定义复杂的字符串格式，如 <code>\d{17}[0-9a-zA-Z]|\d{14}[0-9a-zA-Z]</code> 可以用来判断是否为合法的 15 位或 18 位身份证号码。  </p>
</blockquote>
<blockquote>
<p>因为 15 位和 18 位的身份证号码都是从 7 位到第 12 位为身份证为日期类型。这样我们可以设计出更精确的正则模式，使身份证号的日期合法，这样我们的正则模式可以进一步将日期部分的正则修改为 <code>[12][0-9]{3}[01][0-9][123][0-9]</code> ，当然可以更精确的设置日期。  </p>
</blockquote>
<blockquote>
<p>在 JDK 的 java.util.Regex 包中有实现正则的类，Pattern 和 Matcher。以下是实现代码：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.P attern;</span><br><span class="line">public class RegexTest &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 测试是否为合法的身份证号码</span><br><span class="line">        String[] strs &#x3D; &#123; &quot;130681198712092019&quot;, &quot;13068119871209201x&quot;,</span><br><span class="line">                &quot;13068119871209201&quot;, &quot;123456789012345&quot;, &quot;12345678901234x&quot;,</span><br><span class="line">                &quot;1234567890123&quot; &#125;;</span><br><span class="line">        Pattern p1 &#x3D; Pattern.compile(&quot;(\\d&#123;17&#125;[0-9a-zA-Z]|\\d&#123;14&#125;[0-9a-zA-Z])&quot;);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">            Matcher matcher &#x3D; p1.matcher(strs[i]);</span><br><span class="line">            System.out.println(strs[i] + &quot;:&quot; + matcher.matches());</span><br><span class="line">        &#125;</span><br><span class="line">        Pattern p2 &#x3D; Pattern.compile(&quot;\\d&#123;6&#125;(\\d&#123;8&#125;).*&quot;); &#x2F;&#x2F; 用于提取出生日字符串</span><br><span class="line">        Pattern p3 &#x3D; Pattern.compile(&quot;(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)&quot;);&#x2F;&#x2F; 用于将生日字符串进行分解为年月日</span><br><span class="line">        for (int i &#x3D; 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">            Matcher matcher &#x3D; p2.matcher(strs[i]);</span><br><span class="line">            boolean b &#x3D; matcher.find();</span><br><span class="line">            if (b) &#123;</span><br><span class="line">                String s &#x3D; matcher.group(1);</span><br><span class="line">                Matcher matcher2 &#x3D; p3.matcher(s);</span><br><span class="line">                if (matcher2.find()) &#123;</span><br><span class="line">                    System.out</span><br><span class="line">                            .println(&quot;生日为&quot; + matcher2.group(1) + &quot;年&quot;</span><br><span class="line">                                    + matcher2.group(2) + &quot;月&quot;</span><br><span class="line">                                    + matcher2.group(3) + &quot;日&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 说明生活中遇到的二叉树，用 Java 实现二叉树。</strong></p>
<blockquote>
<p>这是组合设计模式。  </p>
</blockquote>
<blockquote>
<p>我有很多个（假设 10 万个）数据要保存起来，以后还需要从保存的这些数据中检索是否存在某个数据。假如存在数组中，那么，碰巧要找的数字位于 99999 那个地方，查找的速度将很慢，因为要从第 1 个依次往后取，取出来后进行比较。平衡二叉树（构建平衡二叉树需要先排序，我们这里就不作考虑了）可以很好地解决这个问题，但二叉树的遍历（前序、中序、后序）效率要比数组低很多，代码如下：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">public class Node &#123;</span><br><span class="line">    public int value;</span><br><span class="line">    public Node left;</span><br><span class="line">    public Node right;</span><br><span class="line">    public void store(int value)</span><br><span class="line">    &#123;</span><br><span class="line">        if(value&lt;this.value)</span><br><span class="line">        &#123;</span><br><span class="line">            if(left &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                left &#x3D; new Node();</span><br><span class="line">                left.value&#x3D;value;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                left.store(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(value&gt;this.value)</span><br><span class="line">        &#123;</span><br><span class="line">            if(right &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                right &#x3D; new Node();</span><br><span class="line">                right.value&#x3D;value;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                right.store(value);</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean find(int value)</span><br><span class="line">    &#123;   </span><br><span class="line">        System.out.println(&quot;happen &quot; + this.value);</span><br><span class="line">        if(value &#x3D;&#x3D; this.value)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(value&gt;this.value)</span><br><span class="line">        &#123;</span><br><span class="line">            if(right &#x3D;&#x3D; null) return false;</span><br><span class="line">            return right.find(value);</span><br><span class="line">        &#125;else</span><br><span class="line">        &#123;</span><br><span class="line">            if(left &#x3D;&#x3D; null) return false;</span><br><span class="line">            return left.find(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public  void preList()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(this.value + &quot;,&quot;);</span><br><span class="line">        if(left!&#x3D;null) left.preList();</span><br><span class="line">        if(right!&#x3D;null) right.preList();</span><br><span class="line">    &#125;</span><br><span class="line">    public void middleList()</span><br><span class="line">    &#123;</span><br><span class="line">        if(left!&#x3D;null) left.preList();</span><br><span class="line">        System.out.print(this.value + &quot;,&quot;);</span><br><span class="line">        if(right!&#x3D;null) right.preList();        </span><br><span class="line">    &#125;</span><br><span class="line">    public void afterList()</span><br><span class="line">    &#123;</span><br><span class="line">        if(left!&#x3D;null) left.preList();</span><br><span class="line">        if(right!&#x3D;null) right.preList();</span><br><span class="line">        System.out.print(this.value + &quot;,&quot;);     </span><br><span class="line">    &#125;   </span><br><span class="line">    public static void main(String [] args)</span><br><span class="line">    &#123;</span><br><span class="line">        int [] data &#x3D; new int[20];</span><br><span class="line">        for(int i&#x3D;0;i&lt;data.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            data[i] &#x3D; (int)(Math.random()*100) + 1;</span><br><span class="line">            System.out.print(data[i] + &quot;,&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        Node root &#x3D; new Node();</span><br><span class="line">        root.value &#x3D; data[0];</span><br><span class="line">        for(int i&#x3D;1;i&lt;data.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            root.store(data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        root.find(data[19]);</span><br><span class="line">        root.preList();</span><br><span class="line">        System.out.println();</span><br><span class="line">        root.middleList();</span><br><span class="line">        System.out.println();       </span><br><span class="line">        root.afterList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 第 1 个人 10 岁，第 2 个比第 1 个人大 2 岁，依次递推，请用递归方式计算出第 8 个人多大？</strong></p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line">public class A1 &#123;</span><br><span class="line">    public static void main(String [] args)&#123;</span><br><span class="line">        System.out.println(computeAge(8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int computeAge(int n)&#123;</span><br><span class="line">        if(n&#x3D;&#x3D;1) return 10;</span><br><span class="line">        return computeAge(n-1) + 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void toBinary(int n,StringBuffer result)&#123;</span><br><span class="line">    if(n&#x2F;2 !&#x3D; 0)</span><br><span class="line">    toBinary(n&#x2F;2,result);</span><br><span class="line">    result.append(n%2);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 有一对兔子，从出生后第 3 个月起每个月都生一对兔子，小兔子长到第四个月后每个月又生一对兔子，假如兔子都不死，问第月的兔子总数为多少？</strong></p>
<blockquote>
<p>程序分析： 兔子的规律为数列 1,1,2,3,5,8,13,21…  </p>
</blockquote>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/7ddb5450-ee15-11e8-8b4e-7322b3314c0b" alt=""></p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class exp1 &#123;</span><br><span class="line">     public static void main(String args[]) &#123;</span><br><span class="line">          int i &#x3D; 0;</span><br><span class="line">          for (i &#x3D; 1; i &lt;&#x3D; 20; i++)</span><br><span class="line">               System.out.println(f(i));  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public static int f(int x) &#123;</span><br><span class="line">          if (x &#x3D;&#x3D; 1 || x &#x3D;&#x3D; 2)</span><br><span class="line">               return 1;   else</span><br><span class="line">               return f(x - 1) + f(x - 2);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class exp1 &#123;</span><br><span class="line">     public static void main(String args[]) &#123;</span><br><span class="line">          int i &#x3D; 0;</span><br><span class="line">          math mymath &#x3D; new math();</span><br><span class="line">          for (i &#x3D; 1; i &lt;&#x3D; 20; i++)    </span><br><span class="line">            System.out.println(mymath.f(i));</span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">class math &#123;</span><br><span class="line">     public int f(int x) &#123;</span><br><span class="line">          if (x &#x3D;&#x3D; 1 || x &#x3D;&#x3D; 2)</span><br><span class="line">               return 1;</span><br><span class="line">          else    </span><br><span class="line">            return f(x - 1) + f(x - 2);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5. 打印出所有的“水仙花数”。所谓“水仙花数”是指一个三位数，其各位数字立方和等于该数本身。例 如：153 是一个“水仙花数”，因为 153 = 1 的三次方＋5 的三次方＋3 的三次方。在 2000 以内的数字。</strong></p>
<blockquote>
<p>程序分析：利用 for 循环控制 100~999 个数，每个数分解出个位、十位、百位。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class exp2 &#123;</span><br><span class="line">     public static void main(String args[]) &#123;</span><br><span class="line">          int i &#x3D; 0;</span><br><span class="line">          math mymath &#x3D; new math();</span><br><span class="line">          for (i &#x3D; 100; i &lt;&#x3D; 999; i++)    </span><br><span class="line">            if (mymath.shuixianhua(i) &#x3D;&#x3D; true)</span><br><span class="line">                System.out.println(i);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">class math &#123;</span><br><span class="line">     public int f(int x) &#123;</span><br><span class="line">          if (x &#x3D;&#x3D; 1 || x &#x3D;&#x3D; 2)</span><br><span class="line">               return 1;</span><br><span class="line">          else    </span><br><span class="line">            return f(x - 1) + f(x - 2);</span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">     public boolean iszhishu(int x) &#123;</span><br><span class="line">          for (int i &#x3D; 2; i &lt;&#x3D; x &#x2F; 2; i++)    if (x % 2 &#x3D;&#x3D; 0)</span><br><span class="line">            return false;</span><br><span class="line">              return true;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    public boolean shuixianhua(int x) &#123;</span><br><span class="line">          int i &#x3D; 0, j &#x3D; 0, k &#x3D; 0;</span><br><span class="line">          i &#x3D; x &#x2F; 100;   j &#x3D; (x % 100) &#x2F; 10;</span><br><span class="line">          k &#x3D; x % 10;</span><br><span class="line">          if (x &#x3D;&#x3D; i * i * i + j * j * j + k * k * k)</span><br><span class="line">               return true;</span><br><span class="line">          else    return false;  </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6. 输入两个正整数 m 和 n，求其最大公约数和最小公倍数。</strong></p>
<blockquote>
<p>程序分析：利用辗除法。 最大公约数：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class CommonDivisor &#123;</span><br><span class="line">     public static void main(String args[]) &#123;  </span><br><span class="line">        commonDivisor(24, 32);</span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">    static int commonDivisor(int M, int N) &#123;</span><br><span class="line">          if (N &lt; 0 || M &lt; 0) &#123;    </span><br><span class="line">             System.out.println(&quot;ERROR!&quot;);</span><br><span class="line">                   return -1;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">        if (N &#x3D;&#x3D; 0) &#123;</span><br><span class="line">               System.out.println(&quot;the biggest common divisor is :&quot; + M);    return M;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">        return commonDivisor(N, M % N);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">最小公倍数和最大公约数：</span><br><span class="line">import java.util.Scanner;  </span><br><span class="line">public class CandC &#123;  </span><br><span class="line">    &#x2F;&#x2F; 下面的方法是求出最大公约数</span><br><span class="line">     public static int gcd(int m, int n) &#123;</span><br><span class="line">          while (true) &#123;</span><br><span class="line">               if ((m &#x3D; m % n) &#x3D;&#x3D; 0)     return n;</span><br><span class="line">               if ((n &#x3D; n % m) &#x3D;&#x3D; 0)</span><br><span class="line">                return m;</span><br><span class="line">          &#125;</span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> public static void main(String args[]) throws Exception &#123;  </span><br><span class="line">     &#x2F;&#x2F; 取得输入值</span><br><span class="line">      Scanner chin &#x3D; new Scanner(System.in);</span><br><span class="line">    int a &#x3D; chin.nextInt(), b &#x3D; chin.nextInt();   int a &#x3D; 23;</span><br><span class="line">      int b &#x3D; 32;</span><br><span class="line">      int c &#x3D; gcd(a, b);   </span><br><span class="line">    System.out.println(&quot;最小公倍数：&quot; + a * b &#x2F; c + &quot;\n最大公约数：&quot; + c);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>7. 输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。</strong></p>
<blockquote>
<p>程序分析：利用 while 语句，条件为输入的字符不为 ‘\n ‘。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;  </span><br><span class="line"></span><br><span class="line">public class ex7 &#123;</span><br><span class="line">     public static void main(String args[]) &#123;  </span><br><span class="line">        System.out.println(&quot;请输入字符串：&quot;);           </span><br><span class="line">        Scanner scan &#x3D; new Scanner(System.in);</span><br><span class="line">          String str &#x3D; scan.next();</span><br><span class="line">          String E1 &#x3D; &quot;[\u4e00-\u9fa5]&quot;;</span><br><span class="line">          String E2 &#x3D; &quot;[a-zA-Z]&quot;;</span><br><span class="line">          int countH &#x3D; 0;   </span><br><span class="line">        int countE &#x3D; 0;</span><br><span class="line">          char[] arrChar &#x3D; str.toCharArray();</span><br><span class="line">          String[] arrStr &#x3D; new String[arrChar.length];</span><br><span class="line">          for (int i &#x3D; 0; i &lt; arrChar.length; i++) &#123;</span><br><span class="line">               arrStr[i] &#x3D; String.valueOf(arrChar[i]);  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (String i : arrStr) &#123;</span><br><span class="line">               if (i.matches(E1)) &#123;</span><br><span class="line">                countH++;</span><br><span class="line">               &#125;if (i.matches(E2)) &#123;</span><br><span class="line">                    countE++;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;   </span><br><span class="line">        System.out.println(&quot;汉字的个数&quot; + countH);   System.out.println(&quot;字母的个数&quot; + countE);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>8. 求 s=a+aa+aaa+aaaa+aa…a 的值，其中 a 是一个数字。例如 2+22+222+2222+22222（此时共有 5 个数相加），几个数相加有键盘控制。</strong></p>
<blockquote>
<p>程序分析：关键是计算出每一项的值。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class Sumloop &#123;</span><br><span class="line">     public static void main(String[] args) throws IOException &#123;</span><br><span class="line">          int s &#x3D; 0;   </span><br><span class="line">        String output &#x3D; &quot;&quot;;</span><br><span class="line">          BufferedReader stadin &#x3D; new BufferedReader(new InputStreamReader(</span><br><span class="line">    System.in));   </span><br><span class="line">        System.out.println(&quot;请输入a的值&quot;);</span><br><span class="line">        String input &#x3D; stadin.readLine();   </span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; Integer.parseInt(input); i++) &#123;</span><br><span class="line">               output +&#x3D; input;</span><br><span class="line">               int a &#x3D; Integer.parseInt(output);</span><br><span class="line">               s +&#x3D; a;</span><br><span class="line">          &#125;   </span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import java.io.*;  </span><br><span class="line">public class Sumloop &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;   </span><br><span class="line">        int s &#x3D; 0;</span><br><span class="line">          int n;</span><br><span class="line">          int t &#x3D; 0;</span><br><span class="line">          BufferedReader stadin &#x3D; new BufferedReader(new InputStreamReader(</span><br><span class="line">    System.in));  </span><br><span class="line">        String input &#x3D; stadin.readLine();</span><br><span class="line">          n &#x3D; Integer.parseInt(input);</span><br><span class="line">         for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">               t &#x3D; t * 10 + n;</span><br><span class="line">               s &#x3D; s + t;   </span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">          System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>9. 一个数如果恰好等于它的因子之和，这个数就称为“完数”。例如 6 = 1＋2＋3。编程找出 1000 以内的所有完数。</strong></p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Wanshu &#123;  </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          int s;</span><br><span class="line">          for (int i &#x3D; 1; i &lt;&#x3D; 1000; i++) &#123;</span><br><span class="line">               s &#x3D; 0;</span><br><span class="line">               for (int j &#x3D; 1; j &lt; i; j++)     </span><br><span class="line">                if (i % j &#x3D;&#x3D; 0)</span><br><span class="line">                 s &#x3D; s + j;</span><br><span class="line">                   if (s &#x3D;&#x3D; i)</span><br><span class="line">            System.out.print(i + &quot; &quot;);</span><br><span class="line">          &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>10. 有 1、2、3、4 个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</strong></p>
<blockquote>
<p>程序分析：可填在百位、十位、个位的数字都是 1、2、3、4。组成所有的排列后再去掉不满足条件的排列。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Wanshu &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;   </span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">          int j &#x3D; 0;</span><br><span class="line">          int k &#x3D; 0;</span><br><span class="line">          int t &#x3D; 0;</span><br><span class="line">          for (i &#x3D; 1; i &lt;&#x3D; 4; i++)    </span><br><span class="line">            for (j &#x3D; 1; j &lt;&#x3D; 4; j++)</span><br><span class="line">                for (k &#x3D; 1; k &lt;&#x3D; 4; k++)</span><br><span class="line">                     if (i !&#x3D; j &amp;&amp; j !&#x3D; k &amp;&amp; i !&#x3D; k) &#123;</span><br><span class="line">                              t +&#x3D; 1;</span><br><span class="line">                              System.out.println(i * 100 + j * 10 + k);      </span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(t);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>11. 一个整数，它加上 100 后是一个完全平方数，加上 168 又是一个完全平方数，请问该数是多少？</strong></p>
<blockquote>
<p>程序分析：在 10 万以内判断，先将该数加上 100 后再开方，再将该数加上 268 后再开方，如果开方后的结果满足如下条件，即是结果。请看具体分析：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          long k &#x3D; 0;   </span><br><span class="line">        for (k &#x3D; 1; k &lt;&#x3D; 100000l; k++)</span><br><span class="line">               if (Math.floor(Math.sqrt(k + 100)) &#x3D;&#x3D; Math.sqrt(k + 100) &amp;&amp; Math.floor(Math.sqrt(k + 168)) &#x3D;&#x3D; Math.sqrt(k + 168))</span><br><span class="line">                System.out.println(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>12. 猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个。第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第 10 天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。</strong></p>
<blockquote>
<p>程序分析：采取逆向思维的方法，从后往前推断。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Monkey &#123;</span><br><span class="line">     static int total(int day) &#123;   </span><br><span class="line">        if (day &#x3D;&#x3D; 10) &#123;</span><br><span class="line">           return 1;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            return (total(day + 1) + 1) * 2;</span><br><span class="line">          &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">  System.out.println(total(1));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>13. 有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13……求出这个数列的前 20 项之和。</strong></p>
<blockquote>
<p>程序分析：请抓住分子与分母的变化规律。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class test20 &#123;</span><br><span class="line">     public static void main(String[] args) &#123;</span><br><span class="line">          float fm &#x3D; 1f;</span><br><span class="line">          float fz &#x3D; 1f;   float temp;</span><br><span class="line">          float sum &#x3D; 0f;</span><br><span class="line">          for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">               temp &#x3D; fm;</span><br><span class="line">               fm &#x3D; fz;   </span><br><span class="line">            fz &#x3D; fz + temp;</span><br><span class="line">               sum +&#x3D; fz &#x2F; fm;</span><br><span class="line">        &#125;</span><br><span class="line">          System.out.println(sum);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>14. 有 5 个人坐在一起，问第五个人多少岁？他说比第 4 个人大 2 岁。问第 4 个人岁数，他说比第 3 个人 大 2 岁。问第三个人，又说比第 2 人大两岁。问第 2 个人，说比第一个人大两岁。最后问第一个人，他说是 10 岁。请问第五个人多大？</strong></p>
<blockquote>
<p>程序分析：利用递归的方法，递归分为回推和递推两个阶段。要想知道第五个人岁数，需知道第四人的岁数，依次类推， 推到第一人（10 岁），再往回推。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Ex23 &#123;  </span><br><span class="line">     static int getAge(int n) &#123;   </span><br><span class="line">        if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">               return 10;</span><br><span class="line">          &#125;</span><br><span class="line">          return 2 + getAge(n - 1);</span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;   </span><br><span class="line">        System.out.println(&quot;第五个的年龄为:&quot; + getAge(5));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>15. 打印出杨辉三角形。</strong></p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/c047b950-ee15-11e8-ae88-19b33b399945" alt=""></p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Ex33 &#123;</span><br><span class="line">     public static void main(String args[]) &#123;   int i, j;</span><br><span class="line">          int a[][];</span><br><span class="line">          a &#x3D; new int[8][8];</span><br><span class="line">          for (i &#x3D; 0; i &lt; 8; i++) &#123;</span><br><span class="line">               a[i][i] &#x3D; 1;    a[i][0] &#x3D; 1;</span><br><span class="line">          &#125;</span><br><span class="line">          for (i &#x3D; 2; i &lt; 8; i++) &#123;</span><br><span class="line">               for (j &#x3D; 1; j &lt;&#x3D; i - 1; j++) &#123;</span><br><span class="line">                a[i][j] &#x3D; a[i - 1][j - 1] + a[i - 1][j];    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         for (i &#x3D; 0; i &lt; 8; i++) &#123;</span><br><span class="line">               for (j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">                System.out.printf(&quot;  &quot; + a[i][j]);    </span><br><span class="line">            &#125;</span><br><span class="line">               System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ol>
<li>Java 类加载过程？<blockquote>
<p>Java 类加载需要经历一下 7 个过程：  </p>
</blockquote>
</li>
</ol>
<blockquote>
<p><strong>1. 加载</strong>  </p>
</blockquote>
<blockquote>
<p>加载是类加载的第一个过程，在这个阶段，将完成一下三件事情：  </p>
</blockquote>
<ul>
<li>通过一个类的全限定名获取该类的二进制流。</li>
<li>将该二进制流中的静态存储结构转化为方法去运行时数据结构。</li>
<li>在内存中生成该类的 Class 对象，作为该类的数据访问入口。<blockquote>
<p><strong>2. 验证</strong>  </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>验证的目的是为了确保 Class 文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证:  </p>
</blockquote>
<ul>
<li>文件格式验证：验证字节流是否符合 Class 文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.</li>
<li>元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。</li>
<li>字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。</li>
<li>符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。<blockquote>
<p><strong>3. 准备</strong>  </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static int value&#x3D;123;&#x2F;&#x2F;在准备阶段value初始值为0 。在初始化阶段才会变为123 。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>4. 解析</strong>  </p>
</blockquote>
<blockquote>
<p>该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。  </p>
</blockquote>
<blockquote>
<p><strong>5. 初始化</strong>  </p>
</blockquote>
<blockquote>
<p>初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。  </p>
</blockquote>
<blockquote>
<p><strong>6. 使用</strong>  </p>
</blockquote>
<blockquote>
<p><strong>7. 卸载</strong>  </p>
</blockquote>
<ol>
<li>描述一下 JVM 加载 Class 文件的原理机制?<blockquote>
<p>Java 语言是一种具有动态性的解释型语言，类（Class）只有被加载到 JVM 后才能运行。当运行指定程序时，JVM 会将编译生成的 .class 文件按照需求和一定的规则加载到内存中，并组织成为一个完整的 Java 应用程序。这个加载过程是由类加载器完成，具体来说，就是由 ClassLoader 和它的子类来实现的。类加载器本身也是一个类，其实质是把类文件从硬盘读取到内存中。  </p>
</blockquote>
</li>
</ol>
<blockquote>
<p>类的加载方式分为隐式加载和显示加载。隐式加载指的是程序在使用 new 等方式创建对象时，会隐式地调用类的加载器把对应的类加载到 JVM 中。显示加载指的是通过直接调用 class.forName() 方法来把所需的类加载到 JVM 中。  </p>
</blockquote>
<blockquote>
<p>任何一个工程项目都是由许多类组成的，当程序启动时，只把需要的类加载到 JVM 中，其他类只有被使用到的时候才会被加载，采用这种方法一方面可以加快加载速度，另一方面可以节约程序运行时对内存的开销。此外，在 Java 语言中，每个类或接口都对应一个 .class 文件，这些文件可以被看成是一个个可以被动态加载的单元，因此当只有部分类被修改时，只需要重新编译变化的类即可，而不需要重新编译所有文件，因此加快了编译速度。  </p>
</blockquote>
<blockquote>
<p>在 Java 语言中，类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类（例如基类）完全加载到 JVM 中，至于其他类，则在需要的时候才加载。  </p>
</blockquote>
<blockquote>
<p>类加载的主要步骤：  </p>
</blockquote>
<ul>
<li><p>装载。根据查找路径找到相应的 class 文件，然后导入。</p>
</li>
<li><p>链接。链接又可分为 3 个小步：</p>
</li>
<li><p>检查，检查待加载的 class 文件的正确性。</p>
</li>
<li><p>准备，给类中的静态变量分配存储空间。</p>
</li>
<li><p>解析，将符号引用转换为直接引用（这一步可选）</p>
</li>
<li><p>初始化。对静态变量和静态代码块执行初始化工作。</p>
</li>
</ul>
<p><strong>18. Java 内存分配。</strong></p>
<ul>
<li><strong>寄存器：</strong> 我们无法控制。</li>
<li><strong>静态域</strong> ：static定义的静态成员。</li>
<li><strong>常量池：</strong> 编译时被确定并保存在 .class 文件中的（final）常量值和一些文本修饰的符号引用（类和接口的全限定名，字段的名称和描述符，方法和名称和描述符）。</li>
<li><strong>非 RAM 存储：</strong> 硬盘等永久存储空间。</li>
<li><strong>堆内存</strong> ：new 创建的对象和数组，由 Java 虚拟机自动垃圾回收器管理,存取速度慢。</li>
<li><strong>栈内存：</strong> 基本类型的变量和对象的引用变量（堆内存空间的访问地址），速度快，可以共享，但是大小与生存期必须确定，缺乏灵活性。</li>
</ul>
<ol>
<li>Java 堆的结构是什么样子的？什么是堆中的永久代（Perm Gen space）?<blockquote>
<p>JVM 的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在 JVM 启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。  </p>
</blockquote>
</li>
</ol>
<blockquote>
<p>堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些 对象回收掉之前，他们会一直占据堆内存空间。  </p>
</blockquote>
<p><strong>20. GC 是什么? 为什么要有 GC？</strong></p>
<blockquote>
<p>GC 是垃圾收集的意思（GabageCollection），内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。  </p>
</blockquote>
<p><strong>21. 简述 Java 垃圾回收机制。</strong></p>
<blockquote>
<p>在 Java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。  </p>
</blockquote>
<p><strong>22. 如何判断一个对象是否存活？（或者 GC 对象的判定方法）</strong></p>
<blockquote>
<p>判断一个对象是否存活有两种方法：  </p>
</blockquote>
<blockquote>
<p><strong>1. 引用计数法</strong>  </p>
</blockquote>
<blockquote>
<p>所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收.  </p>
</blockquote>
<blockquote>
<p>引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B，对象 B 又引用者对象 A，那么此时 A、B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。  </p>
</blockquote>
<blockquote>
<p><strong>2. 可达性算法（引用链法）</strong>  </p>
</blockquote>
<blockquote>
<p>该算法的思想是：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。  </p>
</blockquote>
<blockquote>
<p>在 Java 中可以作为 GC Roots 的对象有以下几种：  </p>
</blockquote>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区类静态属性引用的对象</li>
<li>方法区常量池引用的对象</li>
<li>本地方法栈JNI引用的对象<blockquote>
<p>虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达 GC Root 时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记.  </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法或者已被虚拟机调用过，那么就认为是没必要的。 如果该对象有必要执行 finalize() 方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize() 线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果 finalize() 执行缓慢或者发生了死锁，那么就会造成 F-Queue 队列一直等待，造成了内存回收系统的崩溃。GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除” 即将回收” 集合，等待回收。  </p>
</blockquote>
<p><strong>23. 垃圾回收的优点和原理。并考虑 2 种回收机制。</strong></p>
<blockquote>
<p>Java 语言中一个显著的特点就是引入了垃圾回收机制，使 C++ 程序员最头疼的内存管理的问题迎刃而解，它使得 Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java 中的对象不再有“作用域”的概念，只有对象的引用才有”作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。  </p>
</blockquote>
<blockquote>
<p>回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。  </p>
</blockquote>
<p><strong>24. 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</strong></p>
<blockquote>
<p>对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。通常，GC 采用有向图的方式记录和管理堆（heap）中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当 GC 确定一些对象为“不可达”时，GC 就有责任回收这些内存空间。可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言规范并不保证 GC 一定会执行。  </p>
</blockquote>
<p><strong>25. Java 中会存在内存泄漏吗，请简单描述。</strong></p>
<blockquote>
<p>所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。Java 中有垃圾回收机制，它可以保证一对象不再被引用的时候，即对象变成了孤儿的时候，对象将自动被垃圾回收器从内存中清除掉。由于 Java 使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么 GC 也是可以回收它们的，例如下面的代码可以看到这种情况的内存回收：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">public class GarbageTest &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param args</span><br><span class="line">     * @throws IOException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        try &#123;</span><br><span class="line">            gcTest();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;has exited gcTest!&quot;);</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.in.read();       </span><br><span class="line">        System.out.println(&quot;out begin gc!&quot;);        </span><br><span class="line">        for(int i&#x3D;0;i&lt;100;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            System.in.read();   </span><br><span class="line">            System.in.read();   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static void gcTest() throws IOException &#123;</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.in.read();       </span><br><span class="line">        Person p1 &#x3D; new Person();</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.in.read();       </span><br><span class="line">        Person p2 &#x3D; new Person();</span><br><span class="line">        p1.setMate(p2);</span><br><span class="line">        p2.setMate(p1);</span><br><span class="line">        System.out.println(&quot;before exit gctest!&quot;);</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.in.read();       </span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(&quot;exit gctest!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private static class Person</span><br><span class="line">    &#123;</span><br><span class="line">        byte[] data &#x3D; new byte[20000000];</span><br><span class="line">        Person mate &#x3D; null;</span><br><span class="line">        public void setMate(Person other)</span><br><span class="line">        &#123;</span><br><span class="line">            mate &#x3D; other;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java 中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是 Java 中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是 java 中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中 (例如放在一个全局 map 对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。  </p>
</blockquote>
<blockquote>
<p>检查 Java 中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。  </p>
</blockquote>
<blockquote>
<p>如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。  </p>
</blockquote>
<blockquote>
<p>下面内容来自于网上（主要特点就是清空堆栈中的某个元素，并不是彻底把它从数组中拿掉，而是把存储的总数减少，本人写得可以比这个好，在拿掉某个元素时，顺便也让它从数组中消失，将那个元素所在的位置的值设置为 null 即可）：  </p>
</blockquote>
<blockquote>
<p>我实在想不到比那个堆栈更经典的例子了，以致于我还要引用别人的例子，下面的例子不是我想到的，是书上看到的，当然如果没有在书上看到，可能过一段时间我自己也想的到，可是那时我说是我自己想到的也没有人相信的。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Stack &#123;</span><br><span class="line">    private Object[] elements&#x3D;new Object[10];</span><br><span class="line">    private int size &#x3D; 0;</span><br><span class="line">    public void push(Object e)&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] &#x3D; e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object pop()&#123;</span><br><span class="line">        if( size &#x3D;&#x3D; 0) throw new EmptyStackException();</span><br><span class="line">        return elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ensureCapacity()&#123;</span><br><span class="line">        if(elements.length &#x3D;&#x3D; size)&#123;</span><br><span class="line">            Object[] oldElements &#x3D; elements;</span><br><span class="line">            elements &#x3D; new Object[2 * elements.length+1];</span><br><span class="line">            System.arraycopy(oldElements,0, elements, 0, size);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的原理应该很简单，假如堆栈加了 10 个元素，然后全部弹出来，虽然堆栈是空的，没有我们要的东西，但是这是个对象是无法回收的，这个才符合了内存泄露的两个条件：无用，无法回收。但是就是存在这样的东西也不一定会导致什么样的后果，如果这个堆栈用的比较少，也就浪费了几个K内存而已，反正我们的内存都上 G 了，哪里会有什么影响，再说这个东西很快就会被回收的，有什么关系。下面看两个例子。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Bad&#123;</span><br><span class="line">    public static Stack s&#x3D;Stack();</span><br><span class="line">    static&#123;</span><br><span class="line">        s.push(new Object());</span><br><span class="line">        s.pop(); &#x2F;&#x2F;这里有一个对象发生内存泄露</span><br><span class="line">        s.push(new Object()); &#x2F;&#x2F;上面的对象可以被回收了，等于是自愈了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为是 static，就一直存在到程序退出，但是我们也可以看到它有自愈功能，就是说如果你的 Stack 最多有 100 个对象，那么最多也就只有 100 个对象无法被回收其实这个应该很容易理解，Stack 内部持有 100 个引用，最坏的情况就是他们都是无用的，因为我们一旦放新的进取，以前的引用自然消失！  </p>
</blockquote>
<blockquote>
<p>内存泄露的另外一种情况：当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前对象，造成内存泄露。  </p>
</blockquote>
<p><strong>26. 深拷贝和浅拷贝。</strong></p>
<blockquote>
<p>简单来讲就是复制、克隆。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p&#x3D;new Person(“张三”);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>浅拷贝就是对对象中的数据成员进行简单赋值，如果存在动态成员或者指针就会报错。  </p>
</blockquote>
<blockquote>
<p>深拷贝就是对对象中存在的动态成员或指针重新开辟内存空间。  </p>
</blockquote>
<p><strong>27. System.gc() 和 Runtime.gc() 会做什么事情？</strong></p>
<blockquote>
<p>这两个方法用来提示 JVM 要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于 JVM 的。  </p>
</blockquote>
<p><strong>28. finalize() 方法什么时候被调用？析构函数 (finalization) 的目的是什么？</strong></p>
<blockquote>
<p>垃圾回收器（garbage colector）决定回收某对象时，就会运行该对象的 finalize() 方法 但是在 Java 中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说 filalize() 可能永远不被执行，显然指望它做收尾工作是靠不住的。 那么 finalize() 究竟是做什么的呢？ 它最主要的用途是回收特殊渠道申请的内存。Java 程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种 JNI（Java Native Interface）调用 non-­Java 程序（C 或 C++）， finalize() 的工作就是回收这部分的内存。  </p>
</blockquote>
<p><strong>29. 如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存？</strong></p>
<blockquote>
<p>不会，在下一个垃圾回收周期中，这个对象将是可被回收的。  </p>
</blockquote>
<p><strong>30. 什么是分布式垃圾回收（DGC）？它是如何工作的？</strong></p>
<blockquote>
<p>DGC 叫做分布式垃圾回收。RMI 使用 DGC 来做自动垃圾回收。因为 RMI 包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC 使用引用计数算法来给远程对象提供自动内存管理。  </p>
</blockquote>
<p><strong>31. 串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？</strong></p>
<blockquote>
<p>吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。 而串行收集器对大多数的小应用（在现代处理器上需要大概 100M 左右的内存）就足够了。  </p>
</blockquote>
<p><strong>32. 在 Java 中，对象什么时候可以被垃圾回收？</strong></p>
<blockquote>
<p>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。  </p>
</blockquote>
<p><strong>33. 简述 Java 内存分配与回收策率以及 Minor GC 和 Major GC。</strong></p>
<ul>
<li>对象优先在堆的 Eden 区分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象将直接进入老年代<blockquote>
<p>当 Eden 区没有足够的空间进行分配时，虚拟机会执行一次 Minor GC。Minor GC 通常发生在新生代的 Eden 区，在这个区的对象生存期短，往往发生 Gc 的频率较高，回收速度比较快；Full GC/Major GC 发生在老年代，一般情况下，触发老年代 GC 的时候不会触发 Minor GC，但是通过配置，可以在 Full GC 之前进行一次 Minor GC 这样可以加快老年代的回收速度。  </p>
</blockquote>
</li>
</ul>
<p><strong>34. JVM 的永久代中会发生垃圾回收么？</strong></p>
<blockquote>
<p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收（Full GC）。  </p>
</blockquote>
<blockquote>
<p>注：Java 8 中已经移除了永久代，新加了一个叫做元数据区的 native 内存区。  </p>
</blockquote>
<p><strong>35. Java 中垃圾收集的方法有哪些？</strong></p>
<blockquote>
<p>标记 - 清除：这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题：  </p>
</blockquote>
<ol>
<li>效率不高，标记和清除的效率都很低；</li>
<li>会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次 GC 动作。<blockquote>
<p>复制算法：为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。  </p>
</blockquote>
</li>
</ol>
<blockquote>
<p>于是将该算法进行了改进，内存区域不再是按照 1:1 去划分，而是将内存划分为 8:1:1 三部分，较大那份内存交 Eden 区，其余是两块较小的内存区叫 Survior 区。每次都会优先使用 Eden 区，若 Eden 区满，就将对象复制到第二块内存区上，然后清除 Eden 区，如果此时存活的对象太多，以至于 Survivor 不够时，会将这些对象通过分配担保机制复制到老年代中。（java 堆又分为新生代和老年代）  </p>
</blockquote>
<blockquote>
<p>标记 - 整理：该算法主要是为了解决标记 - 清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。  </p>
</blockquote>
<blockquote>
<p>分代收集：现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保。  </p>
</blockquote>
<p><strong>36. 什么是类加载器，类加载器有哪些？</strong></p>
<blockquote>
<p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。  </p>
</blockquote>
<blockquote>
<p>主要有一下四种类加载器：  </p>
</blockquote>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）用来加载 Java 核心类库，无法被 Java 程序直接引用。</li>
<li>扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</li>
<li>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader() 来获取它。</li>
<li>用户自定义类加载器，通过继承 java.lang.ClassLoader 类的方式实现。</li>
<li><em>37. 类加载器双亲委派模型机制？*</em></li>
</ul>
<blockquote>
<p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。  </p>
</blockquote>
<h3 id="Java-核心基础"><a href="#Java-核心基础" class="headerlink" title="Java 核心基础"></a>Java 核心基础</h3><p><strong>38. 一个 “.java” 源文件中是否可以包括多个类（不是内部类）？有什么限制？</strong></p>
<blockquote>
<p>可以有多个类，但只能有一个 public 的类，并且 public 的类名必须与文件名相一致。  </p>
</blockquote>
<p><strong>39. 说说 &amp; 和 &amp;&amp; 的区别。</strong></p>
<blockquote>
<p>&amp; 和 &amp;&amp; 都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为 true 时，整个运算结果才为 true，否则，只要有一方为 false，则结果为 false。  </p>
</blockquote>
<blockquote>
<p>&amp;&amp; 还具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式，例如，对于 if(str != null &amp;&amp; !str.equals(“”)) 表达式，当 str 为 null 时，后面的表达式不会执行，所以不会出现 NullPointerException 如果将 &amp;&amp; 改为 &amp;，则会抛出 NullPointerException 异常。If(x==33 &amp; ++y&gt;0) y 会增长，If(x==33 &amp;&amp; ++y&gt;0) 不会增长。  </p>
</blockquote>
<blockquote>
<p>&amp; 还可以用作位运算符，当 &amp; 操作符两边的表达式不是 boolean 类型时，&amp; 表示按位与操作，我们通常使用 0x0f 来与一个整数进行 &amp; 运算，来获取该整数的最低 4 个 bit 位，例如，0x31 &amp; 0x0f 的结果为 0x01。  </p>
</blockquote>
<blockquote>
<p>备注：这道题先说两者的共同点，再说出 &amp;&amp; 和 &amp; 的特殊之处，并列举一些经典的例子来表明自己理解透彻深入、实际经验丰富。  </p>
</blockquote>
<p><strong>40. 值传递和引用传递。</strong></p>
<blockquote>
<p>值传递是针对基本数据类型而言，传递的是值得副本，对副本的改变不会影响到原变量。  </p>
</blockquote>
<blockquote>
<p>引用传递就是将一个堆内存空间的使用权交给多个栈内存空间，每一个栈内存空间都可以对堆内存空间进行修改。  </p>
</blockquote>
<p><strong>41. 在 Java 中如何跳出当前的多重嵌套循环？</strong></p>
<blockquote>
<p>在 Java 中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的 break 语句，即可跳出外层循环。例如：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">  for(int j&#x3D;0;j&lt;10;j++)</span><br><span class="line">  &#123;</span><br><span class="line">      System.out.println(“i&#x3D;” + i + “,j&#x3D;” + j);</span><br><span class="line">      if(j &#x3D;&#x3D; 5) break ok;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外，我个人通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如，要在二维数组中查找到某个数字。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int arr[][] &#x3D; &#123;&#123;1,2,3&#125;,&#123;4,5,6,7&#125;,&#123;9&#125;&#125;;</span><br><span class="line">boolean found &#x3D; false;</span><br><span class="line">for(int i&#x3D;0;i&lt;arr.length &amp;&amp; !found;i++)</span><br><span class="line">  &#123;</span><br><span class="line">      for(int j&#x3D;0;j&lt;arr[i].length;j++)</span><br><span class="line">      &#123;</span><br><span class="line">          System.out.println(“i&#x3D;” + i + “,j&#x3D;” + j);</span><br><span class="line">          if(arr[i][j]  &#x3D;&#x3D; 5)</span><br><span class="line">          &#123;</span><br><span class="line">              found &#x3D; true;</span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>42. 访问修饰符 public,private,protected, 以及不写（默认）时的区别？</strong></p>
<blockquote>
<p>修饰符 当前类 同 包 子 类 其他包     public √ √ √ √   protected √ √ √ ×   Default √ √ × ×   private √ × × ×  </p>
</blockquote>
<p><strong>43. switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上?</strong></p>
<blockquote>
<p>在 switch（expr1）中，expr1 只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是 int 基本类型或 Integer 包装类型，由于，byte,short,char 都可以隐含转换为 int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long 和 String 类型都不符合 switch 的语法规定，并且不能被隐式转换成 int 类型，所以，它们不能作用于 swtich 语句中。  </p>
</blockquote>
<p><strong>44. char 型变量中能不能存贮一个中文汉字? 为什么?</strong></p>
<blockquote>
<p>char 型变量是用来存储 Unicode 编码的字符的，unicode 编码字符集中包含了汉字，所以，char 型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在 unicode 编码字符集中，那么，这个 char 型变量中就不能存储这个特殊汉字。补充说明：unicode 编码占用两个字节，所以，char 类型的变量也是占用两个字节。  </p>
</blockquote>
<blockquote>
<p>备注：后面一部分回答虽然不是在正面回答题目，但是，为了展现自己的学识和表现自己对问题理解的透彻深入，可以回答一些相关的知识，做到知无不言，言无不尽。  </p>
</blockquote>
<p><strong>45. 用最有效率的方法算出 2 乘以 8 等於几?</strong></p>
<blockquote>
<p>2 &lt;&lt; 3  </p>
</blockquote>
<blockquote>
<p>因为将一个数左移 n 位，就相当于乘以了 2 的 n 次方，那么，一个数乘以 8 只要将其左移 3 位即可，而位运算 cpu 直接支持的，效率最高，所以，2 乘以 8 等於几的最效率的方法是 2 &lt;&lt; 3。  </p>
</blockquote>
<p><strong>46. 使用 final 关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</strong></p>
<blockquote>
<p>使用 final 关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final StringBuffer a&#x3D;new StringBuffer(&quot;immutable&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行如下语句将报告编译期错误：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;new StringBuffer(&quot;&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是，执行如下语句则可以通过编译：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.append(&quot; broken!&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void method(final  StringBuffer  param)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">param.append(&quot;a&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>47. “==” 和 equals 方法究竟有什么区别？</strong></p>
<blockquote>
<p>（单独把一个东西说清楚，然后再说清楚另一个，这样，它们的区别自然就出来了，混在一起说，则很难说清楚）  </p>
</blockquote>
<blockquote>
<p>== 操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用 == 操作符。  </p>
</blockquote>
<blockquote>
<p>如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块内存（堆内存），变量也占用一块内存，例如 Objet obj = new Object(); 变量 obj 是一个内存，new Object() 是另一个内存，此时，变量 obj 所对应的内存中存储的数值就是对象占用的那块内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要看这两个变量所对应的内存中的数值是否相等，这时候就需要用 == 操作符进行比较。  </p>
</blockquote>
<blockquote>
<p>equals 方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。例如，对于下面的代码：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a&#x3D;new String(&quot;foo&quot;);</span><br><span class="line"></span><br><span class="line">String b&#x3D;new String(&quot;foo&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>两条 new 语句创建了两个对象，然后用 a,b 这两个变量分别指向了其中一个对象，这是两个不同的对象，它们的首地址是不同的，即 a 和 b 中存储的数值是不相同的，所以，表达式 a==b 将返回 false，而这两个对象中的内容是相同的，所以，表达式 a.equals(b) 将返回 true。  </p>
</blockquote>
<blockquote>
<p>在实际开发中，我们经常要比较传递进行来的字符串内容是否等，例如，String input = …;input.equals(“quit”)，许多人稍不注意就使用 == 进行比较了，这是错误的，随便从网上找几个项目实战的教学视频看看，里面就有大量这样的错误。记住，字符串的比较基本上都是使用 equals 方法。  </p>
</blockquote>
<blockquote>
<p>如果一个类没有自己定义 equals 方法，那么它将继承 Object 类的 equals 方法，Object 类的 equals 方法的实现代码如下：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boolean equals(Object o)&#123;</span><br><span class="line"></span><br><span class="line">return this&#x3D;&#x3D;o;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这说明，如果一个类没有自己定义 equals 方法，它默认的 equals 方法（从 Object 类继承的）就是使用 == 操作符，也是在比较两个变量指向的对象是否是同一对象，这时候使用 equals 和使用 == 会得到同样的结果，如果比较的是两个独立的对象则总返回 false。如果你编写的类希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖 equals 方法，由你自己写代码来决定在什么情况即可认为两个对象的内容是相同的。  </p>
</blockquote>
<p><strong>48. 静态变量和实例变量的区别？</strong></p>
<blockquote>
<p>在语法定义上的区别：静态变量前要加 static 关键字，而实例变量前则不加。  </p>
</blockquote>
<blockquote>
<p>在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个 <strong>实例变量</strong> 。静态变量不属于某个实例对象，而是属于类，所以也称为 <strong>类变量</strong> ，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。  </p>
</blockquote>
<blockquote>
<p>例如，对于下面的程序，无论创建多少个实例对象，永远都只分配了一个 staticVar 变量，并且每创建一个实例对象，这个 staticVar 就会加 1；但是，每创建一个实例对象，就会分配一个 instanceVar，即可能分配多个 instanceVar，并且每个 instanceVar 的值都只自加了 1 次。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class VariantTest&#123;</span><br><span class="line">    public static int staticVar &#x3D; 0;</span><br><span class="line">    public int instanceVar &#x3D; 0;</span><br><span class="line">    public VariantTest()</span><br><span class="line">    &#123;</span><br><span class="line">        staticVar++;</span><br><span class="line">        instanceVar++;</span><br><span class="line">      System.out.println(“staticVar&#x3D;” + staticVar + ”,instanceVar&#x3D;” + instanceVar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：这个解答除了说清楚两者的区别外，最后还用一个具体的应用例子来说明两者的差异，体现了自己有很好的解说问题和设计案例的能力，思维敏捷，超过一般程序员，有写作能力！  </p>
</blockquote>
<p><strong>49. 是否可以从一个 static 方法内部发出对非 static 方法的调用？</strong></p>
<blockquote>
<p>不可以。因为非 static 方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而 static 方法调用时不需要创建对象，可以直接调用。也就是说，当一个 static 方法被调用时，可能还没有创建任何实例对象，如果从一个 static 方法中发出对非 static 方法的调用，那个非 static 方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，不可以一个 static 方法内部发出对非 static 方法的调用。  </p>
</blockquote>
<p><strong>50. Math.round(11.5) 等于多少? Math.round(-11.5) 等于多少?</strong></p>
<blockquote>
<p>Math 类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英文名称的含义相对应，例如，ceil 的英文意义是天花板，该方法就表示向上取整，所以，Math.ceil(11.3)的结果为 12,Math.ceil(-11.3)的结果是 - 11；floor 的英文意义是地板，该方法就表示向下取整，所以，Math.floor(11.6)的结果为 11,Math.floor(-11.6)的结果是 - 12；最难掌握的是 round 方法，它表示 “四舍五入”，算法为 Math.floor(x+0.5)，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为 12，Math.round(-11.5)的结果为 - 11。  </p>
</blockquote>
<p><strong>51. Overload 和 Override 的区别。Overload 的方法是否可以改变返回值的类型?</strong></p>
<blockquote>
<p><strong>Overload</strong> 是重载的意思，Override 是覆盖的意思，也就是重写。  </p>
</blockquote>
<blockquote>
<p>重载 Overload 表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。  </p>
</blockquote>
<blockquote>
<p>重写 Override 表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是 private 类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。  </p>
</blockquote>
<blockquote>
<p>至于 Overloaded 的方法是否可以改变返回值的类型这个问题，要看你倒底想问什么呢？这个题目很模糊。如果几个 Overloaded 的方法的参数列表不一样，它们的返回者类型当然也可以不一样。但我估计你想问的问题是：如果两个方法的参数列表完全一样，是否可以让它们的返回值不同来实现重载 Overload。这是不行的，我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用 map.remove(key) 方法时，虽然 remove 方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java 就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。  </p>
</blockquote>
<blockquote>
<p><strong>override</strong> 可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意以下的几点：  </p>
</blockquote>
<ul>
<li><p>覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；</p>
</li>
<li><p>覆盖的方法的返回值必须和被覆盖的方法的返回一致；</p>
</li>
<li><p>覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；</p>
</li>
<li><p>被覆盖的方法不能为 private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。</p>
</li>
</ul>
<blockquote>
<p>overload 对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的方法，通过定义不同的输入参数来区分这些方法，然后再调用时，VM 就会根据不同的参数样式，来选择合适的方法执行。在使用重载要注意以下的几点：  </p>
</blockquote>
<ul>
<li><p>在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是 fun(int,float)，但是不能为 fun(int,int)）；</p>
</li>
<li><p>不能通过访问权限、返回类型、抛出的异常进行重载；</p>
</li>
<li><p>方法的异常类型和数目不会对重载造成影响；</p>
</li>
<li><p>对于继承来说，如果某一方法在父类中是访问权限是 priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。</p>
</li>
</ul>
<p><strong>52. ClassLoader 如何加载 class。</strong></p>
<blockquote>
<p>JVM 里有多个类加载，每个类加载可以负责加载特定位置的类，例如，bootstrap 类加载负责加载 jre/lib/rt.jar 中的类， 我们平时用的 jdk 中的类都位于 rt.jar 中。extclassloader 负责加载 jar/lib/ext/*.jar 中的类，appclassloader 负责 classpath 指定的目录或 jar 中的类。除了 bootstrap 之外，其他的类加载器本身也都是 java 类，它们的父类是 ClassLoader。  </p>
</blockquote>
<p><strong>53. 序列化接口的 id 有什么用？</strong></p>
<blockquote>
<p>对象经常要通过 IO 进行传送，让你写程序传递对象，你会怎么做？把对象的状态数据用某种格式写入到硬盘，Person-&gt;“zxx,male,28,30000”àPerson，既然大家都要这么干，并且没有个统一的干法，于是，sun 公司就提出一种统一的解决方案，它会把对象变成某个格式进行输入和输出，这种格式对程序员来说是透明（transparent）的，但是，我们的某个类要想能被 sun 的这种方案处理，必须实现 Serializable 接口。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream.writeObject(obj);</span><br><span class="line">Object obj &#x3D; ObjectInputStream.readObject();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>假设两年前我保存了某个类的一个对象，这两年来，我修改该类，删除了某个属性和增加了另外一个属性，两年后，我又去读取那个保存的对象，或有什么结果？未知！sun 的 jdk 就会蒙了。为此，一个解决办法就是在类中增加版本后，每一次类的属性修改，都应该把版本号升级一下，这样，在读取时，比较存储对象时的版本号与当前类的版本号，如果不一致，则直接报版本号不同的错!  </p>
</blockquote>
<p><strong>54. hashCode 方法的作用？</strong></p>
<blockquote>
<p>hashcode 这个方法是用来鉴定 2 个对象是否相等的。与 equals 方法功能类似，但是有区别。一般来讲，equals 这个方法是给用户调用的，如果你想判断 2 个对象是否相等，你可以重写 equals 方法，然后在代码中调用，就可以判断他们是否相等了。简单来讲，equals 方法主要是用来判断从表面上看或者从内容上看，2 个对象是不是相等。举个例子，有个学生类，属性只有姓名和性别，那么我们可以认为只要姓名和性别相等，那么就说这 2 个对象是相等的。  </p>
</blockquote>
<blockquote>
<p>hashcode 方法一般用户不会去调用，比如在 hashmap 中，由于 key 是不可以重复的，他在判断 key 是不是重复的时候就判断了 hashcode 这个方法，而且也用到了 equals 方法。这里不可以重复是说 equals 和 hashcode 只要有一个不等就可以了！所以简单来讲，hashcode 相当于是一个对象的编码，就好像文件中的 md5，他和 equals 不同就在于他返回的是 int 型的，比较起来不直观。我们一般在覆盖 equals 的同时也要覆盖 hashcode，让他们的逻辑一致。举个例子，还是刚刚的例子，如果姓名和性别相等就算 2 个对象相等的话，那么 hashcode 的方法也要返回姓名的 hashcode 值加上性别的 hashcode 值，这样从逻辑上，他们就一致了。  </p>
</blockquote>
<p><strong>55. 构造器 Constructor 是否可被 override?</strong></p>
<blockquote>
<p>构造器 Constructor 不能被继承，因此不能重写 Override，但可以被重载 Overload。  </p>
</blockquote>
<p><strong>56. 接口是否可继承接口? 抽象类是否可实现 (implements) 接口? 抽象类是否可继承具体类(concrete class)? 抽象类中是否可以有静态的 main 方法？</strong></p>
<blockquote>
<p>接口可以继承接口。抽象类可以实现 (implements) 接口，抽象类可继承具体类。抽象类中可以有静态的 main 方法。  </p>
</blockquote>
<blockquote>
<p>备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想想，如果你是 java 语言的设计者，你是否会提供这样的支持，如果不提供的话，有什么理由吗？如果你没有道理不提供，那答案就是肯定的了。  </p>
</blockquote>
<blockquote>
<p>只有记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有 abstract 方法。  </p>
</blockquote>
<p><strong>57. Java 中实现多态的机制是什么？</strong></p>
<blockquote>
<p>靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。  </p>
</blockquote>
<p><strong>58. abstract class 和 interface 有什么区别?</strong></p>
<blockquote>
<p>含有 abstract 修饰符的 class 即为抽象类，abstract 类不能创建的实例对象。含有 abstract 方法的类必须定义为 abstract class，abstract class 类中的方法不必是抽象的。abstract class 类中定义抽象方法必须在具体 (Concrete) 子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为 abstract 类型。  </p>
</blockquote>
<blockquote>
<p>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为 public abstract 类型，接口中的成员变量类型默认为 public static final。  </p>
</blockquote>
<blockquote>
<p>下面比较一下两者的语法区别：  </p>
</blockquote>
<ul>
<li><p>抽象类可以有构造方法，接口中不能有构造方法。</p>
</li>
<li><p>抽象类中可以有普通成员变量，接口中没有普通成员变量</p>
</li>
<li><p>抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</p>
</li>
<li><p>抽象类中的抽象方法的访问类型可以是 public，protected 和（默认类型, 虽然 eclipse 下不报错，但应该也不行），但接口中的抽象方法只能是 public 类型的，并且默认即为 public abstract 类型。</p>
</li>
<li><p>抽象类中可以包含静态方法，接口中不能包含静态方法</p>
</li>
<li><p>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是 public static final 类型，并且默认即为 public static final 类型。</p>
</li>
<li><p>一个类可以实现多个接口，但只能继承一个抽象类。</p>
</li>
</ul>
<blockquote>
<p>下面接着再说说两者在应用上的区别：**  </p>
</blockquote>
<blockquote>
<p>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有 Servlet 类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的 Servlet 都继承这个抽象基类，在抽象基类的 service 方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码，伪代码如下：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public abstract class BaseServlet extends HttpServlet&#123;</span><br><span class="line">    public final void service(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException&#123;</span><br><span class="line">        &#x2F;&#x2F;记录访问日志</span><br><span class="line">        &#x2F;&#x2F;进行权限判断</span><br><span class="line">        if(具有权限)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">              doService(request,response);</span><br><span class="line">            &#125;catch(Excetpion e)&#123;</span><br><span class="line">              &#x2F;&#x2F;记录异常信息</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;   </span><br><span class="line">  &#125;</span><br><span class="line">  protected abstract void doService(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException;  </span><br><span class="line">  &#x2F;&#x2F;注意访问权限定义成protected，显得既专业，又严谨，因为它是专门给子类用的</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyServlet1 extends BaseServlet&#123;</span><br><span class="line">    protected void doService(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException&#123;</span><br><span class="line">    &#x2F;&#x2F;本Servlet只处理的具体业务逻辑代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。  </p>
</blockquote>
<blockquote>
<p>备注：这道题的思路是先从总体解释抽象类和接口的基本概念，然后再比较两者的语法细节，最后再说两者的应用区别。比较两者语法细节区别的条理是：先从一个类中的构造方法、普通成员变量和方法（包括抽象方法），静态变量和方法，继承性等 6 个方面逐一去比较回答，接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功底。  </p>
</blockquote>
<p><strong>59. abstract 的 method 是否可同时是 static, 是否可同时是 native，是否可同时是 synchronized?</strong></p>
<blockquote>
<p>abstract 的 method 不可以是 static 的，因为抽象的方法是要被子类实现的，而 static 与子类扯不上关系。  </p>
</blockquote>
<blockquote>
<p>native 方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与 abstract 混用。例如，FileOutputSteam 类要硬件打交道，底层的实现用的是操作系统相关的 api 实现，例如，在 windows 用 c 语言实现的，所以，查看 jdk 的源代码，可以发现 FileOutputStream 的 open 方法的定义如下：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private native void open(String name) throws FileNotFoundException;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果我们要用 java 调用别人写的 c 语言函数，我们是无法直接调用的，我们需要按照 java 的要求写一个 c 语言的函数，又我们的这个 c 语言函数去调用别人的 c 语言函数。由于我们的 c 语言函数是按 java 的要求来写的，我们这个 c 语言函数就可以与 java 对接上，java 那边的对接方式就是定义出与我们这个 c 函数相对应的方法，java 中对应的方法不需要写具体的代码，但需要在前面声明 native。  </p>
</blockquote>
<blockquote>
<p>关于 synchronized 与 abstract 合用的问题，我觉得也不行，因为在我几年的学习和开发中，从来没见到过这种情况，并且我觉得 synchronized 应该是作用在一个具体的方法上才有意义。而且，方法上的 synchronized 同步所使用的同步锁对象是 this，而抽象方法上无法确定 this 是什么。  </p>
</blockquote>
<p><strong>60. 什么是内部类？Static Nested Class 和 Inner Class 的不同。</strong></p>
<blockquote>
<p>内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。我想可能是既然静态成员类似 c 语言的全局变量，而内部类通常是用于创建内部对象用的，所以，把 “全局变量” 放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中，代码如下：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Outer&#123;</span><br><span class="line">    int out_x  &#x3D; 0;</span><br><span class="line">    public void method()&#123;</span><br><span class="line">        Inner1 inner1 &#x3D; new Inner1();</span><br><span class="line">        &#x2F;&#x2F;在方法体内部定义的内部类</span><br><span class="line">        class Inner2</span><br><span class="line">        &#123;</span><br><span class="line">            public void method() &#123;</span><br><span class="line">                out_x &#x3D; 3;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner2 inner2 &#x3D; new Inner2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;在方法体外面定义的内部类</span><br><span class="line">    public class Inner1 &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在方法体外面定义的内部类的访问类型可以是 public,protecte, 默认的，private 等 4 种类型，这就好像类中定义的成员变量有 4 种访问类型一样，它们决定这个内部类的定义对其他类是否可见；对于这种情况，我们也可以在外面创建内部类的实例对象，创建内部类的实例对象时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象，代码如下：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outer outer &#x3D; new Outer();</span><br><span class="line">Outer.Inner1 inner1 &#x3D; outer.new Innner1();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样，但这种内部类的前面可以使用 final 或 abstract 修饰符。这种内部类对其他类是不可见的其他类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但是，该局部变量前必须加 final 修饰符。  </p>
</blockquote>
<blockquote>
<p>对于这些细节，只要在 eclipse 写代码试试，根据开发工具提示的各类错误信息就可以马上了解到。  </p>
</blockquote>
<blockquote>
<p>在方法体内部还可以采用如下语法来创建一种匿名内部类，即定义某一接口或类的子类的同时，还创建了该子类的实例对象，无需为该子类定义名称：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">    public void start()&#123;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最后，在方法外部定义的内部类前面可以加上 static 关键字，从而成为 Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static Nested Class 与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成 public、protected、默认的、private 等多种类型，而普通类只能定义成 public 和默认的这两种类型。在外面引用 Static Nested Class 类的名称为 “外部类名. 内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建 Static Nested Class，例如，假设 Inner 是定义在 Outer 类中的 Static Nested Class，那么可以使用如下语句创建 Inner 类：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer.Inner inner &#x3D; new Outer.Inner();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于 static Nested Class 不依赖于外部类的实例对象，所以，static Nested Class 能访问外部类的非 static 成员变量。当在外部类中访问 Static Nested Class 时，可以直接使用 Static Nested Class 的名字，而不需要加上外部类的名字了，在 Static Nested Class 中也可以直接引用外部类的 static 的成员变量，不需要加上外部类的名字。  </p>
</blockquote>
<blockquote>
<p>在静态方法中定义的内部类也是 Static Nested Class，这时候不能在类前面加 static 关键字，静态方法中的 Static Nested Class 与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的 static 的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加 final 修饰符。  </p>
</blockquote>
<blockquote>
<p>备注：首先根据你的印象说出你对内部类的总体方面的特点：例如，在两个地方可以定义，可以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。  </p>
</blockquote>
<p><strong>61. String s = “Hello”;s = s + “world!”; 这两行代码执行后，原始的 String 对象中的内容到底变了没有？</strong></p>
<blockquote>
<p>没有。因为 String 被设计成不可变 (immutable) 类，所以它的所有对象都是不可变对象。在这段代码中，s 原先指向一个 String 对象，内容是 “Hello”，然后我们对 s 进行了 + 操作，那么 s 所指向的那个对象是否发生了改变呢？答案是没有。这时，s 不指向原来那个对象了，而指向了另一个 String 对象，内容为 “Hello world!”，原来那个对象还存在于内存之中，只是 s 这个引用变量不再指向它了。  </p>
</blockquote>
<blockquote>
<p>通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用 String 来代表字符串的话会引起很大的内存开销。因为 String 对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个 String 对象来表示。这时，应该考虑使用 StringBuffer 类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。  </p>
</blockquote>
<blockquote>
<p>同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都 new 一个 String。例如我们要在构造器中对一个名叫 s 的 String 引用变量进行初始化，把它设置为初始值，应当这样做：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    private String s;</span><br><span class="line">    ...</span><br><span class="line">    public Demo &#123;</span><br><span class="line">      s &#x3D; &quot;Initial Value&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为 String 对象不可改变，所以对于内容相同的字符串，只要一个 String 对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他们的 String 类型属性 s 都指向同一个对象。 上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java 认为它们代表同一个 String 对象。而用关键字 new 调用构造器，总是会创建一个新的对象，无论内容是否相同。  </p>
</blockquote>
<blockquote>
<p>至于为什么要把 String 类设计成不可变类，是它的用途决定的。其实不只 String，很多 Java 标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。所以 Java 标准类库还提供了一个可变版本，即 StringBuffer。  </p>
</blockquote>
<p><strong>62. String s = new String(“xyz”); 创建了几个 String Object? 二者之间有什么区别？</strong></p>
<blockquote>
<p>两个对象，”xyz” 对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz” 不管出现多少遍，都是缓冲区中的那一个。New String 每写一遍，就创建一个新的对象，它一句那个常量”xyz” 对象的内容来创建出一个新 String 对象。如果以前就用过’xyz’，这句代表就不会创建”xyz” 自己了，直接从缓冲区拿。  </p>
</blockquote>
<p><strong>63. StringBuffer 与 StringBuilder 的区别。</strong></p>
<blockquote>
<p>StringBuffer 和 StringBuilder 类都表示内容可以被修改的字符串， <strong>StringBuilder</strong> 是 <strong>线程不安全的，运行效率高</strong> ，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用 StringBuilder。如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用 StringBuffer。  </p>
</blockquote>
<p><strong>64. final,finally, finalize 的区别。</strong></p>
<ul>
<li><p>final 用于声明 <strong>属性，方法和类</strong> ，分别表示属性不可变，方法不可覆盖，类不可继承。 内部类要访问局部变量，局部变量必须定义成 final 类型。</p>
</li>
<li><p>finally 是 <strong>异常处理语句结构</strong> 的一部分，表示总是执行。</p>
</li>
<li><p>finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM 不保证此方法总被调用。</p>
</li>
</ul>
<p><strong>65. Java 中的异常处理机制的简单原理和应用。</strong></p>
<blockquote>
<p>异常是指 java 程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很相似，现实生活中的事件可以包含事件发生的时间、地点、人物、情节等信息，可以用一个对象来表示，Java 使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。  </p>
</blockquote>
<blockquote>
<p>Java 对异常进行了分类，不同类型的异常分别用不同的 Java 类表示，所有异常的根类为 java.lang.Throwable，Throwable 下面又派生了两个子类：Error 和 Exception，Error 表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程死锁等系统问题。Exception 表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）；普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。  </p>
</blockquote>
<blockquote>
<p>Java 为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须 try..catch 处理或用 throws 声明继续抛给上层调用方法处理，所以普通异常也称为 checked 异常，而系统异常可以处理也可以不处理，所以，编译器不强制用 try..catch 处理或用 throws 声明，所以系统异常也称为 unchecked 异常。  </p>
</blockquote>
<blockquote>
<p>提示答题者：就按照三个级别去思考：虚拟机必须宕机的错误，程序可以死掉也可以不死掉的错误，程序不应该死掉的错误。  </p>
</blockquote>
<h3 id="多线程-高并发"><a href="#多线程-高并发" class="headerlink" title="多线程 / 高并发"></a>多线程 / 高并发</h3><p><strong>66. stop() 和 suspend() 方法为何不推荐使用？</strong></p>
<blockquote>
<p><strong>反对使用 stop()，是因为它不安全</strong> 。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。  </p>
</blockquote>
<blockquote>
<p><strong>suspend() 方法容易发生死锁</strong> 。调用 suspend() 的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被 “挂起” 的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用 suspend()，而应在自己的 Thread 类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用 wait() 命其进入等待状态。若标志指出线程应当恢复，则用一个 notify() 重新启动线程。  </p>
</blockquote>
<p><strong>67. sleep() 和 wait() 有什么区别?</strong></p>
<blockquote>
<p>sleep 就是正在执行的线程主动让出 cpu，cpu 去执行其他线程，在 sleep 指定的时间过后，cpu 才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep 方法并不会释放锁，即使当前线程使用 sleep 方法让出了 cpu，但其他被同步锁挡住了的线程也无法得到执行。wait 是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了 notify 方法（notify 并不释放锁，只是告诉调用过 wait 方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果 notify 方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在 notfiy 方法后增加一个等待和一些代码，看看效果），调用 wait 方法的线程就会解除 wait 状态和程序可以再次得到锁后继续向下运行。  </p>
</blockquote>
<p><strong>68. 同步和异步有何异同，在什么情况下分别使用他们？</strong></p>
<blockquote>
<p>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。  </p>
</blockquote>
<blockquote>
<p>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。  </p>
</blockquote>
<p><strong>69. 当一个线程进入一个对象的一个 synchronized 方法后，其它线程是否可进入此对象的其它方法?</strong></p>
<ul>
<li><p>其他方法前是否加了 synchronized 关键字，如果没加，则能。</p>
</li>
<li><p>如果这个方法内部调用了 wait，则可以进入其他 synchronized 方法。</p>
</li>
<li><p>如果其他个方法都加了 synchronized 关键字，并且内部没有调用 wait，则不能。</p>
</li>
<li><p>如果其他方法是 static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是 this。</p>
</li>
</ul>
<p><strong>70. 简述 synchronized 和 java.util.concurrent.locks.Lock 的异同？</strong></p>
<blockquote>
<p>主要相同点：Lock 能完成 synchronized 所实现的所有功能。  </p>
</blockquote>
<blockquote>
<p>主要不同点：Lock 有比 synchronized 更精确的线程语义和更好的性能。synchronized 会自动释放锁，而 Lock 一定要求程序员手工释放，并且必须在 finally 从句中释放。Lock 还有更强大的功能，例如，它的 tryLock 方法可以非阻塞方式去拿锁。  </p>
</blockquote>
<blockquote>
<p>举例说明（对下面的题用 lock 进行了改写）  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class ThreadTest &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * @param args</span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">  private int j;</span><br><span class="line">  private Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">      ThreadTest tt &#x3D; new ThreadTest();</span><br><span class="line">      for(int i&#x3D;0;i&lt;2;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          new Thread(tt.new Adder()).start();</span><br><span class="line">          new Thread(tt.new Subtractor()).start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private class Subtractor implements Runnable</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">          while(true)</span><br><span class="line">          &#123;</span><br><span class="line">              &#x2F;*synchronized (ThreadTest.this) &#123;          </span><br><span class="line">                  System.out.println(&quot;j--&#x3D;&quot; + j--);</span><br><span class="line">                  &#x2F;&#x2F;这里抛异常了，锁能释放吗？</span><br><span class="line">              &#125;*&#x2F;</span><br><span class="line">              lock.lock();</span><br><span class="line">              try</span><br><span class="line">              &#123;</span><br><span class="line">                  System.out.println(&quot;j--&#x3D;&quot; + j--);</span><br><span class="line">              &#125;finally</span><br><span class="line">              &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private class Adder implements Runnable</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">          while(true)</span><br><span class="line">          &#123;</span><br><span class="line">              &#x2F;*synchronized (ThreadTest.this) &#123;</span><br><span class="line">              System.out.println(&quot;j++&#x3D;&quot; + j++);   </span><br><span class="line">              &#125;*&#x2F;</span><br><span class="line">              lock.lock();</span><br><span class="line">              try</span><br><span class="line">              &#123;</span><br><span class="line">                  System.out.println(&quot;j++&#x3D;&quot; + j++);</span><br><span class="line">              &#125;finally</span><br><span class="line">              &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">              &#125;               </span><br><span class="line">          &#125;           </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>71. 概括的解释下线程的几种可用状态。</strong></p>
<ul>
<li><p>新建 new。</p>
</li>
<li><p>就绪 放在可运行线程池中，等待被线程调度选中，获取 cpu。</p>
</li>
<li><p>运行 获得了 cpu。</p>
</li>
<li><p>阻塞</p>
<ul>
<li>等待阻塞 执行 wait() 。</li>
<li>同步阻塞 获取对象的同步琐时，同步锁被别的线程占用。</li>
<li>其他阻塞 执行了 sleep() 或 join() 方法)。</li>
</ul>
</li>
<li><p>死亡。</p>
</li>
</ul>
<p><strong>72. 什么是 ThreadLocal?</strong></p>
<blockquote>
<p>ThreadLocal 用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择 ThreadLocal 变量。  </p>
</blockquote>
<blockquote>
<p>每个线程都会拥有他们自己的 Thread 变量，它们可以使用 get()\set() 方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal 实例通常是希望它们同线程状态关联起来是 private static 属性。  </p>
</blockquote>
<p><strong>73. run() 和 start() 区别。</strong></p>
<blockquote>
<p><strong>run( )：</strong> 只是调用普通 run 方法  </p>
</blockquote>
<blockquote>
<p><strong>start( )：</strong> 启动了线程, 由 Jvm 调用 run 方法  </p>
</blockquote>
<blockquote>
<p>启动一个线程是调用 start() 方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由 JVM 调度并执行。这并不意味着线程就会立即运行。run() 方法可以产生必须退出的标志来停止一个线程。  </p>
</blockquote>
<p><strong>74. 请说出你所知道的线程同步的方法。</strong></p>
<blockquote>
<p><strong>wait()：</strong> 使一个线程处于等待状态，并且释放所持有的对象的 lock。 <strong>sleep()：</strong> 使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉 InterruptedException 异常。 <strong>notify()：</strong> 唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且不是按优先级。 <strong>notityAll()：</strong> 唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。  </p>
</blockquote>
<p><strong>75. 线程调度和线程控制。</strong></p>
<blockquote>
<p>线程调度（优先级）:  </p>
</blockquote>
<blockquote>
<p>与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取 CPU 资源的概率较大，优先级低的并非没机会执行。 线程的优先级用 1-10 之间的整数表示，数值越大优先级越高，默认的优先级为 5。 在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。  </p>
</blockquote>
<blockquote>
<p><strong>线程控制</strong>  </p>
</blockquote>
<ul>
<li><p><strong>sleep( )</strong> // 线程休眠 <strong>join( )</strong> // 线程加入 <strong>yield( )</strong> // 线程礼让 <strong>setDaemon( )</strong> // 线程守护</p>
<blockquote>
<p><strong>中断线程</strong>  </p>
</blockquote>
</li>
<li><p><strong>stop( )</strong> <strong>interrupt( )</strong> ==(首先选用)==</p>
</li>
<li><p><em>76. 什么是线程饿死，什么是活锁？*</em></p>
</li>
</ul>
<blockquote>
<p>当所有线程阻塞，或者由于需要的资源无效而不能处理，不存在非阻塞线程使资源可用。JavaAPI 中线程活锁可能发生在以下情形：  </p>
</blockquote>
<ul>
<li><p>当所有线程在序中执行 Object.wait(0)，参数为 0 的 wait 方法。程序将发生活锁直到在相应的对象上有线程调用 Object.notify() 或者 Object.notifyAll()。</p>
</li>
<li><p>当所有线程卡在无限循环中。</p>
</li>
</ul>
<p><strong>77. 多线程中的忙循环是什么?</strong></p>
<blockquote>
<p>忙循环就是程序员用循环让一个线程等待，不像传统方法 wait(), sleep() 或 yield() 它们都放弃了 CPU 控制，而忙循环不会放弃 CPU，它就是在运行一个空循环。这么做的目的是为了保留 CPU 缓存。  </p>
</blockquote>
<blockquote>
<p>在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。  </p>
</blockquote>
<p><strong>78. volatile 变量是什么？volatile 变量和 atomic 变量有什么不同？</strong></p>
<blockquote>
<p>volatile 则是保证了所修饰的变量的可见。因为 volatile 只是在保证了同一个变量在多线程中的可见性，所以它更多是用于修饰作为开关状态的变量，即 Boolean 类型的变量。  </p>
</blockquote>
<blockquote>
<p>volatile 多用于修饰类似开关类型的变量、Atomic 多用于类似计数器相关的变量、其它多线程并发操作用 synchronized 关键字修饰。  </p>
</blockquote>
<blockquote>
<p><strong>volatile 有两个功用</strong> ：  </p>
</blockquote>
<ul>
<li><p>这个变量不会在多个线程中存在复本，直接从内存读取。</p>
</li>
<li><p>这个关键字会禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。</p>
</li>
</ul>
<p><strong>79. volatile 类型变量提供什么保证？能使得一个非原子操作变成原子操作吗？</strong></p>
<blockquote>
<p>volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。  </p>
</blockquote>
<blockquote>
<p>在 Java 中除了 long 和 double 之外的所有基本类型的读和赋值，都是原子性操作。而 64 位的 long 和 double 变量由于会被 JVM 当作两个分离的 32 位来进行操作，所以不具有原子性，会产生字撕裂问题。但是当你定义 long 或 double 变量时，如果使用 volatile 关键字，就会获到（简单的赋值与返回操作的）原子性。  </p>
</blockquote>
<h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><p><strong>80. ArrayList 和 Vector 的区别。</strong></p>
<blockquote>
<p>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，并且其中的数据是允许重复的，这是 HashSet 之类的集合的最大不同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素（本来题目问的与 hashset 没有任何关系，但为了说清楚 ArrayList 与 Vector 的功能，我们使用对比方式，更有利于说明问题）。接着才说 ArrayList 与 Vector 的区别，这主要包括两个方面。  </p>
</blockquote>
<ul>
<li>同步性：<blockquote>
<p>Vector 是线程安全的，也就是说是它的方法之间是线程同步的，而 ArrayList 是线程序不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用 ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。  </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>备注：对于 Vector&amp;ArrayList、Hashtable&amp;HashMap，要记住线程安全的问题，记住 Vector 与 Hashtable 是旧的，是 java 一诞生就提供了的，它们是线程安全的，ArrayList 与 HashMap 是 java2 时才提供的，它们是线程不安全的。所以，我们讲课时先讲老的。  </p>
</blockquote>
<ul>
<li>数据增长：<blockquote>
<p>ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加 ArrayList 与 Vector 的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector 默认增长为原来两倍，而 ArrayList 的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的 1.5 倍）。ArrayList 与 Vector 都可以设置初始的空间大小，Vector 还可以设置增长的空间大小，而 ArrayList 没有提供设置增长空间的方法。  </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>总结：即 Vector 增长原来的一倍，ArrayList 增加原来的 0.5 倍。  </p>
</blockquote>
<p><strong>81. 说说 ArrayList,Vector, LinkedList 的存储性能和特性。</strong></p>
<blockquote>
<p>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 由于使用了 synchronized 方法（线程安全）。  </p>
</blockquote>
<blockquote>
<p>通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快 。  </p>
</blockquote>
<blockquote>
<p>ArrayList 在查找时速度快，LinkedList 在插入与删除时更具优势。  </p>
</blockquote>
<p><strong>83. 快速失败 (fail-­fast) 和安全失败 (fail-­safe) 的区别是什么？</strong></p>
<blockquote>
<p>Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util 包下面的所有的集合类都是快速失败的，而 java.util.concurrent 包下面的所有的类都是安全失败的。快速失败的迭代器会抛出 ConcurrentModificationException 异常，而安全失败的迭代器永远不会抛出这样的异常。  </p>
</blockquote>
<p><strong>84. hashmap 的数据结构。</strong></p>
<blockquote>
<p>在 java 编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，hashmap 也不例外。Hashmap 实际上是一个数组和链表的结合体（在数据结构中，一般称之为 “链表散列 “）  </p>
</blockquote>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//upload-images.jianshu.io/upload_images/127268-da2e47d551af3f54?imageMogr2/auto-orient/strip%257CimageView2/2/w/576/format/webp" alt=""></p>
<blockquote>
<p>enter image description here  </p>
</blockquote>
<p><strong>85. HashMap 的工作原理是什么?</strong></p>
<blockquote>
<p>Java 中的 HashMap 是以键值对 (key-­value) 的形式存储元素的。HashMap 需要一个 hash 函数，它使用 hashCode()和 equals()方法来向集合 / 从集合添加和检索元素。当调用 put() 方法的时候，HashMap 会计算 key 的 hash 值，然后把键值对存储在集合中合适的索引上。 如果 key 已经存在了，value 会被更新成新值。HashMap 的一些重要的特性是它的容量 (capacity)，负载因子 (load factor) 和扩容极限(threshold resizing)。  </p>
</blockquote>
<p><strong>86. Hashmap 什么时候进行扩容呢？</strong></p>
<blockquote>
<p>当 hashmap 中的元素个数超过数组大小 loadFactor 时，就会进行数组扩容，loadFactor 的默认值为 0.75，也就是说，默认情况下，数组大小为 16，那么当 hashmap 中元素个数超过 16 <em>0.75=12 的时候，就把数组的大小扩展为 2</em> 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知 hashmap 中元素的个数，那么预设元素的个数能够有效的提高 hashmap 的性能。比如说，我们有 1000 个元素 new HashMap(1000), 但是理论上来讲 new HashMap(1024) 更合适，不过上面 annegu 已经说过，即使是 1000，hashmap 也自动会将其设置为 1024。 但是 new HashMap(1024) 还不是更合适的，因为 0.75*1000 &lt; 1000, 也就是说为了让 0.75 * size &gt; 1000, 我们必须这样 new HashMap(2048) 才最合适，既考虑了 &amp; 的问题，也避免了 resize 的问题。  </p>
</blockquote>
<p><strong>87. List、Map、Set 三个接口，存取元素时，各有什么特点？</strong></p>
<blockquote>
<p>这样的题属于随意发挥题：这样的题比较考水平，两个方面的水平：一是要真正明白这些内容，二是要有较强的总结和表述能力。如果你明白，但表述不清楚，在别人那里则等同于不明白。  </p>
</blockquote>
<blockquote>
<p>首先，List 与 Set 具有相似性，它们都是单列元素的集合，所以，它们有一个功共同的父接口，叫 Collection。Set 里面不允许有重复的元素，所谓重复，即不能有两个相等（注意，不是仅仅是相同）的对象 ，即假设 Set 集合中有了一个 A 对象，现在我要向 Set 集合再存入一个 B 对象，但 B 对象与 A 对象 equals 相等，则 B 对象存储不进去，所以，Set 集合的 add 方法有一个 boolean 的返回值，当集合中没有某个元素，此时 add 方法可成功加入该元素时，则返回 true，当集合含有与某个元素 equals 相等的元素时，此时 add 方法无法加入该元素，返回结果为 false。Set 取元素时，没法说取第几个，只能以 Iterator 接口取得所有的元素，再逐一遍历各个元素。  </p>
</blockquote>
<blockquote>
<p>List 表示有先后顺序的集合， 注意，不是那种按年龄、按大小、按价格之类的排序。当我们多次调用 add(Obj e) 方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来后到的顺序排序。有时候，也可以插队，即调用 add(int index,Obj e) 方法，就可以指定当前对象在集合中的存放位置。一个对象可以被反复存储进 List 中，每调用一次 add 方法，这个对象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被 add 多次时，即相当于集合中有多个索引指向了这个对象，如图 x 所示。List 除了可以以 Iterator 接口取得所有的元素，再逐一遍历各个元素之外，还可以调用 get(index i) 来明确说明取第几个。  </p>
</blockquote>
<blockquote>
<p>Map 与 List 和 Set 不同，它是双列的集合，其中有 put 方法，定义如下：put(obj key,obj value)，每次存储时，要存储一对 key/value，不能存储重复的 key，这个重复的规则也是按 equals 比较相等。取则可以根据 key 获得相应的 value，即 get(Object key) 返回值为 key 所对应的 value。另外，也可以获得所有的 key 的结合，还可以获得所有的 value 的结合，还可以获得 key 和 value 组合成的 Map.Entry 对象的集合。  </p>
</blockquote>
<blockquote>
<p>List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素, 内部排序。Map 保存 key-value 值，value 可多值。  </p>
</blockquote>
<blockquote>
<p>HashSet 按照 hashcode 值的某种运算方式进行存储，而不是直接按 hashCode 值的大小进行存储。例如，”abc” —&gt; 78，”def” —&gt; 62，”xyz” —&gt; 65 在 hashSet 中的存储顺序不是 62,65,78，这些问题感谢以前一个叫崔健的学员提出，最后通过查看源代码给他解释清楚，看本次培训学员当中有多少能看懂源码。LinkedHashSet 按插入的顺序存储，那被存储对象的 hashcode 方法还有什么作用呢？学员想想! hashset 集合比较两个对象是否相等，首先看 hashcode 方法是否相等，然后看 equals 方法是否相等。new 两个 Student 插入到 HashSet 中，看 HashSet 的 size，实现 hashcode 和 equals 方法后再看 size。  </p>
</blockquote>
<blockquote>
<p>同一个对象可以在 Vector 中加入多次。往集合里面加元素，相当于集合里用一根绳子连接到了目标对象。往 HashSet 中却加不了多次的。  </p>
</blockquote>
<p><strong>88. Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用 == 还是 equals()? 它们有何区别?</strong></p>
<blockquote>
<p>Set 里的元素是不能重复的，元素重复与否是使用 equals() 方法进行判断的。  </p>
</blockquote>
<blockquote>
<p>equals() 和 == 方法决定引用值是否指向同一对象 equals() 在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。  </p>
</blockquote>
<p><strong>89. 两个对象值相同 (x.equals(y) == true)，但却可有不同的 hash code，这句话对不对?</strong></p>
<blockquote>
<p>对。如果对象要保存在 HashSet 或 HashMap 中，它们的 equals 相等，那么，它们的 hashcode 值就必须相等。  </p>
</blockquote>
<blockquote>
<p>如果不是要保存在 HashSet 或 HashMap，则与 hashcode 没有什么关系了，这时候 hashcode 不等是可以的，例如 arrayList 存储的对象就不用实现 hashcode，当然，我们没有理由不实现，通常都会去实现的。  </p>
</blockquote>
<p><strong>90. heap 和 stack 有什么区别。</strong></p>
<blockquote>
<p>Java 的内存分为两类，一类是 <strong>栈内存</strong> ，一类是 <strong>堆内存</strong> 。栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。  </p>
</blockquote>
<blockquote>
<p>堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用 new 创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用 final 修饰后，放在堆中，而不是栈中。  </p>
</blockquote>
<p><strong>91. Java 集合类框架的基本接口有哪些？</strong></p>
<blockquote>
<p>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它 自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。  </p>
</blockquote>
<blockquote>
<p>Java 集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java 集合类里面 最基本的接口有：  </p>
</blockquote>
<blockquote>
<p><strong>Collection：</strong> 代表一组对象，每一个对象都是它的子元素。  </p>
</blockquote>
<blockquote>
<p><strong>Set：</strong> 不包含重复元素的 Collection。  </p>
</blockquote>
<blockquote>
<p><strong>List：</strong> 有顺序的 collection，并且可以包含重复元素。  </p>
</blockquote>
<blockquote>
<p><strong>Map：</strong> 可以把键 (key) 映射到值 (value) 的对象，键不能重复。  </p>
</blockquote>
<p><strong>92. HashSet 和 TreeSet 有什么区别？</strong></p>
<blockquote>
<p>HashSet 是由一个 hash 表来实现的，因此，它的元素是无序的。add()，remove()，contains()  </p>
</blockquote>
<blockquote>
<p>TreeSet 是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()， remove()，contains() 方法的时间复杂度是 O(logn)。  </p>
</blockquote>
<p><strong>93. HashSet 的底层实现是什么?</strong></p>
<blockquote>
<p>通过看源码知道 HashSet 的实现是依赖于 HashMap 的，HashSet 的值都是存储在 HashMap 中的。在 HashSet 的构造法中会初始化一个 HashMap 对象，HashSet 不允许值重复，因此，HashSet 的值是作为 HashMap 的 key 存储在 HashMap 中的，当存储的值已经存在时返回 false。  </p>
</blockquote>
<p><strong>94. LinkedHashMap 的实现原理?</strong></p>
<blockquote>
<p>LinkedHashMap 也是基于 HashMap 实现的，不同的是它定义了一个 Entry header，这个 header 不是放在 Table 里，它是额外独立出来的。LinkedHashMap 通过继承 hashMap 中的 Entry, 并添加两个属性 Entry before,after, 和 header 结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。LinkedHashMap 定义了排序模式 accessOrder，该属性为 boolean 型变量，对于访问顺序，为 true；对于插入顺序，则为 false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。  </p>
</blockquote>
<p><strong>95. 为什么集合类没有实现 Cloneable 和 Serializable 接口？</strong></p>
<blockquote>
<p>克隆 (cloning) 或者是序列化 (serialization) 的语义和含义是跟具体的实现相关的。因此，应该 由集合类的具体实现来决定如何被克隆或者是序列化。  </p>
</blockquote>
<p><strong>96. 什么是迭代器 (Iterator)？</strong></p>
<blockquote>
<p>Iterator 接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代 器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素, 但是不可以直接调用集合的 remove(Object Obj) 删除，可以通过迭代器的 remove() 方法删除。  </p>
</blockquote>
<p><strong>97. Iterator 和 ListIterator 的区别是什么？</strong></p>
<blockquote>
<p>下面列出了他们的区别：  </p>
</blockquote>
<blockquote>
<p>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。  </p>
</blockquote>
<blockquote>
<p>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。  </p>
</blockquote>
<blockquote>
<p>ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。  </p>
</blockquote>
<p><strong>98. 数组 (Array) 和列表 (ArrayList) 有什么区别？什么时候应该使用 Array 而不是 ArrayList？</strong></p>
<blockquote>
<p>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。  </p>
</blockquote>
<blockquote>
<p>Array 大小是固定的，ArrayList 的大小是动态变化的。  </p>
</blockquote>
<blockquote>
<p>ArrayList 处理固定大小的基本数据类型的时候，这种方式相对比较慢。  </p>
</blockquote>
<p><strong>99. Java 集合类框架的最佳实践有哪些？</strong></p>
<ul>
<li>假如元素的大小是固 定的，而且能事先知道，我们就应该用 Array 而不是 ArrayList。</li>
<li>有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置 初始容量来避免重新计算 hash 值或者是扩容。</li>
<li>为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的 ClassCastException。</li>
<li>使用 JDK 提供的不变类 (immutable class) 作为 Map 的键可以避免为我们自己的类实现 hashCode()和 equals()方法。</li>
<li>编程的时候接口优于实现。</li>
<li>底层的集合实际上是空的情况下，返回长度是 0 的集合或者是数组，不要返回 null。</li>
<li><em>100. Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用 == 还是 equals()？它们有何区别？*</em></li>
</ul>
<blockquote>
<p>Set 里的元素是不能重复的，那么用 iterator() 方法来区分重复与否。equals() 是判读两个 Set 是否相等  </p>
</blockquote>
<blockquote>
<p>equals() 和 == 方法决定引用值是否指向同一对象 equals() 在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值  </p>
</blockquote>
<p><strong>101. Comparable 和 Comparator 接口是干什么的？列出它们的区别。</strong></p>
<blockquote>
<p>Java 提供了只包含一个 compareTo() 方法的 Comparable 接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。  </p>
</blockquote>
<blockquote>
<p>Java 提供了包含 compare() 和 equals() 两个方法的 Comparator 接口。compare() 方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals() 方法需要一个对象作为参数，它用来决定输入参数是否和 comparator 相等。只有当输入参数也是一个 comparator 并且输入参数和当前 comparator 的排序结果是相同的时 候，这个方法才返回 true。  </p>
</blockquote>
<p><strong>102. Collection 和 Collections 的区别。</strong></p>
<blockquote>
<p>collection 是集合类的上级接口, 继承与它的接口主要是 set 和 list。  </p>
</blockquote>
<blockquote>
<p>collections 类是针对集合类的一个帮助类. 它提供一系列的静态方法对各种集合的搜索, 排序, 线程安全化等操作。  </p>
</blockquote>
<h3 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h3><p><strong>103. 字节流与字符流的区别。</strong></p>
<blockquote>
<p>要把一片二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为 IO 流，对应的抽象类为 OutputStream 和 InputStream ，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。  </p>
</blockquote>
<blockquote>
<p>在应用中，经常要完全是字符的一段文本输出去或读进来，用字节流可以吗？计算机中的一切最终都是二进制的字节形式存在。对于 “中国” 这些字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。  </p>
</blockquote>
<blockquote>
<p>底层设备永远只接受 <strong>字节数据</strong> ，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向 IO 设别写入或读取字符串提供了一点点方便。  </p>
</blockquote>
<blockquote>
<p>字符向字节转换时，要注意编码的问题，因为字符串转成字节数组，  </p>
</blockquote>
<blockquote>
<p>其实是转成该字符的某种编码的字节形式，读取也是反之的道理。  </p>
</blockquote>
<blockquote>
<p>讲解字节流与字符流关系的代码案例：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line">public class IOTest &#123;</span><br><span class="line">     public static void main(String[] args) throws Exception &#123;</span><br><span class="line">           String str &#x3D; &quot;中国人&quot;;</span><br><span class="line">           &#x2F;*FileOutputStream fos  &#x3D; new FileOutputStream(&quot;1.txt&quot;);</span><br><span class="line">           fos.write(str.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">           fos.close();*&#x2F;</span><br><span class="line">           &#x2F;*FileWriter fw &#x3D; new FileWriter(&quot;1.txt&quot;);</span><br><span class="line">           fw.write(str);</span><br><span class="line">           fw.close();*&#x2F;</span><br><span class="line">           PrintWriter pw &#x3D; new PrintWriter(&quot;1.txt&quot;,&quot;utf-8&quot;);</span><br><span class="line">           pw.write(str);</span><br><span class="line">           pw.close();</span><br><span class="line">           &#x2F;*FileReader fr &#x3D; new FileReader(&quot;1.txt&quot;);</span><br><span class="line">         char[] buf &#x3D; new char[1024];</span><br><span class="line">           int len &#x3D; fr.read(buf);</span><br><span class="line">           String myStr &#x3D; new String(buf,0,len);</span><br><span class="line">           System.out.println(myStr);*&#x2F;</span><br><span class="line">           &#x2F;*FileInputStream fr &#x3D; new FileInputStream(&quot;1.txt&quot;);</span><br><span class="line">           byte[] buf &#x3D; new byte[1024];</span><br><span class="line">           int len &#x3D; fr.read(buf);</span><br><span class="line">           String myStr &#x3D; new String(buf,0,len,&quot;UTF-8&quot;);</span><br><span class="line">           System.out.println(myStr);*&#x2F;</span><br><span class="line">           BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(new FileInputStream(&quot;1.txt&quot;),&quot;UTF-8&quot;));</span><br><span class="line">           String myStr &#x3D; br.readLine();</span><br><span class="line">           br.close();</span><br><span class="line">           System.out.println(myStr);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>104. 什么是 Java 序列化，如何实现 Java 序列化？或者请解释 Serializable 接口的作用。</strong></p>
<blockquote>
<p>我们有时候将一个 Java 对象变成字节流的形式传出去或者从一个字节流中恢复成一个 Java 对象，例如，要将 Java 对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个 Java 对象变成某个格式的字节流再传输，但是，jre 本身就提供了这种支持，我们可以调用 OutputStream 的 writeObject 方法来做，如果要让 Java 帮我们做，要被传输的对象必须实现 serializable 接口，这样，javac 编译时就会进行特殊处理，编译的类才可以被 writeObject 方法操作，这就是所谓的序列化。需要被序列化的类必须实现 Serializable 接口，该接口是一个 mini 接口，其中没有需要实现的方法，implements Serializable 只是为了标注该对象是可被序列化的。  </p>
</blockquote>
<blockquote>
<p>例如，在 web 开发中，如果对象被保存在了 Session 中，tomcat 在重启时要把 Session 对象序列化到硬盘，这个对象就必须实现 Serializable 接口。如果对象要经过分布式系统进行网络传输或通过 rmi 等远程调用，这就需要在网络上传输对象，被传输的对象就必须实现 Serializable 接口。  </p>
</blockquote>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p><strong>105. 请简洁描述 MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？</strong></p>
<blockquote>
<p>SQL 标准定义的四个隔离级别为：  </p>
</blockquote>
<blockquote>
<p><strong>read uncommited ：</strong> 读到未提交数据  </p>
</blockquote>
<blockquote>
<p><strong>read committed：</strong> 脏读，不可重复读  </p>
</blockquote>
<blockquote>
<p><strong>repeatable read：</strong> 可重读  </p>
</blockquote>
<blockquote>
<p><strong>serializable ：</strong> 串行事物  </p>
</blockquote>
<p><strong>106. 在 MySQL 中 ENUM 的用法是什么？</strong></p>
<blockquote>
<p>ENUM 是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。  </p>
</blockquote>
<blockquote>
<p>SQL 语法如下：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Create table size(name ENUM(&#39;Smail,&#39;Medium&#39;,&#39;Large&#39;);</span><br></pre></td></tr></table></figure>

<p><strong>107. CHAR 和 VARCHAR 的区别？</strong></p>
<blockquote>
<p>CHAR 和 VARCHAR 类型在存储和检索方面有所不同。  </p>
</blockquote>
<blockquote>
<p>CHAR 列长度固定为创建表时声明的长度，长度值范围是 1 到 255。  </p>
</blockquote>
<blockquote>
<p>当 CHAR 值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需删除尾随空格。  </p>
</blockquote>
<p><strong>108. 列的字符串类型可以是什么？</strong></p>
<blockquote>
<p>字符串类型是：  </p>
</blockquote>
<blockquote>
<p>SET  </p>
</blockquote>
<blockquote>
<p>BLOB  </p>
</blockquote>
<blockquote>
<p>ENUM  </p>
</blockquote>
<blockquote>
<p>CHAR  </p>
</blockquote>
<blockquote>
<p>TEXT  </p>
</blockquote>
<blockquote>
<p>VARCHAR  </p>
</blockquote>
<p><strong>109. MySQL 中使用什么存储引擎？</strong></p>
<blockquote>
<p>存储引擎称为表类型，数据使用各种技术存储在文件中。  </p>
</blockquote>
<blockquote>
<p>技术涉及：  </p>
</blockquote>
<blockquote>
<p>Storage mechanism  </p>
</blockquote>
<blockquote>
<p>Locking levels  </p>
</blockquote>
<blockquote>
<p>Indexing  </p>
</blockquote>
<blockquote>
<p>Capabilities and functions.  </p>
</blockquote>
<p><strong>110. TIMESTAMP 在 UPDATE CURRENT_TIMESTAMP 数据类型上做什么？</strong></p>
<blockquote>
<p>创建表时 TIMESTAMP 列用 Zero 更新。只要表中的其他字段发生更改，UPDATE CURRENT_TIMESTAMP 修饰符就将时间戳字段更新为当前时间。  </p>
</blockquote>
<p><strong>111. 主键和候选键有什么区别？</strong></p>
<blockquote>
<p>表格的每一行都由主键唯一标识, 一个表只有一个主键。  </p>
</blockquote>
<blockquote>
<p>主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。  </p>
</blockquote>
<p><strong>112. MySQL 数据库服务器性能分析的方法命令有哪些?</strong></p>
<blockquote>
<p>Show status 一些值得监控的变量值： Bytes <em>received 和 Bytes</em> sent 和服务器之间来往的流量。 Com <strong>服务器正在执行的命令。 Created</strong> 在查询执行期限间创建的临时表和文件。 Handler <strong>存储引擎操作。 Select</strong> 不同类型的联接执行计划。 Sort_* 几种排序信息。 Show session status like ‘Select’; Show profiles SET profiling=1; Show profiles\G Show profile;  </p>
</blockquote>
<p><strong>113. LIKE 和 REGEXP 操作有什么区别？</strong></p>
<blockquote>
<p>LIKE 和 REGEXP 运算符用于表示 ^ 和％。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;tablename&gt; WHERE * REGEXP &quot;^b&quot;;</span><br><span class="line">SELECT * FROM &lt;tablename&gt; WHERE * LIKE &quot;%b&quot;;</span><br></pre></td></tr></table></figure>

<p><strong>114. BLOB 和 TEXT 有什么区别？</strong></p>
<h1 id="BLOB"><a href="#BLOB" class="headerlink" title="BLOB"></a><strong>BLOB</strong></h1><blockquote>
<p>BLOB 是一个二进制对象，可以容纳可变数量的数据。有四种类型的 BLOB  </p>
</blockquote>
<ul>
<li>TINYBLOB</li>
<li>BLOB</li>
<li>MEDIUMBLOB 和</li>
<li>LONGBLOB<blockquote>
<p>它们只能在所能容纳价值的最大长度上有所不同。  </p>
</blockquote>
</li>
</ul>
<h1 id="TEXT"><a href="#TEXT" class="headerlink" title="TEXT"></a><strong>TEXT</strong></h1><blockquote>
<p>TEXT 是一个不区分大小写的 BLOB。四种 TEXT 类型  </p>
</blockquote>
<ul>
<li>TINYTEXT</li>
<li>TEXT</li>
<li>MEDIUMTEXT 和</li>
<li>LONGTEXT<blockquote>
<p>它们对应于四种 BLOB 类型，并具有相同的最大长度和存储要求。  </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>BLOB 和 TEXT 类型之间的唯一区别在于对 BLOB 值进行排序和比较时区分大小写，对 TEXT 值不区分大小写。  </p>
</blockquote>
<p><strong>115. 数据库的三范式？</strong></p>
<blockquote>
<p>第一范式：数据库表的每一个字段都是不可分割的。  </p>
</blockquote>
<blockquote>
<p>第二范式：数据库表中的非主属性只依赖于主键。  </p>
</blockquote>
<blockquote>
<p>第三范式：不存在非主属性对关键字的传递函数依赖关系。  </p>
</blockquote>
<p><strong>116. MySQL 表中允许有多少个 TRIGGERS？</strong></p>
<blockquote>
<p>在 MySQL 表中允许有六个触发器，如下：  </p>
</blockquote>
<blockquote>
<p>BEFORE INSERT  </p>
</blockquote>
<blockquote>
<p>AFTER INSERT  </p>
</blockquote>
<blockquote>
<p>BEFORE UPDATE  </p>
</blockquote>
<blockquote>
<p>AFTER UPDATE  </p>
</blockquote>
<blockquote>
<p>BEFORE DELETE and  </p>
</blockquote>
<blockquote>
<p>AFTER DELETE  </p>
</blockquote>
<p><strong>117. 什么是通用 SQL 函数？</strong></p>
<h1 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h1><ul>
<li>Abs（num）求绝对值</li>
<li>floor（num）向下取整</li>
<li>ceil（num）向上取整</li>
</ul>
<hr>
<h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><ul>
<li><p>insert (s1,index,length,s2) 替换函数</p>
<ul>
<li>S1 表示被替换的字符串</li>
<li>s2 表示将要替换的字符串</li>
<li>Index 表示被替换的位置, 从 1 开始</li>
<li>Lebgth 表示被替换的长度</li>
</ul>
</li>
<li><p>upper（str），ucase（str）将字母改为大写</p>
</li>
<li><p>lower（str），lcase（str）将字母改为小写</p>
</li>
<li><p>left（str，length）返回 str 字符串的前 length 个字符</p>
</li>
<li><p>right（str，length）返回 str 字符串的后 length 个字符</p>
</li>
<li><p>substring（str，index，length）返回 str 字符串从 index 位开始长度为 length 个字符（index 从 1 开始）</p>
</li>
<li><p>reverse（str）将 str 字符串倒序输出</p>
</li>
</ul>
<hr>
<h1 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h1><ul>
<li>curdate（）、current_date( ) 获取当前日期</li>
<li>curtime（）、current_time( ) 获取当前日期</li>
<li>now（）获取当前日期和时间</li>
<li>datediff（d1、d2）d1 和 d2 之间的天数差</li>
<li>adddate（date，num）返回 date 日期开始，之后 num 天的日期</li>
<li>subdate（date，num）返回 date 日期开始，之前 num 天的日期</li>
</ul>
<hr>
<h1 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h1><ul>
<li>Count（字段）根据某个字段统计总记录数（当前数据库保存到多少条数据）</li>
<li>sum（字段）计算某个字段的数值总和</li>
<li>avg（字段）计算某个字段的数值的平均值</li>
<li>Max（字段）、min（字段）求某个字段最大或最小值</li>
<li><em>118. MySQL 中有哪几种锁？*</em></li>
</ul>
<blockquote>
<p>MyISAM 支持表锁，InnoDB 支持表锁和行锁，默认为行锁。  </p>
</blockquote>
<blockquote>
<p>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。  </p>
</blockquote>
<blockquote>
<p>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。  </p>
</blockquote>
<p><strong>119. MySQL 数据优化。</strong></p>
<ul>
<li><p><strong>优化数据类型</strong></p>
<ul>
<li>避免使用 NULL，NULL 需要特殊处理, 大多数时候应该使用 NOT NULL，或者使用一个特殊的值，如 0，-1 作为默认值。</li>
<li>仅可能使用更小的字段，MySQL 从磁盘读取数据后是存储到内存中的，然后使用 cpu 周期和磁盘 I/O 读取它，这意味着越小的数据类型占用的空间越小.</li>
</ul>
</li>
<li><p><strong>小心字符集转换</strong></p>
<ul>
<li>客户端或应用程序使用的字符集可能和表本身的字符集不一样，这需要 MySQL 在运行过程中隐含地进行转换，此外，要确定字符集如 UTF-8 是否支持多字节字符，因此它们需要更多的存储空间。</li>
</ul>
</li>
<li><p>_ <em>优化 count(my</em> col) 和 count( <em>)</em> *</p>
</li>
<li><p><strong>优化子查询</strong></p>
<ul>
<li>遇到子查询时，MySQL 查询优化引擎并不是总是最有效的，这就是为什么经常将子查询转换为连接查询的原因了，优化器已经能够正确处理连接查询了，当然要注意的一点是，确保连接表 (第二个表) 的连接列是有索引的，在第一个表上 MySQL 通常会相对于第二个表的查询子集进行一次全表扫描，这是嵌套循环算法的一部分。</li>
</ul>
</li>
<li><p><strong>优化 UNION</strong></p>
<ul>
<li>在跨多个不同的数据库时使用 UNION 是一个有趣的优化方法，UNION 从两个互不关联的表中返回数据，这就意味着不会出现重复的行，同时也必须对数据进行排序，我们知道排序是非常耗费资源的，特别是对大表的排序。</li>
<li>UNION ALL 可以大大加快速度，如果你已经知道你的数据不会包括重复行，或者你不在乎是否会出现重复的行，在这两种情况下使用 UNION ALL 更适合。此外，还可以在应用程序逻辑中采用某些方法避免出现重复的行，这样 UNION ALL 和 UNION 返回的结果都是一样的，但 UNION ALL 不会进行排序。</li>
</ul>
</li>
</ul>
<p><strong>120. MySQL 的关键字。</strong></p>
<blockquote>
<p>添加索引：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table tableName add 索引（索引字段）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主键：primary key  </p>
</blockquote>
<blockquote>
<p>唯一：unique  </p>
</blockquote>
<blockquote>
<p>全局：fulltext  </p>
</blockquote>
<blockquote>
<p>普通：index  </p>
</blockquote>
<blockquote>
<p>多列： index index_name  </p>
</blockquote>
<blockquote>
<p>页级: 引擎 BDB。次锁定相邻的一组记录。  </p>
</blockquote>
<blockquote>
<p>表级: 引擎 MyISAM ， 理解为锁住整个表，可以同时读，写不行。 行级: 引擎 INNODB ， 单独的一行记录加锁，对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。 表级锁速度快，但冲突多，行级冲突少，但速度慢。  </p>
</blockquote>
<p><strong>121. 存储引擎。</strong></p>
<blockquote>
<p>存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。  </p>
</blockquote>
<ul>
<li><p>MyISAM：这种引擎是 mysql 最早提供的。这种引擎又可以分为静态 MyISAM、动态 MyISAM 和压缩 MyISAM 三种：</p>
<ul>
<li>静态 MyISAM：如果数据表中的各数据列的长度都是预先固定好的，服务器将自动选择这种表类型。因为数据表中每一条记录所占用的空间都是一样的，所以这种表存取和更新的效率非常高。当数据受损时，恢复工作也比较容易做。</li>
<li>动态 MyISAM：如果数据表中出现 varchar、text 或 BLOB 字段时，服务器将自动选择这种表类型。相对于静态 MyISAM，这种表存储空间比较小，但由于每条记录的长度不一，所以多次修改数据后，数据表中的数据就可能离散的存储在内存中，进而导致执行效率下降。同时，内存中也可能会出现很多碎片。因此，这种类型的表要经常用 optimize table 命令或优化工具来进行碎片整理。</li>
<li>压缩 MyISAM：以上说到的两种类型的表都可以用 myisamchk 工具压缩。这种类型的表进一步减小了占用的存储，但是这种表压缩之后不能再被修改。另外，因为是压缩数据，所以这种表在读取的时候要先时行解压缩。</li>
</ul>
</li>
</ul>
<blockquote>
<p>但是，不管是何种 MyISAM 表，目前它都不支持事务，行级锁和外键约束的功能。  </p>
</blockquote>
<ul>
<li><p>MyISAM Merge 引擎：这种类型是 MyISAM 类型的一种变种。合并表是将几个相同的 MyISAM 表合并为一个虚表。常应用于日志和数据仓库。</p>
</li>
<li><p>InnoDB：InnoDB 表类型可以看作是对 MyISAM 的进一步更新产品，它提供了事务、行级锁机制和外键约束的功能。</p>
</li>
<li><p>memory(heap)：这种类型的数据表只存在于内存中。它使用散列索引，所以数据的存取速度非常快。因为是存在于内存中，所以这种类型常应用于临时表中。</p>
</li>
<li><p>archive：这种类型只支持 select 和 insert 语句，而且不支持索引。</p>
</li>
<li><p>Desc[ribe] tablename：查看数据表的结构。</p>
</li>
<li><p>show engines：命令可以显示当前数据库支持的存储引擎情况。</p>
</li>
</ul>
<p><strong>122. 数据库备份。</strong></p>
<blockquote>
<p>必须要在未登录状态下  </p>
</blockquote>
<ul>
<li><p>导出整个数据库</p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出一个表</p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出一个数据库结构</p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u dbuser -p -d --add-drop-table dbname &gt;d:&#x2F;dbname_db.sql</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>-d 没有数据 –add-drop-table 在每个 create 语句之前增加一个 drop table  </p>
</blockquote>
<p><strong>123. truncate delete drop 的区别。</strong></p>
<blockquote>
<p><strong>drop(DDL 语句)：</strong> 是不可逆操作，会将表所占用空间全部释放掉；  </p>
</blockquote>
<blockquote>
<p><strong>truncate(DDL 语句)：</strong> 只针对于删除表的操作，在删除过程中不会激活与表有关的删除触发器并且不会把删除记录放在日志中；当表被 truncate 后，这个表和索引会恢复到初始大小；  </p>
</blockquote>
<blockquote>
<p><strong>delete(DML 语句)：</strong> 可以删除表也可以删除行，但是删除记录会被计入日志保存，而且表空间大小不会恢复到原来；  </p>
</blockquote>
<blockquote>
<p>执行速度：drop&gt;truncate&gt;delete。  </p>
</blockquote>
<p><strong>124. Redis 是什么？两句话做一下概括。</strong></p>
<blockquote>
<p>是一个完全开源免费的 key-value 内存数据库 2. 通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets。  </p>
</blockquote>
<ul>
<li><p>Redis 使用最佳方式是全部数据 in-memory。</p>
</li>
<li><p>Redis 更多场景是作为 Memcached 的替代者来使用。</p>
</li>
<li><p>当需要除 key/value 之外的更多数据类型支持时，使用 Redis 更合适。</p>
</li>
<li><p>当存储的数据不能被剔除时，使用 Redis 更合适。</p>
</li>
<li><p><em>125. Redis（管道，哈希）。*</em></p>
</li>
<li><p>Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。</p>
</li>
<li><p>Redis 支持数据的备份，即 master-slave 模式的数据备份。</p>
</li>
<li><p>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</p>
</li>
<li><p><em>126. Redis 实现原理或机制。*</em></p>
</li>
</ul>
<blockquote>
<p>Redis 是一个 key-value 存储系统。和 Memcached 类似，但是解决了断电后数据完全丢失的情况，而且她支持更多无化的 value 类型，除了和 string 外，还支持 lists（链表）、sets（集合）和 zsets（有序集合）几种数据类型。这些数据类型都支持 push/pop、add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。  </p>
</blockquote>
<blockquote>
<p>Redis 是一种基于客户端 - 服务端模型以及请求 / 响应协议的 TCP 服务。这意味着通常情况下一个请求会遵循以下步骤：  </p>
</blockquote>
<blockquote>
<p>客户端向服务端发送一个查询请求，并监听 Socket 返回，通常是以阻塞模式，等待服务端响应。服务端处理命令，并将结果返回给客户端。  </p>
</blockquote>
<blockquote>
<p>在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。  </p>
</blockquote>
<blockquote>
<p>Redis 管道技术最显著的优势是提高了 Redis 服务的性能。  </p>
</blockquote>
<blockquote>
<p>分区是分割数据到多个 Redis 实例的处理过程，因此每个实例只保存 key 的一个子集。  </p>
</blockquote>
<blockquote>
<p>通过利用多台计算机内存的和值，允许我们构造更大的数据库。  </p>
</blockquote>
<blockquote>
<p>通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。  </p>
</blockquote>
<blockquote>
<p>Redis 的一些特性在分区方面表现的不是很好：  </p>
</blockquote>
<blockquote>
<p>涉及多个 key 的操作通常是不被支持的。举例来说，当两个 set 映射到不同的 Redis 实例上时，你就不能对这两个 set 执行交集操作。  </p>
</blockquote>
<blockquote>
<p>涉及多个 key 的 Redis 事务不能使用。  </p>
</blockquote>
<blockquote>
<p>当使用分区时，数据处理较为复杂，比如你需要处理多个 rdb/aof 文件，并且从多个实例和主机备份持久化文件。  </p>
</blockquote>
<blockquote>
<p>增加或删除容量也比较复杂。Redis 集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做 presharding 的技术对此是有帮助的。  </p>
</blockquote>
<p><strong>127. Redis 有两种类型分区。</strong></p>
<blockquote>
<p>最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的 Redis 实例。  </p>
</blockquote>
<blockquote>
<p>比如，ID 从 0 到 10000 的用户会保存到实例 R0，ID 从 10001 到 20000 的用户会保存到 R1，以此类推。  </p>
</blockquote>
<blockquote>
<p>这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各 种对象的映射表，通常对 Redis 来说并非是好的方法。  </p>
</blockquote>
<blockquote>
<p>哈希分区：另外一种分区方法是 hash 分区。这对任何 key 都适用，也无需是 object_name: 这种形式，像下面描述的一样简单：  </p>
</blockquote>
<blockquote>
<p>用一个 hash 函数将 key 转换为一个数字，比如使用 crc32 hash 函数。对 key foobar 执行 crc32(foobar) 会输出类似 93024922 的整数。  </p>
</blockquote>
<blockquote>
<p>对这个整数取模，将其转化为 0-3 之间的数字，就可以将这个整数映射到 4 个 Redis 实例中的一个了。93024922 % 4 = 2，就是说 key foobar 应该被存到 R2 实例中。注意：取模操作是取除的余数，通常在多种编程语言中用 % 操作符实现。  </p>
</blockquote>
<blockquote>
<p>实际上，上面的集群模式还存在两个问题：  </p>
</blockquote>
<ol>
<li><p>扩容问题：</p>
</li>
<li><p>因为使用了一致性哈稀进行分片，那么不同的 key 分布到不同的 Redis-Server 上，当我们需要扩容时，需要增加机器到分片列表中，这时候会使得同样的 key 算出来落到跟原来不同的机器上，这样如果要取某一个值，会出现取不到的情况，对于这种情况，Redis 的作者提出了一种名为 Pre-Sharding 的方式：</p>
</li>
<li><p>Pre-Sharding 方法是将每一个台物理机上，运行多个不同断口的 Redis 实例，假如有三个物理机，每个物理机运行三个 Redis 实际，那么我们的分片列表中实际有 9 个 Redis 实例，当我们需要扩容时，增加一台物理机，步骤如下：</p>
<ol>
<li>在新的物理机上运行 Redis-Server；</li>
<li>该 Redis-Server 从属于 (slaveof) 分片列表中的某一 Redis-Server（假设叫 RedisA）；</li>
<li>等主从复制 (Replication) 完成后，将客户端分片列表中 RedisA 的 IP 和端口改为新物理机上 Redis-Server 的 IP 和端口；</li>
<li>停止 RedisA。<blockquote>
<p>这样相当于将某一 Redis-Server 转移到了一台新机器上。Prd-Sharding 实际上是一种在线扩容的办法，但还是很依赖 Redis 本身的复制功能的，如果主库快照数据文件过大，这个复制的过程也会很久，同时会给主库带来压力。所以做这个拆分的过程最好选择为业务访问低峰时段进行。  </p>
</blockquote>
</li>
</ol>
</li>
<li><p>单点故障问题：</p>
</li>
<li><p>还是用到 Redis 主从复制的功能，两台物理主机上分别都运行有 Redis-Server，其中一个 Redis-Server 是另一个的从库，采用双机热备技术，客户端通过虚拟 IP 访问主库的物理 IP，当主库宕机时，切换到从库的物理 IP。只是事后修复主库时，应该将之前的从库改为主库（使用命令 slaveof no one），主库变为其从库（使命令 slaveof IP PORT），这样才能保证修复期间新增数据的一致性。</p>
</li>
</ol>
<p><strong>128. 什么是 MongoDB。</strong></p>
<blockquote>
<p>非关系型数据库 (NoSql),Mongo DB 很好的实现了面向对象的思想 (OO 思想), 在 Mongo DB 中 每一条记录都是一个 Document 对象。Mongo DB 最大的优势在于所有的数据持久操作都无需开发人员手动编写 SQL 语句, 直接调用方法就可以轻松的实现 CRUD 操作.  </p>
</blockquote>
<p><strong>129. MongoDB 特点。</strong></p>
<blockquote>
<p>高性能、易部署、易使用，存储数据非常方便。主要功能特性有：  </p>
</blockquote>
<blockquote>
<p>面向集合存储，易存储对象类型的数据。  </p>
</blockquote>
<blockquote>
<p>模式自由。  </p>
</blockquote>
<blockquote>
<p>支持动态查询。  </p>
</blockquote>
<blockquote>
<p>支持完全索引，包含内部对象。  </p>
</blockquote>
<blockquote>
<p>支持查询。  </p>
</blockquote>
<blockquote>
<p>支持复制和故障恢复。  </p>
</blockquote>
<blockquote>
<p>使用高效的二进制数据存储，包括大型对象（如视频等）。  </p>
</blockquote>
<blockquote>
<p>自动处理碎片，以支持云计算层次的扩展性  </p>
</blockquote>
<blockquote>
<p>支持 Python，PHP，Ruby，Java，C，C#，Javascript，Perl 及 C++ 语言的驱动程序，社区中也提供了对 Erlang 及. NET 等平台的驱动程序。  </p>
</blockquote>
<blockquote>
<p>文件存储格式为 BSON（一种 JSON 的扩展）。  </p>
</blockquote>
<blockquote>
<p>可通过网络访问。  </p>
</blockquote>
<p><strong>130. MongoDB 的功能。</strong></p>
<blockquote>
<p>面向集合的存储：适合存储对象及 JSON 形式的数据。  </p>
</blockquote>
<blockquote>
<p>动态查询：Mongo 支持丰富的查询表达式。查询指令使用 JSON 形式的标记，可轻易查询文档中内嵌的对象及数组。  </p>
</blockquote>
<blockquote>
<p>完整的索引支持：包括文档内嵌对象及数组。Mongo 的查询优化器会分析查询表达式，并生成一个高效的查询计划。  </p>
</blockquote>
<blockquote>
<p>查询监视：Mongo 包含一个监视工具用于分析数据库操作的性能。  </p>
</blockquote>
<blockquote>
<p>复制及自动故障转移：Mongo 数据库支持服务器之间的数据复制，支持主 - 从模式及服务器之间的相互复制。复制的主要目标是提供冗余及自动故障转移。  </p>
</blockquote>
<blockquote>
<p>高效的传统存储方式：支持二进制数据及大型对象（如照片或图片）  </p>
</blockquote>
<blockquote>
<p>自动分片以支持云级别的伸缩性：自动分片功能支持水平的数据库集群，可动态添加额外的机器。  </p>
</blockquote>
<p><strong>131. MongoDB 的适用场景。</strong></p>
<blockquote>
<p>网站数据：Mongo 非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。  </p>
</blockquote>
<blockquote>
<p>缓存：由于性能很高，Mongo 也适合作为信息基础设施的缓存层。在系统重启之后，由 Mongo 搭建的持久化缓存层可以避免下层的数据源 过载。  </p>
</blockquote>
<blockquote>
<p>大尺寸，低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储。  </p>
</blockquote>
<blockquote>
<p>高伸缩性的场景：Mongo 非常适合由数十或数百台服务器组成的数据库。Mongo 的路线图中已经包含对 MapReduce 引擎的内置支持。  </p>
</blockquote>
<blockquote>
<p>用于对象及 JSON 数据的存储：Mongo 的 BSON 数据格式非常适合文档化格式的存储及查询。  </p>
</blockquote>
<p><strong>132. Redis、memcache、MongoDB 对比。</strong></p>
<blockquote>
<p>mongodb 和 memcached 不是一个范畴内的东西。mongodb 是文档型的非关系型数据库，其优势在于查询功能比较强大，能存储海量数据。  </p>
</blockquote>
<blockquote>
<p>和 memcached 更为接近的是 Redis。它们都是内存型数据库，数据保存在内存中，通过 tcp 直接存取，优势是速度快，并发高，缺点是数据类型有限，查询功能不强，一般用作缓存。  </p>
</blockquote>
<ol>
<li><p>性能</p>
</li>
<li><p>Redis 和 memcache 差不多，要大于 mongodb。</p>
</li>
<li><p>操作的便利性</p>
</li>
<li><p>memcache 数据结构单一。</p>
</li>
<li><p>Redis 丰富一些，数据操作方面，Redis 更好一些，较少的网络 IO 次数。</p>
</li>
<li><p>mongodb 支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富。</p>
</li>
<li><p>内存空间的大小和数据量的大小</p>
</li>
<li><p>Redis 在 2.0 版本后增加了自己的 VM 特性，突破物理内存的限制；可以对 key value 设置过期时间（类似 memcache）。</p>
</li>
<li><p>memcache 可以修改最大可用内存, 采用 LRU 算法。</p>
</li>
<li><p>mongoDB 适合大数据量的存储，依赖操作系统 VM 做内存管理，吃内存也比较厉害，服务不要和别的服务在一起。</p>
</li>
<li><p>可用性（单点问题）</p>
</li>
<li><p>Redis 对于单点问题，依赖客户端来实现分布式读写；主从复制时，每次从节点重新连接主节点都要依赖整个快照, 无增量复制，因性能和效率问题，所以单点问题比较复杂；不支持自动 sharding, 需要依赖程序设定一致 hash 机制。一种替代方案是，不用 Redis 本身的复制机制，采用自己做主动复制（多份存储），或者改成增量复制的方式（需要自己实现），一致性问题和性能的权衡。</p>
</li>
<li><p>Memcache 本身没有数据冗余机制，也没必要；对于故障预防，采用依赖成熟的 hash 或者环状的算法，解决单点故障引起的抖动问题。</p>
</li>
<li><p>mongoDB 支持 master-slave,replicaset（内部采用 paxos 选举算法，自动故障恢复）,auto sharding 机制，对客户端屏蔽了故障转移和切分机制。</p>
</li>
<li><p>可靠性（持久化）</p>
</li>
<li><p>对于数据持久化和数据恢复，Redis 支持（快照、AOF）：依赖快照进行持久化，aof 增强了可靠性的同时，对性能有所影响。</p>
</li>
<li><p>memcache 不支持，通常用在做缓存, 提升性能；</p>
</li>
<li><p>MongoDB 从 1.8 版本开始采用 binlog 方式支持持久化的可靠性。</p>
</li>
<li><p>数据一致性（事务支持）</p>
</li>
<li><p>Memcache 在并发场景下，用 cas 保证一致性。</p>
</li>
<li><p>Redis 事务支持比较弱，只能保证事务中的每个操作连续执行。</p>
</li>
<li><p>mongoDB 不支持事务。</p>
</li>
<li><p>数据分析</p>
</li>
<li><p>mongoDB 内置了数据分析的功能 (mapreduce), 其他不支持。</p>
</li>
<li><p>应用场景</p>
</li>
<li><p>Redis：数据量较小的更性能操作和运算上。</p>
</li>
<li><p>memcache：用于在动态系统中减少数据库负载，提升性能; 做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用 sharding）。</p>
</li>
<li><p>MongoDB: 主要解决海量数据的访问效率问题。</p>
</li>
</ol>
<p><strong>133. Redis 有什么用？只有了解了它有哪些特性，我们在用的时候才能扬长避短，为我们所用。</strong></p>
<ol>
<li><strong>速度快：</strong> 使用标准 C 写，所有数据都在内存中完成，读写速度分别达到 10 万 / 20 万。</li>
<li><strong>持久化：</strong> 对数据的更新采用 Copy-on-write 技术，可以异步地保存到磁盘上，主要有两种策略，一是根据时间，更新次数的快照（save 300 10 ）二是基于语句追加方式 (Append-only file，aof) 。</li>
<li><strong>自动操作：</strong> 对不同数据类型的操作都是自动的，很安全。</li>
<li>快速的主 – 从复制，官方提供了一个数据，Slave 在 21 秒即完成了对 Amazon 网站 10G key set 的复制。</li>
<li><strong>Sharding 技术：</strong> 很容易将数据分布到多个 Redis 实例中，数据库的扩展是个永恒的话题，在关系型数据库中，主要是以添加硬件、以分区为主要技术形式的纵向扩展解决了很多的应用场景，但随着 web2.0、移动互联网、云计算等应用的兴起，这种扩展模式已经不太适合了，所以近年来，像采用主从配置、数据库复制形式的，Sharding 这种技术把负载分布到多个特理节点上去的横向扩展方式用处越来越多。</li>
</ol>
<p><strong>134. 这里对 Redis 数据库做下小结。</strong></p>
<ol>
<li>提高了 DB 的可扩展性，只需要将新加的数据放到新加的服务器上就可以了</li>
<li>提高了 DB 的可用性，只影响到需要访问的 shard 服务器上的数据的用户</li>
<li>提高了 DB 的可维护性，对系统的升级和配置可以按 shard 一个个来搞，对服务产生的影响较小</li>
<li>小的数据库存的查询压力小，查询更快，性能更好<h3 id="Java-WEB"><a href="#Java-WEB" class="headerlink" title="Java WEB"></a>Java WEB</h3></li>
</ol>
<p><strong>135. Tomcat 的优化经验。</strong></p>
<blockquote>
<p>Tomcat 作为 Web 服务器，它的处理性能直接关系到用户体验，下面是几种常见的优化措施:  </p>
</blockquote>
<ul>
<li><p>去掉对 web.xml 的监视，把 jsp 提前编辑成 Servlet。有富余物理内存的情况，加大 tomcat 使用的 jvm 的内存。</p>
</li>
<li><p>服务器资源   服务器所能提供 CPU、内存、硬盘的性能对处理能力有决定性影响。</p>
<ul>
<li>对于高并发情况下会有大量的运算，那么 CPU 的速度会直接影响到处理速度。</li>
<li>内存在大量数据处理的情况下，将会有较大的内存容量需求，可以用 - Xmx -Xms -XX:MaxPermSize 等参数对内存不同功能块进行划分。我们之前就遇到过内存分配不足，导致虚拟机一直处于 full GC，从而导致处理能力严重下降。</li>
<li>硬盘主要问题就是读写性能，当大量文件进行读写时，磁盘极容易成为性能瓶颈。最好的办法还是利用下面提到的缓存。</li>
</ul>
</li>
<li><p>利用缓存和压缩   对于静态页面最好是能够缓存起来，这样就不必每次从磁盘上读。这里我们采用了 Nginx 作为缓存服务器，将图片、css、js 文件都进行了缓存，有效的减少了后端 tomcat 的访问。   另外，为了能加快网络传输速度，开启 gzip 压缩也是必不可少的。但考虑到 tomcat 已经需要处理很多东西了，所以把这个压缩的工作就交给前端的 Nginx 来完成。   除了文本可以用 gzip 压缩，其实很多图片也可以用图像处理工具预先进行压缩，找到一个平衡点可以让画质损失很小而文件可以减小很多。曾经我就见过一个图片从 300 多 kb 压缩到几十 kb，自己几乎看不出来区别。</p>
</li>
<li><p>采用集群   单个服务器性能总是有限的，最好的办法自然是实现横向扩展，那么组建 tomcat 集群是有效提升性能的手段。我们还是采用了 Nginx 来作为请求分流的服务器，后端多个 tomcat 共享 session 来协同工作。可以参考之前写的《利用 nginx+tomcat+memcached 组建 web 服务器负载均衡》。</p>
</li>
<li><p>优化 tomcat 参数</p>
</li>
</ul>
<blockquote>
<p>这里以 tomcat7 的参数配置为例，需要修改 conf/server.xml 文件，主要是优化连接配置，关闭客户端 dns 查询。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8080&quot;   </span><br><span class="line">   protocol&#x3D;&quot;org.apache.coyote.http11.Http11NioProtocol&quot;  </span><br><span class="line">   connectionTimeout&#x3D;&quot;20000&quot;  </span><br><span class="line">   redirectPort&#x3D;&quot;8443&quot;   </span><br><span class="line">   maxThreads&#x3D;&quot;500&quot;   </span><br><span class="line">   minSpareThreads&#x3D;&quot;20&quot;  </span><br><span class="line">   acceptCount&#x3D;&quot;100&quot;</span><br><span class="line">   disableUploadTimeout&#x3D;&quot;true&quot;</span><br><span class="line">   enableLookups&#x3D;&quot;false&quot;   </span><br><span class="line">   URIEncoding&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>136. HTTP 请求的 GET 与 POST 方式的区别。</strong></p>
<blockquote>
<p>GET 请求，请求的数据会附加在 URL 之后，以 <strong>?</strong> 分割 URL 和传输数据，多个参数用 <strong>&amp;</strong> 连接。URL 的编码格式采用的是 ASCII 编码，而不是 unicode，即是说所有的非 ASCII 字符都要编码之后再传输。  </p>
</blockquote>
<blockquote>
<p>POST 请求：POST 请求会把请求的数据放置在 HTTP 请求包的包体中。  </p>
</blockquote>
<blockquote>
<p>因此，GET 请求的数据会暴露在地址栏中，而 POST 请求则不会。  </p>
</blockquote>
<ul>
<li>传输数据的大小<blockquote>
<p>在 HTTP 规范中，没有对 URL 的长度和传输的数据大小进行限制。但是在实际开发过程中，对于 GET，特定的浏览器和服务器对 URL 的长度有限制。因此，在使用 GET 请求时，传输数据会受到 URL 长度的限制。  </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>对于 POST，由于不是 URL 传值，理论上是不会受限制的，但是实际上各个服务器会规定对 POST 提交数据大小进行限制，Apache、IIS 都有各自的配置。  </p>
</blockquote>
<ul>
<li><p>安全性</p>
<blockquote>
<p>POST 的安全性比 GET 的高。这里的安全是指真正的安全，而不同于上面 GET 提到的安全方法中的安全，上面提到的安全仅仅是不修改服务器的数据。比如，在进行登录操作，通过 GET 请求，用户名和密码都会暴露再 URL 上，因为登录页面有可能被浏览器缓存以及其他人查看浏览器的历史记录的原因，此时的用户名和密码就很容易被他人拿到了。除此之外，GET 请求提交的数据还可能会造成 Cross-site request frogery 攻击。  </p>
</blockquote>
</li>
<li><p>HTTP 中的 GET，POST，SOAP 协议都是在 HTTP 上运行的。</p>
</li>
<li><p><em>137. 解释一下什么是 Servlet。*</em></p>
</li>
</ul>
<blockquote>
<p>Servlet 是一种服务器端的 Java 应用程序，具有独立于平台和协议的特性, 可以生成动态的 Web 页面。 它担当客户请求（Web 浏览器或其他 HTTP 客户程序）与服务器响应（HTTP 服务器上的数据库或应用程序）的中间层。 Servlet 是位于 Web 服务器内部的服务器端的 Java 应用程序，与传统的从命令行启动的 Java 应用程序不同，Servlet 由 Web 服务器进行加载，该 Web 服务器必须包含支持 Servlet 的 Java 虚拟机。  </p>
</blockquote>
<p><strong>138. 说一说 Servlet 的生命周期。</strong></p>
<blockquote>
<p>Servlet 有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由 javax.servlet.Servlet 接口的 init、service 和 destroy 方法表达。  </p>
</blockquote>
<blockquote>
<p>Servlet 被服务器实例化后，容器运行其 init 方法，请求到达时运行其 service 方法，service 方法自动派遣运行与请求对应的 doXxx 方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其 destroy 方法。  </p>
</blockquote>
<blockquote>
<p>web 容器加载 Servlet，生命周期开始。通过调用 Servlet 的 init() 方法进行 Servlet 的初始化。通过调用 service() 方法实现，根据请求的不同调用不同的 do***() 方法。结束服务，web 容器调用 Servlet 的 destroy() 方法。  </p>
</blockquote>
<p><strong>139. Servlet API 中 forward() 与 redirect() 的区别？</strong></p>
<blockquote>
<p>前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量使用 forward() 方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用 sendRedirect() 方法。  </p>
</blockquote>
<p><strong>140. request.getAttribute() 和 request.getParameter() 有何区别?</strong></p>
<blockquote>
<p>getParameter 是用来接受用 post 或 get 方法传递过来的参数的。  </p>
</blockquote>
<blockquote>
<p>getAttribute 必须先 setAttribute。  </p>
</blockquote>
<blockquote>
<p>request.getParameter() 取得是通过容器的实现来取得通过类似 post，get 等方式传入的数据，request.setAttribute() 和 getAttribute() 只是在 web 容器内部流转，仅仅是请求处理阶段。  </p>
</blockquote>
<blockquote>
<p>request.getParameter() 方法传递的数据，会从 Web 客户端传到 Web 服务器端，代表 HTTP 请求数据。request.getParameter() 方法返回 String 类型的数据。  </p>
</blockquote>
<blockquote>
<p>request.setAttribute() 和 getAttribute() 方法传递的数据只会存在于 Web 容器内部。还有一点就是，HttpServletRequest 类有 setAttribute() 方法，而没有 setParameter() 方法。  </p>
</blockquote>
<p><strong>141. JSP 有哪些动作? 作用分别是什么?</strong></p>
<blockquote>
<p>JSP 共有以下 6 种基本动作：  </p>
</blockquote>
<ul>
<li><p>jsp:include：在页面被请求的时候引入一个文件。</p>
</li>
<li><p>jsp:useBean：寻找或者实例化一个 JavaBean。</p>
</li>
<li><p>jsp:setProperty：设置 JavaBean 的属性。</p>
</li>
<li><p>jsp:getProperty：输出某个 JavaBean 的属性。</p>
</li>
<li><p>jsp:forward：把请求转到一个新的页面。</p>
</li>
<li><p>jsp:plugin：根据浏览器类型为 Java 插件生成 OBJECT 或 EMBED 标记。</p>
</li>
</ul>
<p><strong>142. JSP 的常用指令。</strong></p>
<blockquote>
<p>常用的指令有三个：page、include、taglib;  </p>
</blockquote>
<ul>
<li><strong>page</strong> 指令<blockquote>
<p>&lt;%@page language=”java” contentType=”text/html;charset=gb2312” session=”true” buffer=”64kb” autoFlush=”true” isThreadSafe=”true” info=”text” errorPage=”error.jsp” isErrorPage=”true” isELIgnored=” true” pageEncoding=”gb2312” import=”java.sql.*”%&gt;  </p>
</blockquote>
</li>
</ul>
<blockquote>
<p>说明: isErrorPage(是否能使用 Exception 对象)，isELIgnored(是否忽略表达式)  </p>
</blockquote>
<ul>
<li><p><strong>include</strong> 指令</p>
<blockquote>
<p>&lt;%@ include file=”filename”%&gt;  </p>
</blockquote>
</li>
<li><p><strong>taglib</strong> 指令</p>
<blockquote>
<p>&lt;%@ taglib prefix=”c”uri=”http://……”%&gt;  </p>
</blockquote>
</li>
</ul>
<p><strong>143. JSP 和 Servlet 有哪些相同点和不同点，他们之间的联系是什么？</strong></p>
<blockquote>
<p>JSP 是 Servlet 技术的扩展，本质上是 Servlet 的简易方式，更强调应用的外表表达。JSP 编译后是 “类 servlet”。Servlet 和 JSP 最主要的不同点在于，Servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 HTML 里分离开来。而 JSP 的情况是 Java 和 HTML 可以组合成一个扩展名为. jsp 的文件。JSP 侧重于视图，Servlet 主要用于控制逻辑。  </p>
</blockquote>
<p><strong>144. MVC 的各个部分都有那些技术来实现? 如何实现?</strong></p>
<blockquote>
<p>MVC 是 Model－View－Controller 的简写。Model 代表的是应用的业务逻辑（通过 JavaBean，EJB 组件实现）， View 是应用的表示面（由 JSP 页面产生），Controller 是提供应用的处理过程控制（一般是一个 Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。  </p>
</blockquote>
<h3 id="企业级框架"><a href="#企业级框架" class="headerlink" title="企业级框架"></a>企业级框架</h3><p><strong>145. 谈谈你对 Spring 的理解。</strong></p>
<ul>
<li><p>Spring 实现了 <strong>工厂模式的工厂类</strong> （在这里有必要解释清楚什么是工厂模式），这个类名为 BeanFactory（实际上是一个接口），在程序中通常 BeanFactory 的子类 ApplicationContext。Spring 相当于一个大的工厂类，在其配置文件中通过 <bean> 元素配置用于创建实例对象的类名和实例对象的属性。</p>
</li>
<li><p>Spring 提供了对** IOC** 良好支持，IOC 是一种编程思想，是一种架构艺术，利用这种思想可以很好地实现模块之间的解耦。IOC 也称为 DI（Depency Injection），什么叫依赖注入呢？譬如：</p>
</li>
</ul>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Programmer &#123;</span><br><span class="line">    Computer computer &#x3D; null;</span><br><span class="line">    public void code()&#123;</span><br><span class="line">        &#x2F;&#x2F;Computer computer &#x3D; new IBMComputer();</span><br><span class="line">        &#x2F;&#x2F;Computer computer &#x3D; beanfacotry.getComputer();</span><br><span class="line">        computer.write();</span><br><span class="line">    &#125;</span><br><span class="line">    public void setComputer(Computer computer)</span><br><span class="line">    &#123;</span><br><span class="line">        this.computer &#x3D; computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>另外两种方式都由依赖，第一个直接依赖于目标类，第二个把依赖转移到工厂上，第三个彻底与目标和工厂解耦了。在 spring 的配置文件中配置片段如下：</li>
</ul>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;”computer” class&#x3D;”cn.itcast.interview.Computer”&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;bean id&#x3D;”programmer” class&#x3D;”cn.itcast.interview.Programmer”&gt;</span><br><span class="line">    &lt;property name&#x3D;”computer”  ref&#x3D;”computer”&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>Spring 提供了对 AOP 技术的良好封装， AOP 称为 <strong>面向切面编程</strong> ，就是系统中有很多各不相干的类的方法，在这些众多方法中要加入某种系统功能的代码，例如， <strong>加入日志，加入权限判断，加入异常处理</strong> ，这种应用称为 AOP。实现 AOP 功能采用的是代理技术，客户端程序不再调用目标，而调用代理类，代理类与目标类对外具有相同的方法声明，有两种方式可以实现相同的方法声明，一是实现相同的接口，二是作为目标的子类在，JDK 中采用 Proxy 类产生动态代理的方式为某个接口生成实现类，如果要为某个类生成子类，则可以用 CGLI B。在生成的代理类的方法中加入系统功能和调用目标类的相应方法，系统功能的代理以 Advice 对象进行提供，显然要创建出代理对象，至少需要目标类和 Advice 类。spring 提供了这种支持，只需要在 spring 配置文件中配置这两个元素即可实现代理和 aop 功能，例如:</li>
</ul>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;”proxy” type&#x3D;”org.spring.framework.aop.ProxyBeanFactory”&gt;</span><br><span class="line">    &lt;property name&#x3D;”target” ref&#x3D;””&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property name&#x3D;”advisor” ref&#x3D;””&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p><strong>146. 什么是 Spring 框架？Spring 框架有哪些主要模块？</strong></p>
<blockquote>
<p>Spring 框架是一个为 Java 应用程序的开发提供了 <strong>综合、广泛</strong> 的基础性支持的 Java 平台。Spring 帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring 框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成 Spring 框架，不必担心 Spring 是如何在后台进行工作的。  </p>
</blockquote>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//upload-images.jianshu.io/upload_images/127268-985d9d2db86e9e92?imageMogr2/auto-orient/strip%257CimageView2/2/w/1000/format/webp" alt=""></p>
<blockquote>
<p>enter image description here  </p>
</blockquote>
<blockquote>
<p>Spring 框架至今已集成了 20 多个模块。这些模块主要被分如下图所示的核心容器、数据访问 / 集成、Web、AOP（面向切面编程）、工具、消息和测试模块。  </p>
</blockquote>
<p><strong>147. 什么是控制反转 (IOC)？什么是依赖注入？</strong></p>
<blockquote>
<p>控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。而绑定的过程是通过 “依赖注入” 实现的。  </p>
</blockquote>
<blockquote>
<p>控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。  </p>
</blockquote>
<blockquote>
<p>依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？  </p>
</blockquote>
<blockquote>
<p>在 Java 中依然注入有以下三种实现方式：  </p>
</blockquote>
<ul>
<li><p>构造器注入</p>
</li>
<li><p>Setter 方法注入</p>
</li>
<li><p>接口注入</p>
</li>
</ul>
<p><strong>148. BeanFactory 和 ApplicationContext 有什么区别？</strong></p>
<blockquote>
<p>BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，以便在接收到客户端请求时将对应的 bean 实例化。  </p>
</blockquote>
<blockquote>
<p>BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的配置中解放出来。BeanFactory 还包含了 bean 生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。  </p>
</blockquote>
<blockquote>
<p>从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，根据请求分发 bean 的功能。但 application context 在此基础上还提供了其他的功能。  </p>
</blockquote>
<ol>
<li><p>提供了支持国际化的文本消息</p>
</li>
<li><p>统一的资源文件读取方式</p>
</li>
<li><p>已在监听器中注册的 bean 的事件</p>
</li>
</ol>
<blockquote>
<p>以下是三种较常见的 <strong>ApplicationContext</strong> 实现方式：  </p>
</blockquote>
<blockquote>
<p>1、<strong>ClassPathXmlApplicationContext</strong> ：从 classpath 的 XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(“bean.xml”);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2、<strong>FileSystemXmlApplicationContext</strong> ：由文件系统中的 XML 配置文件读取上下文。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context &#x3D; new FileSystemXmlApplicationContext(“bean.xml”);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3、<strong>XmlWebApplicationContext</strong> ：由 Web 应用的 XML 文件读取上下文。  </p>
</blockquote>
<p><strong>149. 谈谈你对 Hibernate 的理解。</strong></p>
<blockquote>
<p>Hibernate 是一个 ORM 框架，是对 JDBC 的封装。目的就是简化对数据库表访问的操作。 ORM 的意思是对象关系的映射，通过实体类与数据表建立映射，就可以通过持久层操作来代替 sql 语句操作数据库。  </p>
</blockquote>
<blockquote>
<p>hibernate 的核心原理就是对象关系映射（ORM），就是通过 java 的反射机制来实现。  </p>
</blockquote>
<blockquote>
<p>java 反射机制：在 java 运行状态中，对于任何一个类，都能够知道这个类的所有属性和方法，就是对于任意一个对象都能够调用他的任意属性和方法，这种动态获取信息以及动态调用的方法就是功能就是 java 的反射机制。  </p>
</blockquote>
<blockquote>
<p>以上这些就是 hibernate 的核心原理。  </p>
</blockquote>
<ul>
<li><p>使用 Hibernate 的基本流程是：配置 Configuration 对象、产生 SessionFactory、创建 session 对象，启动事务，完成 CRUD 操作，提交事务，关闭 session。</p>
</li>
<li><p>使用 Hibernate 时，先要配置 hibernate.cfg.xml 文件，其中配置数据库连接信息和方言等，还要为每个实体配置相应的 hbm.xml 文件，hibernate.cfg.xml 文件中需要登记每个 hbm.xml 文件。</p>
</li>
<li><p>在应用 Hibernate 时，重点要了解 Session 的缓存原理，级联，延迟加载和 hql 查询。</p>
</li>
</ul>
<p><strong>150. Hibernate 中的 update() 和 saveOrUpdate() 的区别，session 的 load() 和 get() 的区别。</strong></p>
<blockquote>
<p><strong>saveorupdate()</strong> 如果传入的对象在数据库中有就做 update 操作，如果没有就做 save 操作。  </p>
</blockquote>
<blockquote>
<p><strong>save()</strong> 在数据库中生成一条记录，如果数据库中有，会报错说有重复的记录。  </p>
</blockquote>
<blockquote>
<p><strong>Hibernate</strong> 中 <strong>get</strong> 方法和 <strong>load</strong> 方法的根本区别如下。  </p>
</blockquote>
<blockquote>
<p>如果你使用 load 方法，hibernate 认为该 id 对应的对象（数据库记录）在数据库中是一定存在的，所以它可以放心的使用，它可以放心的使用代理来延迟加载该对象。在用到对象中的其他属性数据时才查询数据库，但是万一数据库中不存在该记录，那没办法，只能抛异常 ObjectNotFoundException，所说的 load 方法抛异常是指在使用该对象的数据时，数据库中不存在该数据时抛异常，而不是在创建这个对象时。由于 session 中的缓存对于 hibernate 来说是个相当廉价的资源，所以在 load 时会先查一下 session 缓存看看该 id 对应的对象是否存在，不存在则创建代理。所以如果你知道该 id 在数据库中一定有对应记录存  </p>
</blockquote>
<blockquote>
<p>在就可以使用 load 方法来实现延迟加载。  </p>
</blockquote>
<blockquote>
<p>对于 get 方法，hibernate 会确认一下该 id 对应的数据是否存在，首先在 session 缓存中查找，然后在二级缓存中查找，还没有就查数据库，数据库中没有就返回 null。  </p>
</blockquote>
<blockquote>
<p>虽然好多书中都这么说：“get() 永远只返回实体类”，但实际上这是不正确的，get 方法如果在 session 缓存中找到了该 id 对应的对象，如果刚好该对象前面是被代理过的，如被 load 方法使用过，或者被其他关联对象延迟加载过，那么返回的还是原先的代理对象，而不是实体类对象，如果该代理对象还没有加载实体数据（就是 id 以外的其他属性数据），那么它会查询二级缓存或者数据库来加载数据，但是返回的还是代理对象，只不过已经加载了实体数据。  </p>
</blockquote>
<blockquote>
<p>前面已经讲了，get 方法首先查询 session 缓存，没有的话查询二级缓存，最后查询数据库；反而 load 方法创建时首先查询 session 缓存，没有就创建代理，实际使用数据时才查询二级缓存和数据库。  </p>
</blockquote>
<blockquote>
<p>总之对于 get 和 load 的根本区别，一句话，Hibernate 对于 load 方法认为该数据在数据库中一定存在，可以放心的使用代理来延迟加载，如果在使用过程中发现了问题，就抛异常；而对于 get 方法，Hibernate 一定要获取到真实的数据，否则返回 null。  </p>
</blockquote>
<p><strong>151. Hibernate 的 inverse 属性的作用？</strong></p>
<blockquote>
<p>inverse 属性，是在维护关联关系的时候起作用的。表示控制权是否转移。（在一方起作用）  </p>
</blockquote>
<blockquote>
<p>inverse , 控制反转。inverse = false 不反转，当前方有控制权；true 控制反转，当前方没有控制权。  </p>
</blockquote>
<blockquote>
<p>维护关联关系中，是否设置 inverse 属性：  </p>
</blockquote>
<ol>
<li><p>保存数据有影响。</p>
<blockquote>
<p>如果设置控制反转，即 inverse=true，然后通过部门方维护关联关系。在保存部门的时候，同时保存员工，数据会保存，但关联关系不会维护。即外键字段为 NULL。  </p>
</blockquote>
</li>
<li><p>获取数据无</p>
</li>
<li><p>解除关联关系？有影响。</p>
</li>
</ol>
<blockquote>
<p>inverse = false，可以解除关联  </p>
</blockquote>
<blockquote>
<p>inverse = true，当前方（部门）没有控制权，不能解除关联关系（不会生成 update 语句，也不会报错）。  </p>
</blockquote>
<ol>
<li>删除数据对关联关系的影响？有影响。<blockquote>
<p>inverse=false，有控制权。可以删除。先清空外键引用，再删除数据。  </p>
</blockquote>
</li>
</ol>
<blockquote>
<p>inverse=true，没有控制权。如果删除的记录有被外键引用，会报错，违反主外键引用约束！如果删除的记录没有被引用，可以直接删除。  </p>
</blockquote>
<p><strong>152. 介绍一下 Hibernate 的二级缓存</strong></p>
<blockquote>
<p>按照以下思路来回答：（1）首先说清楚什么是缓存，（2）再说有了 Hibernate 的 Session 就是一级缓存，即有了一级缓存，为什么还要有二级缓存，（3）最后再说如何配置 Hibernate 的二级缓存。  </p>
</blockquote>
<blockquote>
<p>（1）缓存就是把以前从数据库中查询出来和使用过的对象保存在内存中（一个数据结构中），这个数据结构通常是或类似 Hashmap，当以后要使用某个对象时，先查询缓存中是否有这个对象，如果有则使用缓存中的对象，如果没有则去查询数据库，并将查询出来的对象保存在缓存中，以便下次使用。下面是缓存的伪代码：  </p>
</blockquote>
<blockquote>
<p>引出 Hibernate 的第二级缓存，用下面的伪代码分析了 Cache 的实现原理：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Dao&#123;</span><br><span class="line">  hashmap map &#x3D; new map();</span><br><span class="line">  User getUser(integer id)  &#123;</span><br><span class="line">      User user &#x3D; map.get(id)</span><br><span class="line">      if(user &#x3D;&#x3D; null)</span><br><span class="line">      &#123;</span><br><span class="line">          user &#x3D; session.get(id);</span><br><span class="line">          map.put(id,user);</span><br><span class="line">      &#125;</span><br><span class="line">      return user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dao</span><br><span class="line">&#123;</span><br><span class="line">Cache cache &#x3D; null</span><br><span class="line">  setCache(Cache cache)</span><br><span class="line">  &#123;</span><br><span class="line">      this.cache &#x3D; cache</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  User getUser(int id)</span><br><span class="line">  &#123;</span><br><span class="line">      if(cache!&#x3D;null)</span><br><span class="line">      &#123;</span><br><span class="line">          User user &#x3D; cache.get(id);</span><br><span class="line">          if(user &#x3D;&#x3D;null)</span><br><span class="line">          &#123;</span><br><span class="line">              user &#x3D; session.get(id);</span><br><span class="line">              cache.put(id,user);</span><br><span class="line">          &#125;</span><br><span class="line">          return user;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return session.get(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>（2）Hibernate 的 Session 就是一种缓存，我们通常将之称为 Hibernate 的一级缓存，当想使用 session 从数据库中查询出一个对象时，Session 也是先从自己内部查看是否存在这个对象，存在则直接返回，不存在才去访问数据库，并将查询的结果保存在自己内部。由于 Session 代表一次会话过程，一个 Session 与一个数据库连接相关连，所以 Session 最好不要长时间保持打开，通常仅用于一个事务当中，在事务结束时就应关闭。并且 Session 是线程不安全的，被多个线程共享时容易出现问题。通常只有那种全局意义上的缓存才是真正的缓存应用，才有较大的缓存价值，因此，Hibernate 的 Session 这一级缓存的缓存作用并不明显，应用价值不大。Hibernate 的二级缓存就是要为 Hibernate 配置一种全局缓存，让多个线程和多个事务都可以共享这个缓存。我们希望的是一个人使用过，其他人也可以使用，session 没有这种效果。  </p>
</blockquote>
<blockquote>
<p>（3）二级 <strong>缓存是独立于</strong> Hibernate 的软件部件，属于第三方的产品，多个厂商和组织都提供有缓存产品，例如，EHCache 和 OSCache 等等。在 Hibernate 中使用二级缓存，首先就要在 hibernate.cfg.xml 配置文件中配置使用哪个厂家的缓存产品，接着需要配置该缓存产品自己的配置文件，最后要配置 Hibernate 中的哪些实体对象要纳入到二级缓存的管理中。明白了二级缓存原理和有了这个思路后，很容易配置起 Hibernate 的二级缓存。扩展知识：一个 SessionFactory 可以关联一个二级缓存，也即一个二级缓存只能负责缓存一个数据库中的数据，当使用 Hibernate 的二级缓存后，注意不要有其他的应用或 SessionFactory 来更改当前数据库中的数据，这样缓存的数据就会与数据库中的实际数据不一致。  </p>
</blockquote>
<p><strong>153. 简单的谈一下 Spring MVC 的工作流程。</strong></p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//upload-images.jianshu.io/upload_images/127268-a11583a4fa458bd1?imageMogr2/auto-orient/strip%257CimageView2/2/w/1000/format/webp" alt=""></p>
<blockquote>
<p>enter image description here  </p>
</blockquote>
<blockquote>
<p>流程  </p>
</blockquote>
<ol>
<li>用户发送请求至前端控制器 DispatcherServlet。</li>
<li>DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。</li>
<li>处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器（如果有则生成）一并返回给 DispatcherServlet。</li>
<li>DispatcherServlet 调用 HandlerAdapter 处理器适配器。</li>
<li>HandlerAdapter 经过适配调用具体的处理器（Controller，也叫后端控制器）。</li>
<li>Controller 执行完成返回 ModelAndView。</li>
<li>HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。</li>
<li>DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。</li>
<li>ViewReslover 解析后返回具体 View。</li>
<li>DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。</li>
<li>DispatcherServlet 响应用户。</li>
</ol>
<p><strong>154. Spring MVC Framework 的特点。</strong></p>
<ul>
<li><p>它是基于组件技术的全部的应用对象，无论控制器和视图，还是业务对象之类的都是 Java 组件，并且和 Spring 提供的其他基础结构紧密集成。</p>
</li>
<li><p>不依赖于 Servlet API（目标虽是如此，但是在实现的时候确实是依赖于 Servlet 的）。</p>
</li>
<li><p>可以任意使用各种视图技术，而不仅仅局限于 JSP。</p>
</li>
<li><p>支持各种请求资源的映射策略。</p>
</li>
<li><p>它应是易于扩展的。</p>
</li>
</ul>
<p><strong>155. @ModelAttribute 如何使用？</strong></p>
<ul>
<li><p>定义一个方法，该方法用来返回要填充到模型数据中的对象。</p>
</li>
<li><p>给该方法添加 @ModelAttribute 注解。</p>
</li>
<li><p>添加 @ModelAttribute 注解的方法，会在 Spring MVC 在调用任何一个业务方法之前被自动调用。</p>
</li>
</ul>
<p><strong>156. 说说你对自定义数据类型转换器的理解。</strong></p>
<blockquote>
<p>通过自定义数据类型转换器可以根据需求对 HTTP 请求中的参数进行解析，转换成需要的数据类型。具体操作是创建一个 Java 类，实现 org.springframework.core.convert.converter.Converter 接口，这样自定义的 Java 类就具备了转换数据的功能，然后在 convert 方法中完成转换的具体业务流程。  </p>
</blockquote>
<blockquote>
<p>当服务器接收到一个请求之后，Spring MVC 首先将请求分发到数据类型转换器进行格式转换，然后再进入相应的业务方法。  </p>
</blockquote>
<p><strong>157. 什么是 MyBatis 的接口绑定，有什么好处？</strong></p>
<blockquote>
<p>接口映射就是在 IBatis 中任意定义接口, 然后把接口里面的方法和 SQL 语句绑定，我们直接调用接口方法就可以，这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选择和设置。  </p>
</blockquote>
<p><strong>158. 接口绑定有几种实现方式, 分别是怎么实现的？</strong></p>
<blockquote>
<p>接口绑定有两种实现方式，一种是通过注解绑定，就是在接口的方法上面加上 @Select@Update 等注解里面包含 Sql 语句来绑定，另外一种就是通过 xml 里面写 SQL 来绑定，在这种情况下，要指定 xml 映射文件里面的 namespace 必须为接口的全路径名。  </p>
</blockquote>
<p><strong>159. MyBatis 实现一对一有几种方式，具体怎么操作的？</strong></p>
<blockquote>
<p>有联合查询和嵌套查询，联合查询是几个表联合查询，只查询一次，通过在 resultMap 里面配置 association 节点配置一对一的类就可以完成；  </p>
</blockquote>
<blockquote>
<p>嵌套查询是先查一个表，根据这个表里面的结果的外键 id，去再另外一个表里面查询数据，也是通过 association 配置，但另外一个表的查询通过 select 属性配置。  </p>
</blockquote>
<p><strong>160. MyBatis 实现一对多有几种方式，怎么操作的？</strong></p>
<blockquote>
<p>有联合查询和嵌套查询, 联合查询是几个表联合查询, 只查询一次, 通过在 resultMap 里面配置 collection 节点配置一对多的类就可以完成;  </p>
</blockquote>
<blockquote>
<p>嵌套查询是先查一个表, 根据这个表里面的结果的外键 id，去再另外一个表里面查询数据, 也是通过配置 collection，但另外一个表的查询通过 select 节点配置。  </p>
</blockquote>
<p><strong>161. MyBatis 里面的动态 Sql 是怎么设定的？用什么语法？</strong></p>
<blockquote>
<p>MyBatis 里面的动态 Sql 一般是通过 if 节点来实现, 通过 OGNL 语法来实现, 但是如果要写的完整, 必须配合 where,trim 节点, where 节点是判断包含节点有内容就插入 where, 否则不插入, trim 节点是用来判断如果动态语句是以 and 或 or 开始, 那么会自动把这个 and 或者 or 取掉。  </p>
</blockquote>
<p><strong>162. JDO 是什么?</strong></p>
<blockquote>
<p>JDO 是 Java 对象 <strong>持久化</strong> 的新的规范，为 java data object 的简称, 也是一个用于存取某种数据仓库中的对象的标准化 API。JDO 提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如 JDBC API 的使用）。这些繁琐的例行工作已经转移到 JDO 产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO 很灵活，因为它可以在任何数据底层上运行。JDBC 只是面向关系数据库（RDBMS）JDO 更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML 以及对象数据库（ODBMS）等等，使得应用可移植性更强。  </p>
</blockquote>
<blockquote>
<p>应用程序的开发人员通过访问 JDO Instance , 达到访问 JDO Instance 所代表的数据对象, 包括: ERP，数据库系统等. 使数据的存储介质对于应用的开发人员完全透明。  </p>
</blockquote>
<blockquote>
<p>JDO 最早是由 Sun 召集众多的** O/R Mappin**g 开发团队集中起来共同提出的，首先是通过会议确定了 JDO 需要包括的内容，然后正式提出一个 Java 规范请求（JSR-12），正式开始了 JDO 规范的制定。  </p>
</blockquote>
<p><strong>163. Spring、Spring Boot 和 Spring Cloud 的关系。</strong></p>
<blockquote>
<p>Spring Boot 是在Spring生态基础上面发展而来，发明 Spring Boot是为了简化Spring的开发。所以说没有 Spring 作为基础，就不会有Spring Boot，Spring Boot 使用约定优于配置的理念，重新重构了 Spring 的使用，让 Spring 后续的发展更有生命力。  </p>
</blockquote>
<blockquote>
<p>Spring Cloud 是一系列框架的有序集合，它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发。服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。为了解决微服务架构中服务治理而提供的具备一系列功能的开发框架，并且 Spring Cloud 是完全基于 Spring Boot 而开发，Spring Cloud 利用 Spring Boot 特性整合了开源行业中优秀的组件，整体对外提供了一套在微服务架构中服务治理的解决方案。  </p>
</blockquote>
<p><strong>164. 什么是数据校验？</strong></p>
<blockquote>
<p>应用程序必须通过某种手段来确保输入进来的数据从语义上来讲是正确的。在 Java 应用程序中，必须要对输入进来的数据从语义上分析是有效的，也就是数据校验。  </p>
</blockquote>
<blockquote>
<p>输入验证是最重要的 Web 开发任务之一，在 Spring MVC 中有两种方式可以验证输入：一种是 Spring 自带的验证框架，另外一种是利用 JSR 实现。  </p>
</blockquote>
<blockquote>
<p>JSR 是一个规范文档，指定了一整套 API，通过标注给对象属性添加约束。Hibernate Validator 就是 JSR 规范的具体实现，Hibernate Validator 提供了 JSR 规范中所有内置约束注解的实现，以及一些附加的约束注解，除此之外用户还可以自定义约束注解。  </p>
</blockquote>
<blockquote>
<p>Spring Boot 的参数校验依赖于 hibernate-validator 来进行。使用 Hibernate Validator 校验数据，需要定义一个接收的数据模型，使用注解的形式描述字段校验的规则。  </p>
</blockquote>
<p><strong>165. Thymeleaf 特点。</strong></p>
<blockquote>
<p>Thymeleaf 是一个可以完全替代 JSP的模版。与其他的模板引擎相比较，它有如下三个特点。  </p>
</blockquote>
<ul>
<li><p>Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 HTML 原型，然后在 HTML 标签里增加额外的属性来达到模板 + 数据的展示方式。浏览器解释 HTML 时会忽略未定义的标签属性，所以 Thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</p>
</li>
<li><p>Thymeleaf 开箱即用的特性。它支持标准方言和 Spring 方言，可以直接套用模板实现 JSTL、 OGNL 表达式效果，避免每天套模板、改 JSTL、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。</p>
</li>
<li><p>Thymeleaf 提供 Spring 标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速地实现表单绑定、属性编辑器、国际化等功能。</p>
</li>
</ul>
<p><strong>166. 什么是 Druid？</strong></p>
<blockquote>
<p>Druid 是阿里巴巴开源平台上的一个项目，整个项目由数据库连接池、插件框架和 SQL 解析器组成，该项目主要是为了扩展 JDBC 的一些限制，可以让程序员实现一些特殊的需求，比如向密钥服务请求凭证、统计 SQL 信息、SQL 性能收集、SQL 注入检查、SQL 翻译等，程序员可以通过定制来实现自己需要的功能。  </p>
</blockquote>
<blockquote>
<p>Druid 首先是一个数据库连接池，但它不仅仅是一个数据库连接池，还包含了一个 ProxyDriver，一系列内置的 JDBC 组件库，一个 SQL Parser。在 Java 的世界中 Druid 是监控做的最好的数据库连接池。  </p>
</blockquote>
<p><strong>167. Druid 有什么作用？</strong></p>
<ul>
<li><p>替换其他 Java 连接池，Druid 提供了一个高效、功能强大、可扩展性好的数据库连接池。</p>
</li>
<li><p>可以监控数据库访问性能，Druid 内置提供了一个功能强大的 StatFilter 插件，能够详细统计 SQL 的执行性能，这对于线上分析数据库访问性能有很大帮助。</p>
</li>
<li><p>数据库密码加密。直接把数据库密码写在配置文件中，这是不好的行为，容易导致安全问题，DruidDruiver 和 DruidDataSource 都支持 PasswordCallback。</p>
</li>
<li><p>SQL 执行日志，Druid 提供了不同的 LogFilter，能够支持 Common-Logging、Log4j 和 JdkLog，可以按需要选择相应的 LogFilter，监控应用的数据库访问情况。</p>
</li>
<li><p>扩展 JDBC，如果你要对 JDBC 层有编程的需求，可以通过 Druid 提供的 Filter 机制，很方便编写 JDBC 层的扩展插件。</p>
</li>
</ul>
<p><strong>168. 什么是 Spring Data JPA？</strong></p>
<blockquote>
<p>JPA（Java Persistence API）是 Sun 官方提出的 Java 持久化规范。它为 Java 开发人员提供了一种对象 / 关联映射工具来管理 Java 应用中的关系数据。它的出现主要是为了简化现有的持久化开发工作和整合 ORM 技术，结束现在 Hibernate、TopLink、JDO 等 ORM 框架各自为营的局面。JPA 是在充分吸收了现有的 Hibernate、TopLink、JDO 等 ORM 框架的基础上发展而来的，具有易于使用、伸缩性强等优点。  </p>
</blockquote>
<blockquote>
<p>Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套 JPA 应用框架，可以让开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增、删、改、查等在内的常用功能，且易于扩展，学习并使用 Spring Data JPA 可以极大提高开发效率。Spring Data JPA 其实就是 Spring 基于 Hibernate 之上构建的 JPA 使用解决方案，方便在 Spring Boot 项目中使用 JPA 技术。  </p>
</blockquote>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ol>
<li>LINUX 下线程、GDI 类的解释。</li>
</ol>
<ul>
<li><p>LINUX 实现的就是基于核心轻量级进程的”一对一”线程模型，一个线程实体对应一个核心轻量级进程，而线程之间的管理在核外函数库中实现。</p>
</li>
<li><p>GDI 类为图像设备编程接口类库。</p>
</li>
</ul>
<p><strong>170. 绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？</strong></p>
<ul>
<li><p>绝对路径： 如/etc/init.d</p>
</li>
<li><p>当前目录和上层目录： ./ ../</p>
</li>
<li><p>主目录： ~/</p>
</li>
<li><p>切换目录： cd</p>
</li>
<li><p><em>171. 怎么查看当前进程？怎么执行退出？怎么查看当前路径？*</em></p>
</li>
<li><p>查看当前进程： ps</p>
</li>
<li><p>执行退出： exit</p>
</li>
<li><p>查看当前路径： pwd</p>
</li>
<li><p><em>172. 怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户 id？查看指定帮助用什么命令？*</em></p>
</li>
<li><p>清屏： clear</p>
</li>
<li><p>退出当前命令： ctrl+c</p>
</li>
<li><p>彻底退出</p>
</li>
<li><p>执行睡眠 ： ctrl+z 挂起当前进程 fg 恢复后台</p>
</li>
<li><p>查看当前用户 id： ”id“：查看显示目前登陆账户的 uid 和 gid 及所属分组及用户名</p>
</li>
<li><p>查看指定帮助： 如 man adduser 这个很全 而且有例子； adduser –help 这个告诉你一些常用参数； info adduesr；</p>
</li>
<li><p><em>173. Ls 命令执行什么功能？ 可以带哪些参数，有什么区别？*</em></p>
</li>
<li><p>ls 执行的功能： 列出指定目录中的目录，以及文件。</p>
</li>
<li><p>哪些参数以及区别： a 所有文件 l 详细信息，包括大小字节数，可读可写可执行的权限等。</p>
</li>
<li><p><em>174. 建立软链接（快捷方式），以及硬链接的命令。*</em></p>
</li>
<li><p>软链接： ln -s slink source</p>
</li>
<li><p>硬链接： ln link source</p>
</li>
<li><p><em>175. 目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？*</em></p>
</li>
</ul>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">创建目录： mkdir</span><br><span class="line">创建文件：典型的如 touch，vi 也可以创建文件，其实只要向一个不存在的文件输出，都会创建文件</span><br><span class="line">复制文件： cp 7. 文件权限修改用什么命令？格式是怎么样的？</span><br><span class="line">文件权限修改： chmod</span><br><span class="line">格式如下：</span><br><span class="line">$ chmod u+x file 给 file 的属主增加执行权限</span><br><span class="line">$ chmod 751 file 给 file 的属主分配读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限</span><br><span class="line">$ chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x file 上例的另一种形式</span><br><span class="line">$ chmod &#x3D;r file 为所有用户分配读权限</span><br><span class="line">$ chmod 444 file 同上例</span><br><span class="line">$ chmod a-wx,a+r file 同上例</span><br><span class="line">$ chmod -R u+r directory 递归地给 directory 目录下所有文件和子目录的属主分配读的权限</span><br></pre></td></tr></table></figure>

<p><strong>176. 查看文件内容有哪些命令可以使用？</strong></p>
<ul>
<li><p>vi 文件名 ＃编辑方式查看，可修改</p>
</li>
<li><p>cat 文件名 ＃显示全部文件内容</p>
</li>
<li><p>more 文件名 ＃分页显示文件内容</p>
</li>
<li><p>less 文件名 ＃与 more 相似，更好的是可以往前翻页</p>
</li>
<li><p>tail 文件名 ＃仅查看尾部，还可以指定行数</p>
</li>
<li><p>head 文件名 ＃仅查看头部,还可以指定行数</p>
</li>
<li><p><em>177. Linux 下命令有哪几种可使用的通配符？分别代表什么含义？*</em></p>
</li>
<li><p>“?”可替代单个字符。</p>
</li>
<li><p>“*”可替代任意多个字符。</p>
</li>
<li><p>方括号“[charset]”可替代 charset 集中的任何单个字符，如 [a-z]、[abABC]</p>
</li>
<li><p><em>178. Grep 命令有什么用？ 如何忽略大小写？ 如何查找不含该串的行？*</em></p>
</li>
</ul>
<blockquote>
<p>是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [stringSTRING] filename grep [^string] filename</span><br></pre></td></tr></table></figure>

<p><strong>179. Linux 中进程有哪几种状态？在 ps 显示出来的信息中，分别用什么符号表示的？</strong></p>
<ul>
<li>不可中断状态：进程处于睡眠状态，但是此刻进程是不可中断的。不可中断， 指进程不响应异步信号。</li>
<li>暂停状态/跟踪状态：向进程发送一个 SIGSTOP 信号，它就会因响应该信号 而进入 TASK <em>STOPPED 状态;当进程正在被跟踪时，它处于 TASK</em> TRACED 这个特殊的状态。 “正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。</li>
<li>就绪状态：在 run_queue 队列里的状态。</li>
<li>运行状态：在 run_queue 队列里的状态。</li>
<li>可中断睡眠状态：处于这个状态的进程因为等待某某事件的发生（比如等待 socket 连接、等待信号量），而被挂起。</li>
<li>zombie 状态（僵尸）：父亲没有通过 wait 系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。</li>
<li>退出状态。</li>
<li>D 不可中断 Uninterruptible（usually IO）</li>
<li>R正在运行，或在队列中的进程</li>
<li>S处于休眠状态</li>
<li>T停止或被追踪</li>
<li>Z 僵尸进程</li>
<li>W 进入内存交换（从内核 2.6 开始无效）</li>
<li>X死掉的进程</li>
<li><em>180. 把后台任务调到前台执行使用什么命令?把停下的后台任务在后台执行起来用什么命令？*</em></li>
</ul>
<blockquote>
<p>fg。例如：  </p>
</blockquote>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># jobs</span><br><span class="line"></span><br><span class="line">[1]+ Running &#x2F;root&#x2F;bin&#x2F;rsync.sh &amp;</span><br><span class="line"></span><br><span class="line"># fg 1 bg 类似</span><br></pre></td></tr></table></figure>

<p><strong>181. 查看当前谁在使用该主机用什么命令? 查找自己所在的终端信息用什么命令?</strong></p>
<ul>
<li><p>w：用户名称；用户的机器名称或 tty 号；远程主机地址；用户登录系统的时间；空闲时间（作用不大）;附加到 tty（终端）的进程所用的时间（JCPU 时间）；当前进程所用时间（PCPU时间）；用户当前正在使用的命令。</p>
</li>
<li><p>who：用户名、tty 号、时间日期、主机地址。</p>
</li>
<li><p>whoami,id -un：命令用于显示登入的用户名。</p>
</li>
<li><p>last：命令可用于显示特定用户登录系统的历史记录（last jason）；用户名称；tty 设备号；历史登录时间日期；登出时间日期；总工作时间。</p>
</li>
<li><p>查找自己所在终端信息：who am i。</p>
</li>
<li><p><em>182. 通过什么命令指定命令提示符？*</em></p>
</li>
<li><p>\u 显示当前用户账号 \h 显示当前主机名</p>
</li>
<li><p>\W 只显示当前路径最后一个目录 \w 显示当前绝对路径（当前用户目录会以 ~代替） <code>$PWD</code> 显示当前全路径 <code>\$</code> 显示命令行 ’$’ 或者 ’#’ 符号 # ：下达的第几个命令</p>
</li>
<li><p>\d：代表日期，格式为 weekday month date，例如：”Mon Aug 1”</p>
</li>
<li><p>\t：显示时间为 24 小时格式，如：HH：MM：SS \T ：显示时间为 12 小时格式 \A ：显示时间为 24 小时格式：HH：MM \v ：BASH 的版本信息，如 <code>export PS1=’[\u@\h \w\#]\$‘</code></p>
</li>
<li><p><em>183. du 和 df 的定义，以及区别？ du 显示目录或文件的大小。*</em></p>
</li>
</ul>
<blockquote>
<p>df 显示每个&lt;文件&gt;所在的文件系统的信息，默认是显示所有文件系统。 （文件系统分配其中的一些磁盘块用来记录它自身的一些数据，如 i 节点，磁盘分布图，间接块，超级块等。 这些数据对大多数用户级的程序来说是不可见的，通常称为 Meta Data。） du 命令是用户级的程序，它不考虑 Meta Data，而 df 命令则查看文件系统的磁盘分配 图并考虑 Meta Data。 df 命令获得真正的文件系统数据，而 du 命令只查看文件系统的部分情况。  </p>
</blockquote>
<p><strong>184. AWK 详解。</strong></p>
<blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk &#39;&#123;pattern + action&#125;&#39; &#123;filenames&#125;</span><br><span class="line"> \#cat &#x2F;etc&#x2F;passwd |awk -F &#39;:&#39; &#39;&#123;print $1&quot;\t&quot;$7&#125;&#39; &#x2F;&#x2F;-F 的意思是以&#39;:&#39;分隔 root &#x2F;bin&#x2F;bash</span><br><span class="line"> daemon &#x2F;bin&#x2F;sh 搜索&#x2F;etc&#x2F;passwd 有 root 关键字的所有行</span><br><span class="line"></span><br><span class="line">\#awk -F: &#39;&#x2F;root&#x2F;&#39; &#x2F;etc&#x2F;passwd root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<h3 id="软件工程与设计模式"><a href="#软件工程与设计模式" class="headerlink" title="软件工程与设计模式"></a>软件工程与设计模式</h3><p><strong>185. UML 方面。</strong></p>
<blockquote>
<p>标准建模语言 UML。用例图、静态图（包括类图、对象图和包图)、行为图、交互图（顺序图、合作图）、实现图。  </p>
</blockquote>
<p><strong>186. J2EE 常用的设计模式？说明工厂模式。</strong></p>
<blockquote>
<p>总共 23 种，分为三大类：创建型、结构型、行为型。我只记得其中常用的 6、7 种，分别是：创建型（工厂、工厂方法、抽象工厂、单例），结构型（包装、适配器、组合、代理），行为（观察者，模版，策略），然后再针对你熟悉的模式谈谈你的理解即可。  </p>
</blockquote>
<blockquote>
<p>Java 中的 23 种设计模式：  </p>
</blockquote>
<ul>
<li>Factory（工厂模式）</li>
<li>Builder（建造模式）</li>
<li>Factory Method（工厂方法模式）</li>
<li>Prototype（原始模型模式）</li>
<li>Singleton（单例模式）</li>
<li>Facade（门面模式）</li>
<li>Adapter（适配器模式）</li>
<li>Bridge（桥梁模式）</li>
<li>Composite（合成模式）</li>
<li>Decorator（装饰模式）</li>
<li>Flyweight（享元模式）</li>
<li>Proxy（代理模式）</li>
<li>Command（命令模式）</li>
<li>Interpreter（解释器模式）</li>
<li>Visitor（访问者模式）</li>
<li>Iterator（迭代子模式）</li>
<li>Mediator（调停者模式）</li>
<li>Memento（备忘录模式）</li>
<li>Observer（观察者模式）</li>
<li>State（状态模式）</li>
<li>Strategy（策略模式）</li>
<li>Template Method（模板方法模式）</li>
<li>Chain Of Responsibleity（责任链模式）<blockquote>
<p>工厂模式：工厂模式是一种经常被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。  </p>
</blockquote>
</li>
</ul>
<p><strong>187. 开发中都用到了那些设计模式?用在什么场合？</strong></p>
<blockquote>
<p>每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。主要用到了 MVC 的设计模式。用来开发 JSP/Servlet 或者 J2EE 的相关应用。简单工厂模式等。  </p>
</blockquote>
<h3 id="Web-Service"><a href="#Web-Service" class="headerlink" title="Web Service"></a>Web Service</h3><p><strong>188. Web Service 名词解释，JSWDL 开发包的介绍，JAXP、JAXM 的解释，SOAP、UDDI、WSDL 解释。</strong></p>
<blockquote>
<p><strong>Web ServiceWeb Service</strong> 是基于网络的、分布式的模块化组件，它执行特定的任务，遵守具体的技术规范，这些规范使得Web Service能与其他兼容的组件进行互操作。   </p>
</blockquote>
<blockquote>
<p>JAXP（Java API for XML Parsing）定义了在 Java 中使用 DOM、SAX、XSLT 的通用的接口。这样在你的程序中你只要使用这些通用的接口，当你需要改变具体的实现时候也不需要修改代码。  </p>
</blockquote>
<blockquote>
<p><strong>JAXM（Java API for XML Messaging）</strong> 是为 SOAP 通信提供访问方法和传输机制的 API。   </p>
</blockquote>
<blockquote>
<p><strong>WSDL</strong> 是一种 XML 格式，用于将网络服务描述为一组端点，这些端点对包含面向文档信息或面向过程信息的消息进行操作。这种格式首先对操作和消息进行抽象描述，然后将其绑定到具体的网络协议和消息格式上以定义端点。相关的具体端点即组合成为抽象端点（服务）。   </p>
</blockquote>
<blockquote>
<p><strong>SOAP</strong> 即简单对象访问协议（Simple Object Access Protocol），它是用于交换 XML 编码信息的轻量级协议。   </p>
</blockquote>
<blockquote>
<p><strong>UDDI</strong> 的目的是为电子商务建立标准；UDDI 是一套基于 Web 的、分布式的、为 Web Service 提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的 Web Service 注册，以使别的企业能够发现的访问协议的实现标准。  </p>
</blockquote>
<p><strong>189. CORBA 是什么？用途是什么？</strong></p>
<blockquote>
<p><strong>CORBA</strong>  </p>
</blockquote>
<blockquote>
<p>标准是公共对象请求代理结构（Common Object Request Broker Architecture），由对象管理组织（Object Management Group，缩写为 OMG）标准化。它的组成是接口定义语言（IDL），语言绑定（binding 也译为联编）和允许应用程序间互操作的协议。 其目的为：用不同的程序设计语言书写在不同的进程中运行，为不同的操作系统开发。  </p>
</blockquote>
<p>190、JSWDL 开发包的介绍。</p>
<ul>
<li><strong>JAXP</strong> （Java API for XML Parsing）：定义了在 Java 中使⽤ DOM、SAX、XSLT 的通⽤的接⼝。</li>
<li><strong>JAXM</strong> （Java API for XML Messaging）：是为 SOAP 通信提供访问方法和传输机制的 API。</li>
<li><strong>SOAP</strong> ：简单对象访问协议（Simple Object Access Protocol），它是用于交换 XML 编码信息的轻量级协议。</li>
<li><strong>UDDI</strong> ：基于 Web 的、分布式的、为 Web Service 提供的、信息注册中心的实现标准规范 。</li>
<li><strong>WSDL</strong> ：是一种 XML 格式，⽤于将⽹络服务描述为一组端点，这些端点对包含面向文档信息或⾯向过程信息的消息进⾏操作。<h3 id="答题技巧"><a href="#答题技巧" class="headerlink" title="答题技巧"></a>答题技巧</h3></li>
</ul>
<blockquote>
<p>回答问题的思路：先正面叙述一些 <strong>基本的核心知识</strong> ，然后描述一些 <strong>特殊的东西</strong> ，最后再来一些 <strong>锦上添花的东西</strong> 。要注意有些不是锦上添花，而是画蛇添足的东西，不要随便写上。把答题像写书一样写。我要回答一个新技术的问题大概思路和步骤是：我们想干什么，怎么干，干的过程中遇到了什么问题，现在用什么方式来解决。其实我们讲课也是这样一个思路。  </p>
</blockquote>
<blockquote>
<p>例如，讲 AJAX 时，我们希望不改变原来的整个网页，而只是改变网页中的局部内容，如用户名校验、级联下拉列表、下拉树状菜单。用传统方式，就是浏览器自己直接向服务器发请求，服务器返回新页面会盖掉老页面，这样就不流畅了。  </p>
</blockquote>
<blockquote>
<p>答题时，先答是什么，再答有什么作用和要注意什么（这部分最重要，展现自己的心得）。  </p>
</blockquote>
<blockquote>
<p>答案的段落分别，层次分明，条理清晰都非常重要，从这些表面的东西也可以看出一个人的习惯、办事风格、条理等。  </p>
</blockquote>
<blockquote>
<p>要讲你做出答案的思路过程，或者说你记住答案的思想都写下来。把答题想着是辩论赛。答题就是给别人讲道理、摆事实。答题不局限于什么格式和形式，就是要将自己的学识展现出来！  </p>
</blockquote>
<blockquote>
<p>别因为人家题目本来就模棱两可，你就心里胆怯和没底气了，不敢回答了。你要大胆地指出对方题目很模糊和你的观点，不要把面试官想得有多高，其实他和你就是差不多的，你想想，如果他把你招进去了，你们以后就是同事了，可不是差不多的吗？  </p>
</blockquote>
<blockquote>
<p>关于就业薪水，如果你是应届生，那不能要高工资，好比大饼的故事，没有文凭还想拿高工资，就去中关村缺什么补什么吧！少数人基础确实很好，在校期间确实又做过一些项目，那仍然是可以要到相对高的工资的。  </p>
</blockquote>
<blockquote>
<p><strong>公司招聘程序员更看重的要用到的编码技术、而不是那些业务不太相关的所谓项目经历。</strong>  </p>
</blockquote>
<ol>
<li>公司想招什么样的；</li>
<li>公司面试会问什么；</li>
<li>简历怎么写；</li>
<li>怎样达到简历上的标准（培训中心教项目的目的）。<blockquote>
<p>对于一些公司接到了一些项目，想招聘一些初中级的程序员过来帮助写代码，完成这个项目，你更看重的是他的专业技术功底，还是以前做过几个项目的经历呢？我们先排除掉那些编码技术功底好，又正好做过相似项目的情况，实际上，这种鱼和熊掌兼得的情况并不常见。  </p>
</blockquote>
</li>
</ol>
<blockquote>
<p>其实公司很清楚，只要招聘进来的人技术真的很明白，那他什么项目都可以做出来，公司招人不是让你去重复做你以前的项目，而是做一个新项目，业务方面，你只要进了项目团队，自然就能掌握。所以，大多数招聘单位在招聘那些编码级别的程序员时也没指望能招聘到做过类似项目的人，也不会刻意去找做过类似项目的人，用人单位也不是想把你招进，然后把你以前做过的项目重做一遍。  </p>
</blockquote>
<blockquote>
<p>所以，用人单位更看重招进来的人对要用到的编码技术的功底到底怎样，技术扎实不扎实，项目则只要跟着开发团队走，自然就没问题。除非是一些非常专业的行业，要招聘特别高级的开发人员和系统分析师，招聘单位才特别注重他的项目经验和行业经验，要去找到行业高手，公司才关心项目和与你聊项目的细节，这样的人通常都不是通过常规招聘渠道去招聘进来的，而是通过各种手段挖过来的，这情况不再我今天要讨论的范围中。  </p>
</blockquote>
<blockquote>
<p>技术学得明白不明白，人家几个问题就把你的深浅问出来了，只要问一些具体的技术点，就很容易看出你是真懂还是假懂，很容看出你的技术深度和实力，所以，技术是来不得半点虚假的，必须扎扎实实。  </p>
</blockquote>
<blockquote>
<p>由于项目的种类繁多，涉及到现实生活中的各行各业，什么五花八门的业务都有，例如，酒店房间预定管理，公司车辆调度管理，学校课程教室管理，超市进销存管理，知识内容管理，等等……成千上万等等，但是，不管是什么项目，采用的无非都是我们学习的那些目前流行和常用的技术。  </p>
</blockquote>
<blockquote>
<p>技术好、经验丰富，则项目做出来的效率高些，程序更稳定和更容易维护些；技术差点，碰碰磕磕最后也能把项目做出来，无非是做的周期长点、返工的次数多点，程序代码写得差些，用的技术笨拙点。如果一个人不是完完全全做过某个项目，他是不太关心该项目的业务的，对其中的一些具体细节更是一窍不知（如果我招你来做图书管理，你项目经历说你做过汽车调度，那我能问你汽车调度具体怎么回事吗？不会，所以，你很容易蒙混过去的）。  </p>
</blockquote>
<blockquote>
<p>而一个程序员的整个职业生涯中能实实在在和完完整整做出来的项目没几个，更别说在多个不同行业的项目了，有的程序员更是一辈子都只是在做某一个行业的项目，结果他就成了这个行业的专家（专门干一件事的家伙）。所以，技术面试官通常没正好亲身经历过你简历写的那些项目，他不可能去问你写的那些项目的具体细节，而是只能泛泛地问你这个项目是多少人做的，做了多长时间，开发的过程，你在做项目的过程中有什么心得和收获，用的什么技术等面上的问题，所以，简历上的项目经历可以含有很多水分，很容易作假，技术面试官也无法在项目上甄别你的真伪。  </p>
</blockquote>
<blockquote>
<p>简历该怎么写： <strong>精通那些技术，有一些什么项目经历</strong>  </p>
</blockquote>
<blockquote>
<p>讲的项目应该真实可靠才有价值，否则，表面上是项目，实际上还是知识点的整合，对巩固技术点和增强学习的趣味性，但无法获得实际的项目经验。（项目主要是增加你经验的可信度，获得更多面试机会，真正能不能找到工作，找到好工作，主要看你键盘上的功夫了），好的面试官几下就能面出你是否真有工作经验，他们问技术以外的公司的人和事，并且问开始、过程、结果，看你怎么编。  </p>
</blockquote>
<blockquote>
<p>建议大家尽量开自己的 blog，坚持每天写技术 blog。在简历上写上自己的 blog 地址，可以多转载一些技术文章。  </p>
</blockquote>
<h3 id="人事问题"><a href="#人事问题" class="headerlink" title="人事问题"></a>人事问题</h3><p><strong>191. 请讲一下这样一个经历：尽管其他人反对，但是你还是坚持自己的观点，并把事情继续做下去。</strong></p>
<blockquote>
<p>【思路】从自己积极方面回答，比如家人和老师都希望我报考会计专业，而我对会计就是不感兴趣，毅然选择了计算机专业。我现在毕业，专业技能很强，而且有自己成熟的作品，计算机是我的事业，将继续做下去。  </p>
</blockquote>
<p><strong>192. 你的一位领导脾气比较急，批评下属时常常不留情面，大家的工作情绪经常受到影响。作为职员，你该怎么办？</strong></p>
<blockquote>
<p>【思路】首先对领导的批评应该认真接受，不能因为领导严厉的批评而产生逆反心理，以致影响工作； 其次可以私下找机会和领导沟通，向领导反映下属因此产生的意见和情绪，婉转地说明这种情绪可能会影响工作的正常开展，至于是否接受建议、改变方法，由领导自己决定。  </p>
</blockquote>
<p><strong>193. 与上级意见不一是，你将怎么办？</strong></p>
<blockquote>
<p>正确回答：首先呢，作为一个员工我的是不会和上级产生争执的，如果真有意见不一致的时候，我想我会服从领导安排的。  </p>
</blockquote>
<blockquote>
<p>【思路】  </p>
</blockquote>
<ol>
<li>一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”</li>
<li>如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。”</li>
</ol>
<p><strong>194. 你是应届毕业生，缺乏经验，如何能胜任这项工作？</strong></p>
<blockquote>
<p>正确回答：作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。  </p>
</blockquote>
<blockquote>
<p>【思路】  </p>
</blockquote>
<ol>
<li>如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘单位并不真正在乎“经验”，关键看应聘者怎样回答。</li>
<li>对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。</li>
</ol>
<p><strong>195. 你为什么觉得自己能够在这个职位上取得成就？</strong></p>
<blockquote>
<p>正确回答： 从我的经历来看，这是我的职业生涯中最适合我的一份工作。几年来，我一直在研究这个领域并且关注贵公司，一直希望能有这样的面试机会。我拥有必备的技能（简单讲述一个故事来加以说明），我非常适合这一职位，也确实能做好这份工作。  </p>
</blockquote>
<blockquote>
<p>【思路】这是一个相当宽泛的问题，它给求职者提供了一个机会，可以让求职者表明自己的热情和挑战欲。对这个问题的回答将为面试人在判断求职者是否对这个职位有足够的动力和自信心方面提供关键信息。  </p>
</blockquote>
<p><strong>196. 你希望 5 年后达到什么成就？</strong></p>
<ul>
<li>A. 做一天和尚敲一天钟，尽人事听天命、顺其自然。</li>
<li>B. 依我的机灵及才干，晋升到部门经理是我的中期目标。</li>
<li>C. 自己独当一面开公司。</li>
<li>D. “全力以赴”是我的座右铭，希望能随着经验的增加，被赋予更多的职责及挑战。<blockquote>
<p>解答：最理想的回答是 D。  </p>
</blockquote>
</li>
</ul>
<p><strong>197. 5 年之内你想处于什么位置？</strong></p>
<blockquote>
<p>正确回答：我希望有机会在工厂或国内办事处工作。我也希望通过管理一个小团体发展我的管理技能。  </p>
</blockquote>
<blockquote>
<p>【思路】不要给出具体的时限或工作头衔。谈你喜欢的东西，你天生的技能，实际的问题和在你所选的领域或行业里你希望有什么机会，你希望从那些经验中学点什么。不要谈论你在那些与你所应聘的工作无关的领域或行业里的目标。这是听起来很明显的道理，但是很多求职者会犯这个错误。不经意间你就表现出了对当前的领域或行业缺乏真正的兴趣。不用说，一失言马上就会把你从进一步的考虑中淘汰掉。  </p>
</blockquote>
<p><strong>198. 如果你有无限的时间和经济来源，你会怎样使用它们呢？</strong></p>
<blockquote>
<p>正确回答：我希望能参加几次不针对金融专家的有关金融管理的行政研讨会。我还希望能让我的部门放长假，把每一个人都派去参加外界的一些活动。最后，我很可能去旅游并考察一下外国竞争者，同时一路享受当地的美食，您呢？  </p>
</blockquote>
<blockquote>
<p>【思路】虽然娱乐的事情谈起来很有诱惑力，但一定要紧扣工作或与行业相关的事务，或者紧扣与你应聘的这份工作的技能相关的努力上。例如，你正在应聘教书工作，你可能对义务教授成年人读书识字的项目感兴趣。这就证明了你对自己的工作领域的激情，即对教育重要性的一种信仰，即使是作为一种兴趣而毫无报酬都无所谓。  </p>
</blockquote>
<p><strong>199. 假如现在是你在我们公司做首次年度总结，我该告诉你一些什么呢？</strong></p>
<blockquote>
<p>正确回答：您要感谢我把工作完成得很好，并说明您渴望能够继续看到我工作的好成绩。更重要的是，我希望您能告诉我，您很欣赏我为一些重要项目加班加点工作的行为，还有我富有创造性的思维是如何有助于对存在的问题提出改革方案的。  </p>
</blockquote>
<blockquote>
<p>【思路】很明显，在回答该问题时，你想给人留下积极的印象。“但愿您能更准时地出现”绝对不是一个好答案。记住，重点谈一两点你个人的优势。  </p>
</blockquote>
<p><strong>200. 为什么你想在这里工作？</strong></p>
<blockquote>
<p>正确回答：我几年前就错过了你们公司的一次招标，之后我意识到电脑产品变得越来越相近了，且零售价格的竞争愈趋激烈，以致服务成为了一家公司在竞争中脱颖而出的最好的方法。贵公司在所有的竞争者中享有最好的服务记录，而我相信从长远看，它将主宰这个行业。你的准备和调查研究工作应在这里明显表现出来。  </p>
</blockquote>
<blockquote>
<p>【思路】给出一到两个你对该公司感兴趣的原因，并表明什么最激发你的兴趣。什么是你可以叙述来表明你个人对该公司的认识的最有说服力的事情呢？它的产品还是它的员工？答案包括公司的信誉、对该工作本身的描述，或者是跻身于该企业的欲望。  </p>
</blockquote>
<p><strong>201. 你对加班的看法。</strong></p>
<blockquote>
<p>正确回答：首先我想确认下，是何种性质的加班？ 如果是我个人的工作量是在规定的时间内没有完成的话，这种情况是不会发生的，我是个注重工作效率的人。其次如果是公司业务量临时增加的话，我会接受加班。  </p>
</blockquote>
<blockquote>
<p>【思路】首先，明确的告诉对方，如果是因为自己在规定的时间内没有完成工作任务的话 ，需要加班的情况是几乎不可能出现的，“我是个注重工作效率的人”其次，如果是因为公司业务情况或者其他的一些紧急工作的话是可以适应加班的。  </p>
</blockquote>
<p><strong>202. 你能给公司带来什么？</strong></p>
<blockquote>
<p>【思路】一般外企很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。外企喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。”等等。  </p>
</blockquote>
<p><strong>203. 你认为你在学校属于好学生吗？</strong></p>
<blockquote>
<p>【思路】企业的招聘者很精明，问这个问题可以试探出很多问题：如果求职者学习成绩好，就会说：“是的，我的成绩很好，所有的成绩都很优异。当然，判断一个学生是不是好学生有很多标准，在学校期间我认为成绩是重要的，其他方面包括思想道德、实践经验、团队精神、沟通能力也都是很重要的，我在这些方面也做得很好，应该说我是一个全面发展的学生。”如果求职者成绩不尽理想，便会说：“我认为是不是一个好学生的标准是多元化的，我的学习成绩还可以，在其他方面我的表现也很突出，比如我去很多地方实习过，我很喜欢在快节奏和压力下工作，我在学生会组织过××活动，锻炼了我的团队合作精神和组织能力。” 有经验的招聘者一听就会明白，企业喜欢诚实的求职者。  </p>
</blockquote>
<p><strong>204. 有人说“成功是对人有益的”，也有人说“失败是对人有益的”，你怎么看？</strong></p>
<blockquote>
<p>【思路】成功是对努力的一种回报，一种肯定，能使人们认识到自身的价值，对自身是一种动力，能激发人们继续创新、学习的勇气！当然，成功是对人有益的。 “失败是对人有益的”，俗话说“失败乃成功之母”，它给予人们更多的是经验与坚韧顽强的精神和永不认输的斗志，所以说“失败是对人有益的”。 这类题的应对方法：辩证地看、联系地看，肯定一方但不否定另一方，两者是有机的统一。  </p>
</blockquote>
<p><strong>205. 如果我们单位录用了你，但工作一段时间却发现你根本不适合这个职位你怎么办？</strong></p>
<blockquote>
<p>【思路】一段时间发现工作不适合我，有两种情况：  </p>
</blockquote>
<ol>
<li>如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；</li>
<li>你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。</li>
</ol>
<p><strong>206. 你最大的长处和弱点分别是什么？这些长处和弱点对你在企业的业绩会有什么样的影响？</strong></p>
<blockquote>
<p>【思路】这个问题的最大陷阱在于，第一个问题实际上是两个问题，而且还要加上一个后续问题。这两个问题的陷阱并不在于你是否能认真地看待自己的长处，也不在于你是否能正确认识自己的弱点。记住，你的回答不仅是向面试人说明你的优势和劣势，也能在总体上表现你的价值观和对自身价值的看法。  </p>
</blockquote>
<blockquote>
<p>长处来说，我相信我最大的优点是我有一个高度理性的头脑，能够从混乱中整理出头绪来。我最大的弱点是，对那些没有秩序感的人，可能缺乏足够的耐心。我相信我的组织才能可以帮助企业更快地实现目标，而且有时候，我处理复杂问题的能力也能影响我的同事。  </p>
</blockquote>
<p><strong>207. 除了工资，还有什么福利最吸引你？</strong></p>
<blockquote>
<p>【思路】尽可能诚实，如果你做足了功课，你就知道他们会提供什么，回答尽可能和他们提供的相配。如果你觉得自己该得到更多，也可以多要一点。  </p>
</blockquote>
<p><strong>208. 有人说，善意的谎言是对的，你如何看？</strong></p>
<blockquote>
<p>【思路】这个问题不能一概而论的， 它仅仅动机是善意的， 但是造成的后果好不好呢， 如果反而引起更大的伤害， 那么就得不偿失了；其次是对象，如果对象意志毅力很强，能够接受突如其来的打击，并且不喜欢别人骗他哪怕是善意的，那么善意的谎言便毫无意义，有时反而造成误会。但是善意的谎言在更多程度上都是对的可以接受的，它可以最大地减少不必要的痛苦，能够起到积极的作用。  </p>
</blockquote>
<p><strong>209. 领导要你 4 天完成一件工作，突然要你 2 天完成，你该怎么办？</strong></p>
<blockquote>
<p>【思路】  </p>
</blockquote>
<ol>
<li>首先分析一下提前完成工作的可能性。</li>
<li>如果确定完不成的，那么去跟领导详谈，跟他讲道理摆事实，说明没法完成的理由。一定要有充足的理由，才能说服他。</li>
<li>如果可以完成，但是需要其他条件的配合的，那么找领导说明情况。请领导给于支持。</li>
<li>如果经过自己努力可以完成的，那么就努力完成吧。</li>
</ol>
<p><strong>210. 你认为这些年来同事对你怎么样？</strong></p>
<blockquote>
<p>【思路】：面试官问这个问题的目的，主要想从你的同事对你的态度和评价上推测你这个人是什么样的，对于你来说回答这个问题要谨慎。比如：同事对我都很热心（从侧面反衬你对同事也很热心）；同事们有棘手的工作我会主动去帮助他们，所以我有事情的时候他们都来帮助我等等。  </p>
</blockquote>
<p><strong>211. 向面试官提出的问题。</strong></p>
<blockquote>
<p>贵公司对这项职务的工作内容和期望目标为何？有没有什么部分是我可以努力的地方？  </p>
</blockquote>
<blockquote>
<p>贵公司是否有正式或非正式教育训练？  </p>
</blockquote>
<blockquote>
<p>贵公司的升迁管道如何？  </p>
</blockquote>
<blockquote>
<p>贵公司的多角化经营，而且在海内外都设有分公司，将来是否有外派、轮调的机会？  </p>
</blockquote>
<blockquote>
<p>贵公司能超越同业的最大利基点为何？  </p>
</blockquote>
<blockquote>
<p>贵公司强调的团队合作中，其它的成员素质和特性如何？  </p>
</blockquote>
<blockquote>
<p>能否为我介绍一下工作环境，或者是否有机会能参观一下贵公司？  </p>
</blockquote>
<blockquote>
<p>【思路】在面试结束前，大多数的主考官都会丢问题给求职者，最常见的就是：你有没有什么问题或疑问，想要提出来的？无论求职者是否有提出问题，其实，这个问题背后的真正含意，通常是主考官用来测试你对这份工作有多大的企图心、决心和热情。  </p>
</blockquote>
<blockquote>
<p>因此，如果你害怕发问不妥当，或是不知道该从何问起，甚至回答没有问题时，都很可能会让主考官认为，你想要这份工作的企图心、决心还不够强。  </p>
</blockquote>
<blockquote>
<p>相反地，求职者应该更积极、主动的利用面试最后一关的机会，适时的提出问题，这不但有助于主考官对你的印象能够加深，而且你也能趁此机会进一步了解这家公司的背景、企业文化是否适合你。  </p>
</blockquote>
<blockquote>
<p>最重要的是，如果能够在面试时，提出漂亮的问题，录取的机率将会大大提高。所以，无论如何，前往面试前，先谨记10个可以反问主考官的问题，以便到时候可以提出。  </p>
</blockquote>
<blockquote>
<p>至于薪水待遇、年假天数、年终奖金、福利措施等问题，有些公司的主考官在面试时，会直接向求职者提出。如果对方没有提及，对社会新鲜人来说，在找第一份工作时，比较不适合提出，除非你有对方不得不录取你的条件。另外，也有人在结束前，谦虚的请教主考官：您认为我今天的表现如何？录取的机率有多大？通常，这个问题也会让对方认为，你对这份工作抱有很大的决心和企图心，而你也可以试着从对方的回答中，约略猜测出自己成功的机率有多大，并且作为下一次面试时表现的参考！  </p>
</blockquote>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>非常感谢各位读者的支持，笔者水平有限，知识点上难免会有遗漏的地方，如果大家有更好的想法或者建议，欢迎留言。也可加我微信：nnsouthwind，进行更进一步的交流。</p>
<p>最后祝大家工作顺利，薪资翻倍，附上本文 PDF 资源的下载链接。</p>
<blockquote>
<p>链接: <a href="https://pan.baidu.com/s/1jfVHaaXDMWYeNloGgG1-Dg">https://pan.baidu.com/s/1jfVHaaXDMWYeNloGgG1-Dg</a> 提取码: dnak  </p>
</blockquote>
<hr>
<p>本文首发于 GitChat，未经授权不得转载，转载需与 GitChat 联系。</p>
<p>登录后订阅Chat<br><a href="#">24</a> <a href="#">3</a><br>写评论<br><a href="#">向作者提问</a></p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/6644ecb0-b559-11e8-9a21-09295a3d7e19" alt=""></p>
<p>One<br>先不说别的，先来个赞<br>2018年12月4日</p>
<p>11</p>
<p>1</p>
<p>宁楠: 感谢支持。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/0d41f040-d336-11e8-83c4-93b72872a9ed" alt=""></p>
<p>民<br>很好的chat,首先从内容数量上就该点赞了。<br>2018年12月4日</p>
<p>7</p>
<p>1</p>
<p>宁楠: 感谢支持。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/f5d017a0-ac40-11e8-8a14-814e96ebc1f4" alt=""></p>
<p>Nono.c.Rook<br>说拼凑来的 真的是不知道什么想法，在我看来这边文章就算是拼凑来的，但是只要有你不懂的，看这篇文章记住了的知识点就是不亏的，更何况还是大佬辛辛苦苦平时积累，总结的。5块钱，一张地铁票钱，可能你面试的时候就因为这里的一个点你记住了，能回答上面试官的某个问题了。所以你觉得亏吗？多点感恩，少点戾气吧。<br>2018年12月5日</p>
<p>7</p>
<p>1</p>
<p>宁楠: 正能量满满，感谢支持。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/6a05a260-f9ae-11e8-9b6b-a5fce06a523c?imageView2/1/w/200/h/200" alt=""></p>
<p>快乐<br>对我来说很好很有用，覆盖了我的知识漏洞，非常感谢作者，这么多内容光整理排版就很不容易，真不知道那些鸡蛋里挑骨头的人脑子都是咋想的。<br>2018年12月5日</p>
<p>6</p>
<p>1</p>
<p>宁楠: 感谢支持，吸收对自己有用的就行了。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/f4a6ed10-f9b4-11e8-9a77-a1dd83a1c487?imageView2/1/w/200/h/200" alt=""></p>
<p>岁月静好<br>整体来说不错，虽然知识点上有遗漏，但是一篇文章能汇总这么多内容，已经很好了。提个小建议，有些问题的答案篇幅过长，可以适当精简一下，感谢作者提供这么好的一份资料。至于说东拼西凑的那些人，呵呵，无论文章写的怎么样，总会有人挑毛病，众口难调，但是起码应该尊重别人的劳动成果，心怀感恩。<br>2018年12月5日</p>
<p>6</p>
<p>1</p>
<p>宁楠: 建议收到，感谢。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/5851b530-b7ba-11e8-9d9d-aba50ff29480" alt=""></p>
<p>安于她梦<br>这从哪儿东拼西凑来的？<br>2018年12月4日</p>
<p>3</p>
<p>1</p>
<p>宁楠: 收集自网络，书，日常工作等渠道。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/e63b2960-f9d4-11e8-bf62-7b30373320ba" alt=""></p>
<p>四年<br>很不错<br>2018年12月5日</p>
<p>2</p>
<p>1</p>
<p>宁楠: 感谢支持。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/2abdf580-f175-11e8-af10-4396b0560f7c" alt=""></p>
<p>木叶<br>算法<br>2018年12月5日</p>
<p>1</p>
<p>1</p>
<p>宁楠: 开篇就是算法。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/68e23d20-5898-11e7-8049-a5327097ea48" alt=""></p>
<p>一枝花算不算浪漫<br>感觉是各种东拼西凑的东西。都什么年代了还有hibernate的面试题。<br>2018年12月4日</p>
<p>0</p>
<p>3</p>
<p>谢工: 找有用的部分有选择的看看<br>宁楠: 看你需要的，不需要的就直接忽略好么。<br>别来无恙ζ: 我就用hibernate 有什么不好么</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/d9c89ac0-76cf-11e7-bbea-b5e384e58415" alt=""></p>
<p>别来无恙ζ<br>这份Chat最适合应聘什么职位的人来看<br>2018年12月5日</p>
<p>0</p>
<p>1</p>
<p>宁楠: 无论哪个阶段的Java开发都能有所借鉴，每个人都有知识盲点。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/90089410-f45c-11e8-9bf4-dfe2abdfb7f1" alt=""></p>
<p>@<br>比较适合初学者<br>2018年12月5日</p>
<p>0</p>
<p>1</p>
<p>宁楠: 对，初学者应该好好看看。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/4950d680-f6dd-11e8-8106-33a106efcb0b" alt=""></p>
<p>Nyx<br>一般吧 跟预期有差距<br>2018年12月1日</p>
<p>0</p>
<p>1</p>
<p>宁楠: 好的。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/2d730370-ee40-11e8-875e-f9c063aa1910" alt=""></p>
<p>Mark<br>感觉不值。<br>2018年12月1日</p>
<p>0</p>
<p>1</p>
<p>宁楠: 211道题你认为多少钱值？</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/8be9d290-fda8-11e8-bc51-a7b1de7ce4f3" alt=""></p>
<p>杨丹<br>好多都是面试宝典里的内容<br>2018年12月3日</p>
<p>0</p>
<p>1</p>
<p>宁楠: 211道题，内容多了难免会有重叠。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/d9c89ac0-76cf-11e7-bbea-b5e384e58415" alt=""></p>
<p>别来无恙ζ<br>看会了一半，会有人要嘛<br>2018年12月3日</p>
<p>0</p>
<p>0</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/b2817c90-ccef-11e7-a2c1-9126334b1dc9" alt=""></p>
<p>Safari<br>43. switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上? JDK 1.7以后switch支持String类型了<br>2018年12月4日</p>
<p>0</p>
<p>1</p>
<p>宁楠: 对，答案写错了，抱歉，感谢指正。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/6e331340-f2ba-11e8-9572-13f523650544" alt=""></p>
<p>Emine<br>第一题就明显不对。Pattern p2 = Pattern.compile(“\d{6}(\d{8}).*”);，只适合18位的身份证号。15位的身份证，日期一共就6位，要这么写Pattern.compile(“\d{6}(\d{6}).*”)<br>7天前</p>
<p>0</p>
<p>0</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/faa618c0-1643-11e9-9167-29294e8d9945" alt=""></p>
<p>鼎晟<br>很棒 ^ _ ^😍<br>1天前</p>
<p>0</p>
<p>0</p>
<p>×</p>
<h4 id="文章评论"><a href="#文章评论" class="headerlink" title="文章评论"></a>文章评论</h4><p>0/200</p>
<p>提交</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FjUg5IGe5ThyN4F3BgPwVLtNUH6z?imageView2/1/h/500" alt=""><br>Chat<br>免费订</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/Frl6G1w68QeqEpWzShYkZkF0ehqs?imageView2/1/h/500" alt=""><br>课程<br>随心学</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/Fiyy0OVXYs6dh8eIcTFz0eC_PZeG?imageView2/1/h/500" alt=""><br>好书<br>每月领</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FtpKeUnInA1OgvIFtJjDKmOBO30g?imageView2/1/h/500" alt=""><br>专家<br>畅快聊</p>
<p>成为会员</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FlCRq4HauzLPJ4HG__hQg68Dutqf" alt=""><br> 热门分类</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FjgoMiaOzWmUU3JgdX3qvkBGGQ91" alt=""><br><a href="/gitchat/categories/58e84f875295227534aad506/1">前端</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FuPwXhHD3AxVmjsNdsmwGMK2Snxm" alt=""><br><a href="/gitchat/categories/58e84f53ec8e9e7b34457809/2">人工智能</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FmfNJDcE5rxC2X8GjgH8cfc8sFdW" alt=""><br><a href="/gitchat/categories/58e84f6bad952d6b3428af9a/3">架构</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/Fikw2zHy2kEE5fDxXgnH6aznmCEw" alt=""><br><a href="/gitchat/categories/5953698a3d38293ecceacb89/4">区块链</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FkEA14MZoO2nVDHiO2hRZcNASz14" alt=""><br><a href="/gitchat/categories/58e84f1584c651693437f27c/5">职场</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FidoaTbc4rvNKqFISPUs_0_NC1Xd" alt=""><br><a href="/gitchat/categories/59c491948fee063dc3c447ab/6">编程语言</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FuMNvLb25yJ4RiEg_2OnS8jpI8aB" alt=""><br><a href="/gitchat/categories/58e84f31ad952d6b3428af99/7">技术管理</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FsAwwVyxgMp5jrw3V1OzBAFRlZXd" alt=""><br><a href="/gitchat/categories/58e84f7bec8e9e7b3445780d/8">大数据</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FvClrIKCKLu4pj4tys0BMpr3IEy_" alt=""><br><a href="/gitchat/categories/591171a3e692d5280d8157b6/9">移动开发</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FhpGxdtnPjzRslCSUnNKdBXdjGLQ" alt=""><br><a href="/gitchat/categories/58e84f2284c651693437f27d/10">产品与运营</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FiDhwLN1jdKDRmYqdySCaKcw-1R3" alt=""><br><a href="/gitchat/categories/58e84f425295227534aad502/11">测试</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FrRYtPEGuW_ZbSEIUIQRHOPlzVPc" alt=""><br><a href="/gitchat/categories/591f073981be962a981acf18/12">安全</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/Fjz0BDR-Wh44YkTpn0nnZj7jqyyz" alt=""><br><a href="/gitchat/categories/5901bd477b61a76bc4016423/13">运维</a><br>Chat 是什么？ <a href="/books/5b398139328f856827673b50/index.html">了解更多</a><br>Chat 是一种全新的阅读/写作互动体验产品。一场 Chat 包含一篇文章和一场为该文章的读者和作者准备的专属线上交流。</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FugaAUCJPglWvm7ZO6Vldhc6Iq6h" alt=""></p>
<p>关注 GitChat 微信公众号</p>
<ul>
<li>获得 Chat 邀请</li>
<li>与作者实时互动</li>
<li>限时特惠不错过</li>
</ul>
<p><a href="/new/gitchat/activity">创建一场 Chat</a> <a href="/application/column">成为达人课作者</a> <a href="http://gitbook.cn/books/5ad965d38ba0ed4ba9410f27/index.html">加入我们</a> | <a href="/books/5b398139328f856827673b50/index.html">常见问题</a> | <a href="#contactUsModal">联系客服</a></p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FjUg5IGe5ThyN4F3BgPwVLtNUH6z?imageView2/1/h/500" alt=""><br>Chat<br>免费订</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/Frl6G1w68QeqEpWzShYkZkF0ehqs?imageView2/1/h/500" alt=""><br>课程<br>随心学</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/Fiyy0OVXYs6dh8eIcTFz0eC_PZeG?imageView2/1/h/500" alt=""><br>好书<br>每月领</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FtpKeUnInA1OgvIFtJjDKmOBO30g?imageView2/1/h/500" alt=""><br>专家<br>畅快聊</p>
<p>成为会员</p>
<p>热门分类</p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FjgoMiaOzWmUU3JgdX3qvkBGGQ91" alt=""><br><a href="/gitchat/categories/58e84f875295227534aad506/1">前端</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FuPwXhHD3AxVmjsNdsmwGMK2Snxm" alt=""><br><a href="/gitchat/categories/58e84f53ec8e9e7b34457809/2">人工智能</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FmfNJDcE5rxC2X8GjgH8cfc8sFdW" alt=""><br><a href="/gitchat/categories/58e84f6bad952d6b3428af9a/3">架构</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/Fikw2zHy2kEE5fDxXgnH6aznmCEw" alt=""><br><a href="/gitchat/categories/5953698a3d38293ecceacb89/4">区块链</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FkEA14MZoO2nVDHiO2hRZcNASz14" alt=""><br><a href="/gitchat/categories/58e84f1584c651693437f27c/5">职场</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FidoaTbc4rvNKqFISPUs_0_NC1Xd" alt=""><br><a href="/gitchat/categories/59c491948fee063dc3c447ab/6">编程语言</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FuMNvLb25yJ4RiEg_2OnS8jpI8aB" alt=""><br><a href="/gitchat/categories/58e84f31ad952d6b3428af99/7">技术管理</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FsAwwVyxgMp5jrw3V1OzBAFRlZXd" alt=""><br><a href="/gitchat/categories/58e84f7bec8e9e7b3445780d/8">大数据</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FvClrIKCKLu4pj4tys0BMpr3IEy_" alt=""><br><a href="/gitchat/categories/591171a3e692d5280d8157b6/9">移动开发</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FhpGxdtnPjzRslCSUnNKdBXdjGLQ" alt=""><br><a href="/gitchat/categories/58e84f2284c651693437f27d/10">产品与运营</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FiDhwLN1jdKDRmYqdySCaKcw-1R3" alt=""><br><a href="/gitchat/categories/58e84f425295227534aad502/11">测试</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/FrRYtPEGuW_ZbSEIUIQRHOPlzVPc" alt=""><br><a href="/gitchat/categories/591f073981be962a981acf18/12">安全</a><br><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/Fjz0BDR-Wh44YkTpn0nnZj7jqyyz" alt=""><br><a href="/gitchat/categories/5901bd477b61a76bc4016423/13">运维</a></p>
<p><img src="Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89//images.gitbook.cn/logo.png" alt=""></p>
<p>微信扫描登录</p>
<p>×</p>
<h4 id="帐号设置"><a href="#帐号设置" class="headerlink" title="帐号设置"></a>帐号设置</h4><p>头像<br><a href="javascript:;">选择头像</a></p>
<p>最佳分辨率：200*200像素</p>
<p>昵 称:</p>
<p>微信号:</p>
<p>头 衔:</p>
<p>背景介绍:</p>
<p>正在上传头像，请稍等……<br>正在更新，请稍等……<br>邮件地址格式不正确，请重新填写<br>此邮件地址已经被其他用户使用</p>
<p>取消保存</p>
<p>×Java 开发必备面试题详解（技术+人事）</p>
<p>请写下您的意见：</p>
<p>提交</p>
<h4 id="提-示"><a href="#提-示" class="headerlink" title="提 示"></a>提 示</h4><p>购买Chat后即可去读者圈向作者提问！</p>
<p>去购买</p>
<p><a href="https://gitbook.cn/books/5bf63a0e00fee84c8f6ad257/index.html"></a></p>

        </div>
        
        
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="menu-label has-text-centered">Like this article? Support the author with</h3>
        <div class="buttons is-centered">
            
                
<div class="notification is-danger">
    You forgot to set the <code>qrcode</code> for Alipay. Please set it in <code>_config.yml</code>.
</div>

                
                
<div class="notification is-danger">
    You forgot to set the <code>qrcode</code> for Wechat. Please set it in <code>_config.yml</code>.
</div>

                
                <!-- Visit https://www.paypal.com/donate/buttons/ to get your donate button -->

<div class="notification is-danger">
    You forgot to set the <code>business</code> and <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.
</div>

                
                
<div class="notification is-danger">
    You forgot to set the <code>url</code> Patreon. Please set it in <code>_config.yml</code>.
</div>

                
        </div>
    </div>
</div>



<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start">
            <a class="level level-item has-link-grey  article-nav-prev" href="/2019/08/02/Java%20Map%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/">
                <i class="level-item fas fa-chevron-left"></i>
                <span class="level-item">Java Map集合面试题汇总</span>
            </a>
        </div>
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/2019/08/02/10%E9%81%93%E8%85%BE%E8%AE%AF%E7%9A%84Java%E9%9D%A2%E8%AF%95%E9%A2%98/">
                <span class="level-item">10道腾讯的Java面试题</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>


</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                    <figure class="image is-128x128 has-mb-6">
                        <img class="" src="/images/avatar.png" alt="Robynn-D">
                    </figure>
                    
                    <p class="is-size-4 is-block">
                        Robynn-D
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        社長大人
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>中國台灣</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Posts
                    </p>
                    <a href="/archives">
                        <p class="title has-text-weight-normal">
                            61
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Categories
                    </p>
                    <a href="/categories">
                        <p class="title has-text-weight-normal">
                            0
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Tags
                    </p>
                    <a href="/tags">
                        <p class="title has-text-weight-normal">
                            0
                        </p>
                    </a>
                </div>
            </div>
        </nav>
        
        
        
    </div>
</div>
    
        
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Links
        </h3>
        <ul class="menu-list">
        
            <li>
                <a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener">
                    <span class="level-left">
                        <span class="level-item">Hexo</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">hexo.io</span>
                    </span>
                </a>
            </li>
        
        </ul>
        </div>
    </div>
</div>

    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Categories
            </h3>
            <ul class="menu-list">
            
            </ul>
        </div>
    </div>
</div>
    
        
    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
            <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Recent
        </h3>
        
        <article class="media">
            
            <a href="/2020/02/26/%E5%A4%A7%E7%BB%93%E5%B1%80%E5%90%8E%EF%BC%8C%E8%B0%81%E8%BF%98%E4%B8%8D%E6%9C%8D%E8%BF%99%E5%8D%8E%E8%AF%AD%E6%9C%80%E4%BD%B3%E7%88%B1%E6%83%85/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="大结局后，谁还不服这华语最佳爱情">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-02-26T08:08:42.846Z">2020-02-26</time></div>
                    <a href="/2020/02/26/%E5%A4%A7%E7%BB%93%E5%B1%80%E5%90%8E%EF%BC%8C%E8%B0%81%E8%BF%98%E4%B8%8D%E6%9C%8D%E8%BF%99%E5%8D%8E%E8%AF%AD%E6%9C%80%E4%BD%B3%E7%88%B1%E6%83%85/" class="title has-link-black-ter is-size-6 has-text-weight-normal">大结局后，谁还不服这华语最佳爱情</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/02/26/%E6%B5%AA%E6%BC%AB%E5%8C%BB%E7%94%9F%E9%87%91%E5%B8%88%E5%82%852%20-%20%E4%B8%8D%E5%AE%B9%E6%98%93%E7%9A%84%E4%BA%BA%E7%94%9F%E9%87%8C%EF%BC%8C%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%BA%BA%E9%83%BD%E5%80%BC%E5%BE%97%E8%A2%AB%E7%8F%8D%E6%83%9C/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="浪漫医生金师傅2 - 不容易的人生里，每一个人都值得被珍惜">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-02-26T06:23:36.973Z">2020-02-26</time></div>
                    <a href="/2020/02/26/%E6%B5%AA%E6%BC%AB%E5%8C%BB%E7%94%9F%E9%87%91%E5%B8%88%E5%82%852%20-%20%E4%B8%8D%E5%AE%B9%E6%98%93%E7%9A%84%E4%BA%BA%E7%94%9F%E9%87%8C%EF%BC%8C%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%BA%BA%E9%83%BD%E5%80%BC%E5%BE%97%E8%A2%AB%E7%8F%8D%E6%83%9C/" class="title has-link-black-ter is-size-6 has-text-weight-normal">浪漫医生金师傅2 - 不容易的人生里，每一个人都值得被珍惜</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/02/%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1DDD/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="领域建模DDD">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-02T06:48:51.089Z">2019-08-02</time></div>
                    <a href="/2019/08/02/%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1DDD/" class="title has-link-black-ter is-size-6 has-text-weight-normal">领域建模DDD</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/02/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%88%98%E7%95%A5/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="领域驱动设计战略">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-02T06:48:51.089Z">2019-08-02</time></div>
                    <a href="/2019/08/02/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%88%98%E7%95%A5/" class="title has-link-black-ter is-size-6 has-text-weight-normal">领域驱动设计战略</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/02/%E5%8E%BBBAT%E9%9D%A2%E8%AF%95%E5%AE%8C%E7%9A%84Mysql%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="去BAT面试完的Mysql面试题总结">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-02T06:48:51.085Z">2019-08-02</time></div>
                    <a href="/2019/08/02/%E5%8E%BBBAT%E9%9D%A2%E8%AF%95%E5%AE%8C%E7%9A%84Mysql%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" class="title has-link-black-ter is-size-6 has-text-weight-normal">去BAT面试完的Mysql面试题总结</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Archives
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2020/02/">
                <span class="level-start">
                    <span class="level-item">February 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">August 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">59</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Tags
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
            </div>
        </div>
    </div>
</div>
        
        </div>
    
</div>

                




<div class="column is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only has-order-3 column-right ">
    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Recent
        </h3>
        
        <article class="media">
            
            <a href="/2020/02/26/%E5%A4%A7%E7%BB%93%E5%B1%80%E5%90%8E%EF%BC%8C%E8%B0%81%E8%BF%98%E4%B8%8D%E6%9C%8D%E8%BF%99%E5%8D%8E%E8%AF%AD%E6%9C%80%E4%BD%B3%E7%88%B1%E6%83%85/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="大结局后，谁还不服这华语最佳爱情">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-02-26T08:08:42.846Z">2020-02-26</time></div>
                    <a href="/2020/02/26/%E5%A4%A7%E7%BB%93%E5%B1%80%E5%90%8E%EF%BC%8C%E8%B0%81%E8%BF%98%E4%B8%8D%E6%9C%8D%E8%BF%99%E5%8D%8E%E8%AF%AD%E6%9C%80%E4%BD%B3%E7%88%B1%E6%83%85/" class="title has-link-black-ter is-size-6 has-text-weight-normal">大结局后，谁还不服这华语最佳爱情</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020/02/26/%E6%B5%AA%E6%BC%AB%E5%8C%BB%E7%94%9F%E9%87%91%E5%B8%88%E5%82%852%20-%20%E4%B8%8D%E5%AE%B9%E6%98%93%E7%9A%84%E4%BA%BA%E7%94%9F%E9%87%8C%EF%BC%8C%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%BA%BA%E9%83%BD%E5%80%BC%E5%BE%97%E8%A2%AB%E7%8F%8D%E6%83%9C/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="浪漫医生金师傅2 - 不容易的人生里，每一个人都值得被珍惜">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-02-26T06:23:36.973Z">2020-02-26</time></div>
                    <a href="/2020/02/26/%E6%B5%AA%E6%BC%AB%E5%8C%BB%E7%94%9F%E9%87%91%E5%B8%88%E5%82%852%20-%20%E4%B8%8D%E5%AE%B9%E6%98%93%E7%9A%84%E4%BA%BA%E7%94%9F%E9%87%8C%EF%BC%8C%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%BA%BA%E9%83%BD%E5%80%BC%E5%BE%97%E8%A2%AB%E7%8F%8D%E6%83%9C/" class="title has-link-black-ter is-size-6 has-text-weight-normal">浪漫医生金师傅2 - 不容易的人生里，每一个人都值得被珍惜</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/02/%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1DDD/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="领域建模DDD">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-02T06:48:51.089Z">2019-08-02</time></div>
                    <a href="/2019/08/02/%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1DDD/" class="title has-link-black-ter is-size-6 has-text-weight-normal">领域建模DDD</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/02/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%88%98%E7%95%A5/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="领域驱动设计战略">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-02T06:48:51.089Z">2019-08-02</time></div>
                    <a href="/2019/08/02/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%88%98%E7%95%A5/" class="title has-link-black-ter is-size-6 has-text-weight-normal">领域驱动设计战略</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019/08/02/%E5%8E%BBBAT%E9%9D%A2%E8%AF%95%E5%AE%8C%E7%9A%84Mysql%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="去BAT面试完的Mysql面试题总结">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-02T06:48:51.085Z">2019-08-02</time></div>
                    <a href="/2019/08/02/%E5%8E%BBBAT%E9%9D%A2%E8%AF%95%E5%AE%8C%E7%9A%84Mysql%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" class="title has-link-black-ter is-size-6 has-text-weight-normal">去BAT面试完的Mysql面试题总结</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Archives
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2020/02/">
                <span class="level-start">
                    <span class="level-item">February 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">August 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">59</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Tags
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
            </div>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.svg" alt="Java 开发必备面试题详解（技术+人事）" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2020 Robynn-D&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a>
                
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("en");</script>


<script>
var IcarusThemeSettings = {
    site: {
        url: 'http://yoursite.com',
        external_link: {"enable":true,"exclude":[]}
    },
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>





<script src="/js/animation.js"></script>



<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>



<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>


<a id="back-to-top" title="Back to Top" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>














<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>