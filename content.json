{"pages":[],"posts":[{"title":"大结局后，谁还不服这华语最佳爱情","text":"大结局后，谁还不服这华语最佳爱情昨天，你们要的大结局来了。 有够夸张的。 当晚上榜三个热搜，#爱奇艺崩了#貌似也有它的锅。 早在去年12月，就郑重提醒过，切不可对它等闲视之—— 一部2019年的剧，每周一集，经过近三个月的更（酷）新（刑）播到了2020年。 开局8.0。 9.2收官。 年度最佳华语剧？ 年度最上头华语剧。 *想见你* 在等更新的日子里，粉丝们是这样的—— 这样的—— 这样的—— 《Last dance》有循环播放500遍吧。 昨天的大结局是你最想要的ending吗？ 相信见仁见智。 有惊喜。 先是上周遭遇盗版泄露风波，摄制组临时集结，在杀青九个月之后，连夜抢拍彩蛋。 也有遗憾。 比如，莫俊杰的助听器是怎么遗落在了现场？ 编剧他竟然忘记填坑了！ 忘记了！ 忘了！ 了！ 无论这个结局是否完美。 都不能掩盖《想见你》刷新我们对于台偶认知的事实。 上次写女主角柯佳嬿，评论区就有毒饭要求： 希望想见你完结后，能写一篇从头到尾的解析 大结局后，事实上剧中所有的悬疑都已经揭开，无需多做解释。 更想复盘的是。 这部跨年大戏，为什么值得**。** 01 莫比乌斯环到底指什么？ 看完大结局，第一感觉是，不对劲。 不对劲在哪？ 在强行破环。 众所周知，这部剧让人上头，其中一个最重要原因，就在它那个看似无比完美的“莫比乌斯环”剧情。好像每一个剧情，都能完美合缝。 但被结局破坏了。 黄雨萱为了挽回陈韵如的性命，在最后一次魂穿回去的时候，紧紧抱住了莫俊杰。 过去被改变了，陈韵如没死。 那么之后就不会有莫俊杰入狱，也不会有李子维来探望他，最后出车祸，魂穿到未来附身在王诠胜身上的事实。 也就不会有2010年王诠胜（实际是李子维）向黄雨萱表白，和她相爱的过程。 更不会有王诠胜飞机失事，然后黄雨萱魂穿到1998年的事。 电视剧里怎么表现这一点？ 所有相爱的证据，一一删除。 未来既然都不会发生，过去两人的种种回忆，也就不会发生了。 怎么说呢？ 还是有点牵强。 就像打破了莫比乌斯环，不是靠巧妙的剪接，而是仅仅强行将环拆开，把两个面重新翻过来，变成一张普通的纸。 但在刷过一遍又一遍之后，终于明白了关窍之处。 关键点，看这个图。 无数代表平行宇宙的意象： 窗口上那幅画，挂着无数钟表的时间之树； 黄雨萱背后出现的两个莫比乌斯环； 以及达利的扭曲钟面。 什么意思？ 是不是代表，剧情根本就不是一个莫比乌斯环，而是两个，甚至是更多的莫比乌斯环？时间其实从来未曾停过向前流逝，只不过，每一次他们在穿越的时候，都是在穿越不同莫比乌斯环？ 一个破题的情节在于—— 黄雨萱在2020年12月30日，驾着车去到海边，将伍佰的磁带从已经被破坏的播放器里拿出来，放到自己的车上。 没有sony随身听，还可以用sony车上播放器。 然后就魂穿到了1999年，陈韵如死去的那天晚上，在她眼睛睁开来那一瞬间，顺利逃走。 这一招魂穿的方法，跟谁学的呢？ 其实不是跟谁学的，而是从李子维魂穿到未来的方法被启示出来的。 关键根本不在于用什么听音乐，关键是要用sony产的播放器。 （sony打钱） 那么，李子维能够魂穿到未来，黄雨萱难道就不会一不小心魂穿到未来吗？ 不会。 因为魂穿虽然有外在条件，比如伍佰的录音带，闭着眼睛听歌等等，但它的核心条件，是“想见你”。 因为我想见你，我就能够去你那里找你。 而黄雨萱最后一次魂穿过去的1999年，是陈韵如已经自杀掉的1999年吗？不是。 在相同的时间节点，陈韵如已经死了。 而黄雨萱魂穿的时候，她还站在水泥栏杆上，拼命往上拽。 前后的动作完全不一样，只能说明—— 在上一个莫比乌斯环中，陈韵如确实已死；而在这一个莫比乌斯环，黄雨萱作为陈韵如，并没有死。 这也解释了之前，李子维曾说过的那一句话： 这个爱的循环中，似乎轮回了好多次。 ……这样的场景，是不是在这无数交错循环的时空中，早已发生过千万次，而每一次我都会像现在一样，无可救药的，爱上那个来自未来，想要改变这一切的你。 也就是说这样的穿越，已经循环了很多次，一次次迭代。 每一次都会和上次稍微不同，如果输出结果没有改变，循环就继续重复。 但每一次也会对系统造成轻微扰动，如果扰动大到打破系统稳态，循环就终止。 这也是最后一次，我们看到的结局。 这是千百次轮回修来的“正果”。 虽然黄雨萱和李子维爱情的痕迹被抹去了。 但他们也已经在一起了无数次。（虽然很虐） 编剧留给我们的安慰是，黄雨萱通过另外一种方式获得了爱情。 比李子维小十岁左右的黄雨萱本体。 当我们一直以为黄雨萱，李子维，莫俊杰，陈韵如都在爱的循环中兜兜转转时。 他们，却已经实现了蜕变，各自找到了自己的人生归宿。 02 王诠胜到底去哪里了？ 很多人都问另一个坑： 本体的王诠胜，到底去哪里了？ 表面上看，结局这个坑没有填上。 但。 透露了一点信息。 最后一集，黄雨萱在2020年的街上漫步，请看她身后的公交车站牌： 而她选择的最后一次魂穿的地点，大海前面。 这是闲笔吗？ 认为，不是。 制片人麻怡婷说：《想见你》有太多线索跟蛛丝马迹只要一个闪神就会错过。 这些蛛丝马迹对应的谁？ 在此前剧组释出的一支番外MV《蓝色初恋》中，王诠胜的真实身份得到了揭露—— 他的本体，是一个性少数群体，但被人欺负，最终跳水自杀。 而他的角色特征，就是“蓝”—— 他的耳机，蓝色；他递给心上人的毛巾，也是蓝色； 他被人欺负的厕所里，一片天蓝色的瓷砖； 他躺着的泳池，也是一片水蓝。 蓝色，英文blue，也有忧郁的意思。 联想黄雨萱最后一次魂穿后，依然安然无恙回到自己家里。 真实的王诠胜，会不会还存在在自己那个世界的莫比乌斯环里，不受飞机失事的影响，而继续生存下去呢？ 03 宝藏片头片尾曲 一切细节都不可放过。 片头片尾曲里也有机关。 片头曲的最后一个画面，和片尾曲的最早一个画面衔接上了；而片尾曲的最后一个画面，也能和片头的第一个画面对接。 同样是一个环。 黄雨萱的穿越，以及表示穿越到过去的“倒带”字符。 而王诠胜的穿越，则是表示穿越到未来的“快进”字符。 穿越成功的李子维，手里的红色金鱼，表示还未遇见的黄雨萱。 而地上的黑色金鱼，奄奄一息，表示逃不脱阴暗死亡的陈韵如。 片头里出现的所有箴言，都是演员柯佳嬿手写的。 反映的，都是与该集相同的主题。 比如，最后一集写的是： “也不是所有碎片都能拼凑，就像那些昨天无法重新拥有。” 这些碎片指什么？ 既可以指陈韵如的死无可挽回，也可以指黄雨萱在改变过去以后，从此永远失去了李子维。 一个片头片尾，把全部精华概括起来了。 04 草蛇灰线，伏延千里 有些细节，初一看也没甚用意。 过后一想，都有意义。 比如第13集开头，黄雨萱和王诠胜（实际上是李子维）在聊天的时候，陈韵如躲在心灵的小屋里。 很多观众可能没注意到的是，说话的明明是黄雨萱，可为什么陈韵如嘴唇也动了。 她怎么做？ 模仿练习。 而这，就埋伏着后期她在夺回自己身体的时候，假装黄雨萱的口吻，继续和李子维交往的情节。 这个埋伏还有二连伏，紧跟着这一段情节之后，陈韵如醒过来。 翻看着自己的笔记，寻找着日记里那一句关键的话：“他就是王诠胜。” 很多观众（包括一刷时候的），都以为这就是黄雨萱魂穿的陈韵如。 但注意看她起床时的衣服： 上面写着：me，me。 谁？陈韵如。 这就预示着，在黄雨萱魂穿失败，被囚禁在心灵小黑屋时，陈韵如已经夺回了自己的身体，计划着假装黄雨萱。 这才有了她后来翻看日记的行为，自己写上“他就是王诠胜”，以诱使黄雨萱魂穿的情节。 05 宝藏配角 《想见你》最吸引你的是什么？ 是推理烧脑？ 主线发糖？ 还是你的老公许光汉？ 其实看久了以后，感觉和剧里每个角色都熟悉了起来，感觉剧情不用发展，就像一个莫比乌斯环，在那个时光里打转就足够令人满足。 没看过剧的人，看到黄雨萱、王诠胜、陈韵如、李子维、莫俊杰，一串主要人物的名字涌上来，估计眼前一黑。 但这部剧居然把主线拍得引人入胜的同时，还藏有丰富的支线。 即使寥寥几笔，也轻松勾勒出一个有血有肉的角色。 从夜店陪酒但关怀子女的陈韵如母亲，到外表亲和但办案果断的女警。 最小的一个角色，莫过于剧集开头出现的一个技术宅男同事，可以说是配角中的配角。 他从黄雨萱的社交网络分析，她绝不可能是一个走不出情伤的人。 但这分析完全跑偏。 正如女同事接下来指出的，一个真正陷于情伤的人，不敢在社交网络赤裸裸地剖白自己。 一段对话，合情合理地利用理工男的误解，渲染起黄雨萱不外露的抑郁。 再比如，陈韵如的舅舅。 在剧中，比起全程消失的父亲、不知道怎么和孩子沟通的母亲，他好像是最关心陈韵如的亲属。 但他的关心，也没有阻止陈韵如最后选择自杀。 回看前情，也不是没有伏笔。 当黄雨萱附身陈韵如，向舅舅剖白一切时，舅舅表示了信任。 然而出门碰见陈韵如的弟弟，他才把自己的计划和盘托出—— 他没有真正相信过黄雨萱的穿越故事，他所说的话都只是安抚的说辞。 尽管穿越是一个虚构的设定，舅舅的反应却象征了许多家长的心态—— 顺意、安抚、欺骗，而对孩子真实的处境置若罔闻。 正是缺乏对于陈韵如内心真正的关怀，舅舅失去了真正拯救她的机会。 这个场景顺带牵出的又是陈韵如弟弟这个小角色。 看似对姐姐不理不睬的他，是除了李子维莫俊杰以外唯一相信过黄雨萱的人。 换句话说，也是唯一了解陈韵如的人。 06 被杀死过太多次的陈韵如 大结局的最后两集加彩蛋，其实最让感慨的，不是海边亲吻中消失的两个人。 也不是最后黄雨萱的那句“子维哥”。 而是陈韵如坠楼之前，和莫俊杰的那段对白。 莫俊杰拼命示爱，想要拯救深陷自杀情绪的陈韵如。 但陈韵如说： 莫俊杰 你打从一开始 就只是想要拯救我而已 就像当初李子维拯救你一样 你做了这么多只是要证明 你可以跟他一样去改变另一个人 但我想要的不是被拯救 我想要的是结束这一切 这段台词几乎是瞬间让想到了另一部杰作。 ——《牯岭街少年杀人事件》。 片中，小明被小四捅死前的最后一段台词，就是： 对我好，就是想要跟我交换我对你的感情。这样你就安心了，是不是？你太自私了。 要改变我？我就跟这个世界一样，这个世界是不会变的。 虽然人物关系、所处情境不同。 这两段台词表示的，都是一种强烈的幻灭感。 彻底失去了对他人的爱和信任，小明的幻灭导向麻木，而陈韵如的幻灭导向绝望。 “陈韵如们”的心声，大概就像是编剧在创作这个角色时，时常听的一首歌： 要是如此夺取他人的容身之所去生存的话 那我即使变作一块小石头也没关系的吧 那就不会感到误会或是困惑 然后就连你亦不会知道我的存在 明明想要将我对你的爱慕向你尽数倾诉 但内心却抱有对谁亦无法言道的秘密而撒下谎言 明明我是比你所想的更没有志气 为什么 为什么 为什么 要是你因失去容身之所而彷徨的话 我就会想要是能找某人来当替身就好了 在前几集陈韵如“黑化”时，很多弹幕正如莫俊杰般向她喊话： 回头看看！还有莫俊杰爱你！ 但当一头骆驼只差一根稻草就能被压垮时，单纯地拿走这根稻草，或者两根稻草，并无法改变骆驼的命运。 而《想见你》最可贵的地方，不仅在于看见了“陈韵如们”。 更在于看见了压在她们脊背上的稻草。 所以，我们看见很动人的一幕—— 所有人都喜欢的偶像剧女主角，对遭人唾弃的“反派”道歉： 一切都是我不好 是我的错 都是因为我太自私了 我不应该想要见王诠胜一面 就突然闯进你的生活 对不起 更直指内核的台词，则来自于舅舅。 黄雨萱说，都是我害的。而舅舅指出： 是我们的错 如果说黄雨萱是为了自己穿越到陈韵如身上，占据了她的人格而道歉。 舅舅的歉意，则更具有普适性。 “我们”，代表着我们每一个人。 每一个曾在不经意间陷于偏见的人。 每一个在共情之前，作出道德判断的人。 《想见你》进行的正是这样的反思。 纵观全剧，除了陈韵如之外，《想见你》里的边缘人还有很多—— 戴着助听器，少时被人欺凌的莫俊杰。 番外中亲吻男同学，最终抑郁自杀的王诠胜。 甚至，在夜店陪酒养活家庭，却不被儿女理解的陈韵如的母亲。 也许这个工作 在别人看起来是一点都不骄傲啦 但她也不会因为这样子 就觉得丢脸啊 实际上，“我们错了”的“我们”，所指的是我们。 这些生活在边缘的人们，又何尝不会是我们？ 和这个世界有过龃龉的我们。 感受过社会规则与本心悖谬的我们。 随着剧情进展到最后一集，这两种“我们”的身影，**从浮现，到逐渐交融、和解。** 编剧原本可以写一个无脑爽剧，让黄雨萱和李子维成为无忧无虑的神仙眷侣。 但他抓住了“陈韵如们”的手，告诉他们—— 不要死。 越是看这部剧，越想问一个问题—— 我们的国产电视剧，杀死过多少个陈韵如？ 有多少个可能有血有肉，有故事有灵魂的配角，被简化成万人唾骂的“贱人”、“心机婊”、“白莲花”。 或是大女主一往无前的封神路上，微不足道的尘埃？ 不用我说，你脑海中已经浮现了一些剧名。 《锦绣未央》《三生三世十里桃花》《微微一笑很倾城》《孤芳不自赏》《楚乔传》…… 无论片长有多注水，永远是这样程式化的剧情和角色塑造—— 站在艳冠群芳、才思敏捷的女主的对立面。 一群面目模糊的“战五渣”，使出种种手段陷害女主角，再被主角男女混合手撕强怼。 )) 分明的善恶观像加多了味精的速食快餐，爽得观众昏天黑地。 但爽劲过去后，除了干渴和晕眩，这些快餐又留下了什么？ 陈韵如在这些故事里过于轻易地死去。 甚至至死，你也没记住她叫陈韵如。 《想见你》结局了。 庆幸，我们终于认识了陈韵如。 更庆幸，那个世界上，黄雨萱和陈韵如都活了下去。 因为那正是我们。 我们，和我们。","link":"/2020/02/26/%E5%A4%A7%E7%BB%93%E5%B1%80%E5%90%8E%EF%BC%8C%E8%B0%81%E8%BF%98%E4%B8%8D%E6%9C%8D%E8%BF%99%E5%8D%8E%E8%AF%AD%E6%9C%80%E4%BD%B3%E7%88%B1%E6%83%85/"},{"title":"浪漫医生金师傅2 - 不容易的人生里，每一个人都值得被珍惜","text":"浪漫医生金师傅2 - 不容易的人生里，每一个人都值得被珍惜 낭만닥터 김사부2 (2020) 豆瓣: ★8.3/10 IMDb: ★0.0/10 韩国 / 剧情 / 2020-01-06(韩国)首播 / 16集 / 片长80分钟 该剧以位于地方城市的石垣医院为背景，讲述怪胎天才医生金师傅和热情高涨的年轻医生们之间的故事。由第一季的刘仁植导演、姜银庆编剧再次合作。 金师傅2与第一季，还是有蛮多不同的。感受到了编导们在3年后，抓住了时代发展的特点，去创设人物、讲述故事：选择了形象更年轻的演员、让他们中最起码一两个人有了“正常”的家庭成长背景、为她们赋予了当下年轻人的特色。 年轻主角的重要成长点，也不是放在最后。放在最后的，是朴教授作为一个成年人的选择。这个选择，比起年轻人的成长，要模糊的多，你很难说他以后还会与金师傅在哪些方面合拍、哪些方面不和，这与年轻人的成长不同，年轻人的成长是从自我的冲突中，经由金师傅的教导和熏陶，貌似就找到了路，清晰且坚定。但成年人不同，他们不会像一个孩子一样，那么容易完全信任，他们不太可能将自己完全交付给另一个人。所以如果有第3季，说不定他们互动的点也还是蛮有意思的地方。 这一次，有更多的空间去描述不同患者的故事，从短小的篇幅里，看到不同人的人生。比如：国防官员的秘书兄弟，责任感和兄弟情一样感人和令人敬佩；急救队员和妈妈的故事，催泪到极致又让人感受到这个世界如此温暖；无期徒刑男孩的故事、家暴的故事，令人无比心痛；院长，让我们看到一个温柔睿智的老人，如何有尊严地选择自己的人生…… 徐宇镇的人生，前半段是关于生存权的斗争过程。真难想象，在那样的境遇下，他是怎样能成长为三观正、业务强的帅气男孩的。也许越是有人曾要剥夺他的生存权，他越是争气地要活出自己来，这就是他顽强的生命力。虽然之后的每一步，都如此不易，他决不轻易妥协。但是啊，就是这样的男孩，也需要有人告诉他，他值得活下来，作为一个生命，值得被看到、被认可、被爱，在经历那样的生活后，也需要有人能够跟他说对不起，虽然他压根不可能真正得到想要的那们道歉。但是像父母亲一样的成年人，愿意在做错事情上，向自己道歉，也是一种替代吧？所以，当护士长、当张室长向他道歉时，他的内心也得到了抚慰吧。金师傅对宇镇的偏爱，连都仁范都“吃醋”，我也为姜东柱吃醋，可是我也能想到，这是给他的最好的礼物啊，被看重、被珍惜，是宇镇心底那个男孩无声的呐喊吧！终于，有人听到，所幸，有人回应！有了师傅、有了爱人、有了家人一样的同伴，从此的人生路，生活得不再那么辛苦了吧，爱会让人即使做同样的事情，但是可以充满力量了吧？ 车恩在是一个当下家庭的模范生标准。有着看起来幸福完满的家庭，以为这样就不会有成长的苦恼了吗？其实每个人的成长都不是那么容易的。爸爸和哥哥的优秀，成了她人生的榜样，这样的榜样，一不小心就成了压力和负担。妈妈的期待灌注在女儿身上，这份沉重，足以让人喘不过气来，所以拼尽全力的车恩在，在手术室里，就喘不过气来了。按照别人的期待活着、小心翼翼地做好自己、怕自己让人失望给人带来麻烦，又哪里是容易的人生？还有车恩在的复原力简直太棒了，这也是幸福家庭带给孩子的礼物，即使她受了伤，可是有一点点助力，她就能恢复，爱的力量就是这么强大。 朴教授的人生真是，可能他在遇到公交车事件前，过的都是一帆风顺、充满自信的人生。可就是在公交车上，金师傅变成了他的镜子，映射出他的善良的限度。不堪接受自己没有那么好的一面，把内心糟糕的感觉和想法投射到别人身上，是一种常见的防御机制。但这种防御机制，往往是自己非常习惯使用的一种，它曾经给过人保护，但是习惯的越久，改变起来遇困难。这是朴教授面临的现实情况。看到他最后脱下西装，走近患者的时候，那么帅气和坚定，慢慢领会到“放下屠刀，立地成佛”的深意，小的时候一直不理解，为什么做了那么多坏事的人，不做坏事了，就能成佛，回馈也太好了，还有很多人一直没做过坏事不是吗？此刻，却突然理解了，没有人的人生是容易的，最初拿起屠刀，自然有拿起屠刀的缘故，打碎过往的自己，做出全新的选择，对谁而言，都是一个艰难的过程。 最后，喜欢斐文正医生。就这样。","link":"/2020/02/26/%E6%B5%AA%E6%BC%AB%E5%8C%BB%E7%94%9F%E9%87%91%E5%B8%88%E5%82%852%20-%20%E4%B8%8D%E5%AE%B9%E6%98%93%E7%9A%84%E4%BA%BA%E7%94%9F%E9%87%8C%EF%BC%8C%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%BA%BA%E9%83%BD%E5%80%BC%E5%BE%97%E8%A2%AB%E7%8F%8D%E6%83%9C/"},{"title":"10道腾讯的Java面试题","text":"10道腾讯的Java面试题下面总结10道面试腾讯的Java面试题。1、说几种常见的攻击方式及预防手段。 - XSS/CSRF/DDOS具体参考之前的文章。 2、http1.x和http2.x的区别。 - http2.0增加多路复用、二进制分帧、首部压缩、服务器推送。 3、mysql查询语句怎么做性能分析。 - 使用explain或者profile命令，具体参考之前的文章。 4、你知道哪几种排序算法？ - 冒泡、选择、插入、希尔、快速、堆、归并、桶排序。 5、HashMap和HashTable的区别，并说明其底层实现数据结构。 - HashMap非线程安全，HashTable线程安全，具体参考之间的文章。 6、HashMap满了之后怎么扩容？ - loadfactor为扩容因子，当数据容量超过最大容量*loadfactor时容量自动扩大2倍，并将当前的数据重新放入新的hashmap中，所以初始的定义大小为2^n的大小最佳。 7、Linux中远程传输文件有什么方式？ - SCP、FTP等。 8、说说Java中异常的分类。 - Throwable子类Exception、Error。 9、TCP和UDP的区别，TCP为什么是三次握手，不是两次。 - 1.基于连接与无连接 2.TCP要求系统资源较多，UDP较少。 3.UDP程序结构较简单。 4.流模式（TCP）与数据报模式(UDP)。 5.TCP保证数据正确性，UDP可能丢包。 6.TCP保证数据顺序，UDP不保证。 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误，即重要的事情说三遍 10、说说数据库设计的三范式，可以违反三范式吗？ - 第一范式，又称1NF，它指的是在一个应用中的数据都可以组织成由行和列的表格形式，且表格的任意一个行列交叉点即单元格，都不可再划分为行和列的形式，实际上任意一张表格都满足1NF； 第二范式，又称2NF，它指的是在满足1NF的基础上，一张数据表中的任何非主键字段都全部依赖于主键字段，没有任何非主键字段只依赖于主键字段的一部分。即，可以由主键字段来唯一的确定一条记录。比如学号+课程号的联合主键，可以唯一的确定某个成绩是哪个学员的哪门课的成绩，缺少学号或者缺少课程号，都不能确定成绩的意义。 第三范式，又称3NF，它是指在满足2NF的基础上，数据表的任何非主键字段之间都不产生函数依赖，即非主键字段之间没有依赖关系，全部只依赖于主键字段。例如将学员姓名和所属班级名称放在同一张表中是不科学的，因为学员依赖于班级，可将学员信息和班级信息单独存放，以满足3NF。 某些业务设计可以违反三范式。","link":"/2019/08/02/10%E9%81%93%E8%85%BE%E8%AE%AF%E7%9A%84Java%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"2017年开发者都在学什么？","text":"2017年开发者都在学什么？简单的流量控制系统 http://www.tuicool.com/articles/3yu6VzN拯救你的旧代码库，不得不看的11条军规 http://www.tuicool.com/articles/BFN7nuQ网卡厂商自动识别工具 http://www.tuicool.com/articles/NJFBBjm容器化部署OpenStack的正确姿势 http://mp.weixin.qq.com/s/ZKpbXhlstQMZMgI9xQtPSA运维的一天：架构设计、故障处理、人员离职 http://mp.weixin.qq.com/s/e66vOVhh3FNDm6Pb1imRpA自动化运维之架构设计六要点 | 腾讯大梁专栏 http://mp.weixin.qq.com/s/AM5-2mnf6XuuMEu8b86jMQ亲！用什么来保护你，我的运维安全 http://mp.weixin.qq.com/s/MCEXn2vEZXtFtXzbB-hRXQ精益之道 | 浅析广发银行大数据平台演变 https://mp.weixin.qq.com/s/KYK2R-IIr82MTyyfyZp3KA做好CMDB并不足够，运维还需要做好应用配置管理 http://mp.weixin.qq.com/s/xihZ47nwlgOI1Px8vUmKJQ数据中心运维管理 | 资料汇总（2017.7.2版本） http://mp.weixin.qq.com/s/e1_JBr_r6GYcsqPS8nSG3g实录丨不以敏捷开发为基础的DevOps都是耍流氓 http://mp.weixin.qq.com/s/hl5KQevQLYyRXoy-D0qSog承载新美大3万台服务器的云计算基础运维 http://mp.weixin.qq.com/s/n1PHyva6o_4frs0ufS5e1ALinux主流Web服务架构的运维工作简单剖析 http://mp.weixin.qq.com/s/zhymPaWJSfowjmyn8DZPdA深入解析运维故障处理方法 http://mp.weixin.qq.com/s/XNSdqipFMgdRT7NndLQKEw发生网络安全事件怎么办？看看中央网信办的最新预案 http://mp.weixin.qq.com/s/zSmUETFYxmGGpUtP1bvhxgLinux 中 FTP 服务器的搭建 https://mp.weixin.qq.com/s/btX531R-q_NG5E5Z2YfFLQ使用nginx+Lua+GraphicsMagick实现图片自动裁剪 http://ylw6006.blog.51cto.com/470441/1830002EasyReport(ver2.0) https://github.com/xianrendzw/EasyReport/blob/master/docs/manual/version2_0.md【老生常谈的】互联网协议 http://mp.weixin.qq.com/s/YoV3ULSUyBJv44jpk7QTwgARP理论知识详解 http://mp.weixin.qq.com/s/YCeY6IdznFB9_vO77tD6mw从无到有：熊猫直播 Rancho 发布系统构建之路 https://mp.weixin.qq.com/s/SjhUc01_aG5fA5mbDjUFnA统一集中数据备份管理系统 http://mp.weixin.qq.com/s/GkUxlIPhuzqMTwePkWgSsw详解RDMA(远程直接内存访问)架构原理 http://mp.weixin.qq.com/s/7P6kiPlUkCb7pcGJOEsBjw魅族资深DBA：利用MHA构建MySQL高可用平台 http://mp.weixin.qq.com/s?__biz=MzI4NTA1MDEwNg==&amp;mid=2650757285&amp;idx=1&amp;sn=70417d324610c704c1166673aec17f9b&amp;chksm=f3f9ed30c48e6426d4f3c28e3fb2eb5a6594b30b6a6be975d5fd6137eea75bec86eec99611fc&amp;mpshare=1&amp;scene=1&amp;srcid=11030DsiNOZREhnqlWWPXJRa#rdLinux之磁盘阵列(RAID) http://mp.weixin.qq.com/s/mgi-TYF_f4U21MZg6Ormdg1对多业务，数据库水平切分架构一次搞定 | 架构师之路 http://mp.weixin.qq.com/s/kOTz5XAeAcUI2gzKl7AEHwOpenStack 七年盘点，热潮褪去后的明天在哪？ http://mp.weixin.qq.com/s/Fk2S-NNDbKPWyhOArF5Hlw从0到1，蘑菇街怎样打破应用运维自动化的技术藩篱？ https://mp.weixin.qq.com/s/ey6mcaDNXMsn1cJwz4I1QQ从BI到AI只差数据科学平台的距离？ http://mp.weixin.qq.com/s/5A13wR7JTYxNU3UmYhX3zwGIT版本控制 — GIT与SVN的相互转换 (三) http://blog.csdn.net/zhangskd/article/details/43452627怎样选择适合的数据中心架构 http://mp.weixin.qq.com/s/Csr4EMcH6lOY8K3ZzBaVTA一次心惊肉跳的服务器误删文件的恢复过程 http://mp.weixin.qq.com/s/eBvuc2y4fVCwUHsmQeHt1A企业数据备份相关容量和性能满足 http://mp.weixin.qq.com/s/w1Gw1CDLa-GlsHXWVRjfQw统一集中数据备份管理系统 http://mp.weixin.qq.com/s/GkUxlIPhuzqMTwePkWgSsw数据备份方案 http://mp.weixin.qq.com/s/zPscVkomVuD8BZQEWqe0Gg携程的Web漏洞扫描系统实现细节 https://mp.weixin.qq.com/s?__biz=MzIwMzg1ODcwMw==&amp;mid=2247486194&amp;idx=1&amp;sn=58b7b1336313bc254c83b72e533091d8&amp;source=41#wechat_redirect从中华武术谈运维工程师以及运维自动化 http://mp.weixin.qq.com/s/p1UNrbW7aQa6RgqrB4k1uQ如何挖掘Nginx日志中隐藏的金矿？ http://mp.weixin.qq.com/s/t-ktlzJsrpad1-YRuIakiw虚拟化项目-规划备份和灾难恢复 https://mp.weixin.qq.com/s/Izezx3adJqK3OJX-0qY9ig要想 Linux 优化好，这8个步骤少不了~ http://mp.weixin.qq.com/s/Wch3e-m-dprx40NL_VWmfA电商网站为例，谈大型分布式架构设计与优化 http://mp.weixin.qq.com/s/xc2L7hqxBaOwnSAXw_kUjwIptables小技巧 http://mp.weixin.qq.com/s/LKSm2juGR0vH12w4e1pL-Q饿了么MySQL异地多活的数据双向复制经验谈 http://mp.weixin.qq.com/s/SNTe4-8AddDZ0rS1G9PN9A 如何打造一个全程联动、环环相扣的安全审计系统？ http://mp.weixin.qq.com/s/4ksiLZZSkrALhKEEx8U_uwhttp://www.freebuf.com/wenku渗透测试：我的企业安全经验之账号安全 http://www.cnseay.com/4130/安全扫描器：IBM Appscan8.7破解版下载 强大的web安全漏洞扫描器 http://www.cnseay.com/3366/工具推荐：Linux下各种实用的安全工具打包推荐 http://www.cnseay.com/3382/实用工具：猜密码，精准的分析个人密码 http://www.cnseay.com/4203/服务器安全配置linux服务器安全配置 http://www.cnseay.com/110/运用动态安全域保护企业网的方法 http://www.cnseay.com/534/nginx+naxsi搭建开源免费WAF防火墙 http://blog.sina.com.cn/s/blog_5376c7190102wnrm.htmlmodSecurity和Naxsi哪个更适合Nginx搭建WAF http://www.cnblogs.com/rainy-shurun/p/5374782.html企业安全建设之使用开源软件建设大规模WAF集群 http://www.freebuf.com/special/127713.htmlWeb应用防护系统OpenWAF开源CC防护模块 http://os.51cto.com/art/201703/536081.htm企业linux安全运维理念和实战 安全/运维必看 http://www.cnseay.com/3557/安全运营：弱口令，企业安全的坟墓 http://www.cnseay.com/3844/经验之谈：乙方安全服务与安全产品感悟 http://www.cnseay.com/4142/安全运营：企业安全实践经验分享 http://www.cnseay.com/4191/企业安全：人员安全管理之黑客怎么入侵员工 http://www.cnseay.com/4270/企业安全：员工行为难管控 http://www.cnseay.com/4434/企业安全：为何总有修不完的漏洞 http://www.cnseay.com/4443/內建安全的软件开发 https://www.testwo.com/article/709性能测试监控工具nmon安装及使用方法 http://www.cnseay.com/1040/ AI时代，我们离AIOps还有多远？ http://mp.weixin.qq.com/s/iUdTVm498Egz-cODL8AZJQ运维未来的发展方向是智能运维 http://mp.weixin.qq.com/s/-wb1unlBxpVfUqabLbhZOw宜信、百度和阿里AIOps落地实践经验谈 http://mp.weixin.qq.com/s/q8FXUFXLSlAeze7bN_RbDg如何打造一个全程联动、环环相扣的安全审计系统？ http://mp.weixin.qq.com/s/4ksiLZZSkrALhKEEx8U_uw一张思维导图，包罗最全监控体系建设要点！ http://mp.weixin.qq.com/s/1Qq-Sx18ND3aOMPsw3MbtASysdig：Linux服务器监控和排障利器 http://mp.weixin.qq.com/s/1O5PSYFEZg2y22uhYBliKQ到底该如何理解AIOps？又如何落地AIOps？ http://mp.weixin.qq.com/s/WQ4o3EVm7Imo2iX_YDJRlA 数据中心：数据中心未来趋势 http://mp.weixin.qq.com/s/afiHcagkk4h9bqWjBce2RA数据中心基础设施管理 http://mp.weixin.qq.com/s/Z9J_mq15RTF51C89LAVKkw案例 | 中国银行数据中心基础设施可视化运维管理 http://mp.weixin.qq.com/s/GIJqEEws_7_bzgLUc_YYqA某银行省级数据中心IT运维服务体系建设完整思路 http://mp.weixin.qq.com/s/3ON23H93uZlSn_qAmSqVDg视频 | 如何在2分钟建成一个数据中心 http://mp.weixin.qq.com/s/6nxMIb6YsaTUXhfdt0aQsgCIO必须知道的关于数据中心宕机的10个问题 http://mp.weixin.qq.com/s/3qZ4DgwVUEYDTpnujc9nowmhVTL的安装与应用 http://mp.weixin.qq.com/s/M19ClUa6oT_XlGKK0kvUzg你的数据备份到了公有灾备混合云 http://mp.weixin.qq.com/s/RoFWVoE9qqkmSyh33sD05w规划备份和容灾恢复解决方案 http://mp.weixin.qq.com/s/slDhd1amdp-pvQC9W7ISJg某银行省级数据中心IT运维服务体系建设完整思路 http://mp.weixin.qq.com/s/kSbEV6VbAeirwT-jLRj7HA优化网站性能必备的6种架构方案，你知道吗？ http://mp.weixin.qq.com/s/TtDa-siYGeW-JPp_bSXmQA阿里8年资深技术专家谈企业级互联网架构的演进之路 http://mp.weixin.qq.com/s/7myfJtGW8P9MwdN72b9uXgext3，ext4，xfs和btrfs文件系统性能对比 http://mp.weixin.qq.com/s/F06RMyoH7qqsUmTHT01jWw一个细节翔实、可供参考的支付体系架构演进实例 http://mp.weixin.qq.com/s/qCUCMkupgYp2D3AfWH2QPQ可同时支撑5~10个618大促的数据库做了哪些性能优化？ http://mp.weixin.qq.com/s/6fY0-UFOmm2hDY-tQ50NIQ宜信、百度和阿里AIOps落地实践经验谈 http://mp.weixin.qq.com/s/q8FXUFXLSlAeze7bN_RbDgJenkins &amp; Docker 持续集成实践 http://mp.weixin.qq.com/s/xi7pZmMMVZZlBNee-Md-Ig运维未来的发展方向是智能运维 http://mp.weixin.qq.com/s/-wb1unlBxpVfUqabLbhZOw解决航空IT“事故”新思路 ——用日志打通整个系统 http://mp.weixin.qq.com/s/W2bmLZahlZNZs1qBwJXaTwSysdig：Linux服务器监控和排障利器 http://mp.weixin.qq.com/s/1O5PSYFEZg2y22uhYBliKQJenkins &amp; Docker 持续集成实践 http://mp.weixin.qq.com/s/Uj5bdT3Iqxrz9ovKLOEMOgMySQL 到底能不能放到 Docker 里跑？ http://mp.weixin.qq.com/s/LhCHEkSstmru4PnrfuoaVg任务机器人在金融运维中的落地实践 http://mp.weixin.qq.com/s/8faMmSr0MUqk7263Bl67tg到底该如何理解AIOps？又如何落地AIOps？ http://mp.weixin.qq.com/s/WQ4o3EVm7Imo2iX_YDJRlA饿了么MySQL异地多活的数据双向复制经验谈 http://mp.weixin.qq.com/s/gskMG1n6zQQR_UOntmbNEg谈谈移动应用的安全性实践 http://mp.weixin.qq.com/s/gkTr0h0umkwB9VP07vZ0LA关于极限头脑风暴的清单 http://mp.weixin.qq.com/s/SUFGUw6dRyoqEu3Reci07g sonar0day漏洞http://www.centoscn.com/CentosSecurity/http://mp.weixin.qq.com/s/58e9_8LUNcjw8eueh9s2kg 外部扫描系统openvas：https://github.com/mikesplain/openvas-docker自建CVE库cve search：https://github.com/cve-search/cve-search开源威胁情报OSTrICa：https://github.com/Ptr32Void/OSTrICa 说起开源安全审计工具，业界最知名的恐怕就是Cisofy主导的Lynis和社区主导的Ossec，两者各有千秋，是否一定要2选1，笔者认为这个没有统一答案。当然，在本文中，会有一个对比，然后给出建议。 系统安全审计NetHogsClamAV http://www.clamav.net/Lynis：*nix系统上使用Shell编写的系统安全审计工具安装方式：Debian：apt-get install lynis Ossec：支持全平台的主机入侵检测系统","link":"/2019/08/02/2017%E5%B9%B4%E5%BC%80%E5%8F%91%E8%80%85%E9%83%BD%E5%9C%A8%E5%AD%A6%E4%BB%80%E4%B9%88%EF%BC%9F/"},{"title":"7 個線上接收手機簡訊驗證碼的免費網路服務整理","text":"7 個線上接收手機簡訊驗證碼的免費網路服務整理（Copyright: bacho12345 / 123RF Stock Photo ） 一直以來 Email 和手機號碼都是線上服務用來驗證使用者身分的主要方式，現在還加入直接以第三方帳號例如 Google、Facebook 註冊登入，這些過程不外乎是減少被短時間內大量註冊或濫用的可能性，但某些時候我們並不希望被知道真實身分，就可以使用一些方法繞過驗證，例如註冊時透過用後即丟的 暫時信箱 收驗證信，手機方面也有 臨時手機號碼 可以使用，就能夠在不被得知真實資料的情況下完成註冊或通過身分認證等程序。 手機號碼牽涉的層面較多、較複雜，相較於暫時信箱來說這類服務就更少一些，而且多半是所有人共用號碼，當然也會看到其他人的簡訊內容。 但如果是要用於註冊帳戶通過驗證，或者想收一則簡訊又不希望告訴對方真實號碼，本文要介紹的 7 個線上收手機簡訊驗證碼的免費服務或可研究一下，這些工具雖然功能和介面很簡單陽春卻很實用。 另一方面，當你臨時需要某個國家的手機門號，也能從這裡碰碰運氣，不過並不保證永久固定或有效，如果你想要一個能長時間使用的國外手機號碼，也能參考「 Ring4 在手機上產生美國等各國手機號碼，可撥打電話及收發簡訊 」註冊一個，價格隨著不同國家而有所差異。 但也必須提醒使用者，無論是暫時信箱或暫時手機號碼等匿名工具都有非常完整的使用記錄，因此請別抱持僥倖心態將它做為詐欺或非法用途。以下要介紹的服務皆從網路整理，不保證可以持續穩定提供服務，如果無法使用，請換其他同性質服務再試一次。 1. Receive SMS Online網站鏈結： https://receive-sms.com/ 如果你想保護個人隱私，不希望對方獲取你的真實手機號碼，Receive SMS Online 就是一個很實用的工具，每次在首頁會有六個美國手機號碼，點擊後就能開啟簡訊收件匣，缺點是所有的簡訊都會公開於首頁，也無法刪除隱藏，不過可以正常顯示中文內容。 2. Receive FREE SMS Online網站鏈結： http://receivefreesms.com/ Receive FREE SMS Online 提供 24 組來自世界各地的拋棄式、隨用即丟的手機號碼，涵蓋地區包括美國、英國、德國、巴西、俄國、法國、澳大利亞、加拿大、瑞士、印尼、以色列、西班牙和香港，無需註冊，也提供付費租用各國門號，最低可租用一個月。 3. Receive SMS Online網站鏈結： https://www.receivesmsonline.net/ 跟其他同質性的服務類似，Receive SMS Online 提供美國、英國、加拿大地區的臨時免費手機號碼，用於註冊服務或通過身分驗證，它和下一個服務 Free Online Phone 來自同一公司，要使用網站上的任一號碼，只要點擊下方的按鈕就能開啟簡訊收件匣，不過不提供付費功能。 4. Free Online Phone網站鏈結： https://www.freeonlinephone.org/ 和前一個服務來自同公司，介面看起來有點像，一樣提供美國、英國、加拿大和瑞士四個國家的隨機手機號碼，網站首頁會顯示每個號碼目前總共收到多少簡訊，點擊 Read SMS 開啟簡訊收件匣，可正常顯示中文，且寄件者的號碼會有部分隱藏，應該有助於提高一些隱私及安全性。 5. Receive SMS Online網站鏈結： http://receive-sms-online.com/ Receive SMS Online 提供八組會隨時間更動的手機門號，包括英國、德國、挪威、烏克蘭及波蘭等國家，點擊後會顯示最近 24 小時接收到的所有簡訊數量、使用時間及簡訊內容，寄件者部分會顯示完整電話號碼，也能正常顯示中文，簡訊無法刪除，也不提供付費功能。 6. Sellaite SMS Receiver網站鏈結： http://sms.sellaite.com/ 看起來非常陽春、好像上個時代的網頁設計風格，不過別擔心，Sellaite SMS Receiver 確實是可以使用的，這個服務提供三個愛沙尼亞（Estonia）手機號碼，不用註冊、登入就能接收簡訊，也可在網頁中正常顯示中文，但不提供付費傳送簡訊項目。 7. Receive SMS Online for Free網站鏈結： http://hs3x.com/ 這個網站對於驗證各種服務，例如 Google、Yahoo、Microsoft、Amazon、VK 等等算得上非常好用，它提供一些虛擬手機號碼來接收 SMS 簡訊，不用註冊，直接選擇號碼然後按下 Read SMS 來查看所有簡訊，跟其他服務差不多。如果需要也可付費購買虛擬門號。 7 個線上接收手機簡訊驗證碼的免費網路服務整理","link":"/2019/08/02/7%20%E5%80%8B%E7%B7%9A%E4%B8%8A%E6%8E%A5%E6%94%B6%E6%89%8B%E6%A9%9F%E7%B0%A1%E8%A8%8A%E9%A9%97%E8%AD%89%E7%A2%BC%E7%9A%84%E5%85%8D%E8%B2%BB%E7%B6%B2%E8%B7%AF%E6%9C%8D%E5%8B%99%E6%95%B4%E7%90%86/"},{"title":"Dubbo面试题锦集","text":"Dubbo面试题锦集1、默认使用的是什么通信框架，还有别的选择吗? 2、服务调用是阻塞的吗？ 3、一般使用什么注册中心？还有别的选择吗？ 4、默认使用什么序列化框架，你知道的还有哪些？ 5、服务提供者能实现失效踢出是什么原理？ 6、服务上线怎么不影响旧版本？ 7、如何解决服务调用链过长的问题？ 8、说说核心的配置有哪些？ 9、dubbo推荐用什么协议？ 10、同一个服务多个注册的情况下可以直连某一个服务吗？ 11、画一画服务注册与发现的流程图 12、集群容错怎么做？ 13、在使用过程中都遇到了些什么问题？ 14、dubbo和dubbox之间的区别？ 15、你还了解别的分布式框架吗？ 以上不完全总结了dubbo面试过程中的一些问题，也是实际使用过程中经常会注意到的地方，虽然dubbo没有更新了，但国内使用还是挺多，里面的实现思想还是挺好的，也值得学习。","link":"/2019/08/02/Dubbo%E9%9D%A2%E8%AF%95%E9%A2%98%E9%94%A6%E9%9B%86/"},{"title":"Api接口安全性设计","text":"Api接口安全性设计Token授权机制：用户使用用户名密码登录后服务器给客户端返回一个Token（通常是UUID），并将Token-UserId以键值对的形式存放在缓存服务器中。服务端接收到请求后进行Token验证，如果Token不存在，说明请求无效。Token是客户端访问服务端的凭证。 时间戳超时机制：用户每次请求都带上当前时间的时间戳timestamp，服务端接收到timestamp后跟当前时间进行比对，如果时间差大于一定时间（比如5分钟），则认为该请求失效。时间戳超时机制是防御DOS攻击的有效手段。 签名机制：将 Token 和 时间戳 加上其他请求参数再用MD5或SHA-1算法（可根据情况加点盐）加密，加密后的数据就是本次请求的签名sign，服务端接收到请求后以同样的算法得到签名，并跟当前的签名进行比对，如果不一样，说明参数被更改过，直接返回错误标识。签名机制保证了数据不会被篡改。 拒绝重复调用（非必须）：客户端第一次访问时，将签名sign存放到缓存服务器中，超时时间设定为跟时间戳的超时时间一致，二者时间一致可以保证无论在timestamp限定时间内还是外 URL都只能访问一次。如果有人使用同一个URL再次访问，如果发现缓存服务器中已经存在了本次签名，则拒绝服务。如果在缓存中的签名失效的情况下，有人使用同一个URL再次访问，则会被时间戳超时机制拦截。这就是为什么要求时间戳的超时时间要设定为跟时间戳的超时时间一致。拒绝重复调用机制确保URL被别人截获了也无法使用（如抓取数据）。 1234567891、客户端通过用户名密码登录服务器并获取Token2、客户端生成时间戳timestamp，并将timestamp作为其中一个参数3、客户端将所有的参数，包括Token和timestamp按照自己的算法进行排序加密得到签名sign4、将token、timestamp和sign作为请求时必须携带的参数加在每个请求的URL后边（http://url/request?token=123&amp;timestamp=123&amp;sign=123123123）5、服务端写一个过滤器对token、timestamp和sign进行验证，只有在token有效、timestamp未超时、缓存服务器中不存在sign三种情况同时满足，本次请求才有效","link":"/2019/08/02/Api%E6%8E%A5%E5%8F%A3%E5%AE%89%E5%85%A8%E6%80%A7%E8%AE%BE%E8%AE%A1/"},{"title":"Amazon 2018 黑五折扣精选 « 美国攻略","text":"Amazon 2018 黑五折扣精选 « 美国攻略2018年的黑色星期五是11月23日。在美国，黑五标志着圣诞购物季的正式开始，是一年中零售商家最看重、最繁忙、通常也是折扣最大的日子。下面是 Amazon 在黑五期间的折扣精选，我们会持续更新。 相关信息和攻略 Amazon 黑五活动主页： www.amazon.com/black-friday 2018 美国黑五攻略： www.gonglue.us/black-friday 2018 黑五全网折扣精选： www.gonglue.us/deals Costco 黑五期间折扣精选： www.gonglue.us/costco-deals 网上下单购物返现： www.gonglue.us/rebatesAmazon 黑五期间折扣精选 【11/21】Dyson 多款机器特价 Dyson 多款机型在 Amazon 出现特价，都是很好的价格！ V10 Absolute：$523.94 - $43.95 = $479.99 @ https://amzn.to/2DTesGB V10 Animal： $465.49 - $65.50 = $399.99 @ https://amzn.to/2Tyxwyw V8 Absolute $348.90 - $44.91 = $303.99 @ https://amzn.to/2LrcHQP Ball Animal 2： $299 - $59.01 = $239.99 @ https://amzn.to/2OWhpXV Ball Multi Floor 2：$249 - $49.01 = 199.99 @ https://amzn.to/2Br7KFr精选杂志订阅$5/年 亚马逊现有 精选杂志订阅 $5/年，家具美食亲子类都有，有纸质也有 Kindle 版。比如 Reader’s Digest 一年10本仅$5，每本才50c！杂志订阅包括自动续订，年底记得去取消。 Braun 电动剃须刀 Braun 790cc 无线剃须刀 + Clean &amp; Charge Station，标价 $289.99、现 Amazon 售价 $169.94 - extra $40 off coupon - 收货后 Braun 官方有 $30 off mail in rebates，相当于实价 $99.94。这个价格比 Costco 的裸货版（没有 charge station）还要便宜，是我看到的历史最低价。790 CC 本身是非常好的剃须刀，我用的就是它： https://amzn.to/2DDMIVA 。 如果预算充足的话还可以买 9 系列（我没用过）： 9290cc 标价 $384.99、现 Amazon 售价 $249.94 - extra $50 off coupon - $50 off mail in rebates = $149.94，同样是历史最低价： https://amzn.to/2FBeiVN 。 Mail in rebates 活动12月31日截至，使用说明在这里： https://bit.ly/2QeQV8w 。若喜欢 Panasonic 的话现在 ES-LV65-S 原价 $199.99、现价 $119.99，不是历史最低价，但也是不错的价格： https://amzn.to/2KpdYIK 。 Aprilis 浴盐 340g / 120z 原价 $13.99，现 Amazon 有 5% 自动折扣，使用 JEN8ABJ7 另有 $7 off，我刚才试了一下只要 $6.29，且送到 Virginia 无运费无税： https://amzn.to/2OT9Lxn 三星 SSD 固态硬盘三星 1TB SSD 硬盘标价 $199，Amazon 过去1年最低价 $147.99，现价 $127.98： https://amzn.to/2OTG4Mw 三星 Micro SD 卡Samsung 100MG/s (U3) Micro SDXC 存储卡（含 adapter）在 Amazon 史低价，32G=$5.99、64G=$10.99、128G=$19.99、256G=$44.99。以 64G 为例，标价 $22.99、过去1年最低价 $15.47，而现在只要 $10.99！点击购买： https://amzn.to/2qYrnyw KitchenAid 配件低至4.5折亚马逊 现有 KitchenAid 配件 低至4.5折，并且包邮（亚马逊自营商品），好几件都是史低价，比如 螺旋切片器 特价$59.95（原价$84.95）。关于 KitchenAid 厨师机和配件介绍请看 这里 。 PlayStation 4 1TB Marvel’s Spider-ManPlayStation 4 1TB Marvel’s Spider-Man 主机+游戏黑五价 $199.99，包括黑色主机、无线手柄、和蜘蛛侠游戏！@ Walmart, @ Best Buy, @ GameStop, @ Amazon （部分商家已售完）。 Lego 经典创意盒补充装仅 $10.88Amazon 现有 Lego 经典创意盒补充装（型号10693） 史低价 $10.88 且包邮，包含303片。 Walmart 同款同价，店内取货可免运费。 象印咖啡机（10杯）Zojirushi EC-YSC100 Fresh Brew Plus Thermal Carafe Coffee Maker, 10 Cup, Stainless Steel/Black，原价 $190.00，过去一年最低价 $107.95，现在只要 $87.49，是很好的价格， 点击这里购买 。我家里有象印的热水器、电饭煲和水杯，他们家东西做工好、细致体贴、设计和外观也讨我喜欢。 Amazon Echo / Echo DotAmazon 第2代 Echo 正常售价 $100，黑五期间 只要 $70 ；第3代 Echo Dot 平产给售价 $50，黑五期间 只要 $24 。 Samsung Galaxy Watch 智能手表Samsung Galaxy Watch (46mm) 原价349，黑五期间 Amazon 预计将有$249好价 ，有意购买的注意关注价格变化。 Amazon Fire HD 平板电脑Amazon Fire HD 10 平日价格$149.99， 黑五期间将有$99.99特价 ，为历史最低， 价格11月16日生效。 规格相近的 iPad 9.7寸32G，苹果官价$429.99， 黑五期间 Costco 特价也要$249.99 ，相比之下，Amazon Fire HD 10 虽然各方面不如 iPad，但胜在确实便宜啊！另外，原价 $80 的Fire HD 8 黑五期间 将有 $50 好价 。 Amazon Fire TV 电视盒子$59.99平日价格$119.99， 黑五期间将有$59.99特价 ， 11月16日起生效 。Fire TV Cube 像 Echo 一样随时待命，可用语音控制你的电视，只需唤醒 Alexa 即可。另，平时 $50 的 Fire TV Stick 4K 黑五期间 将有 $35 好价 。 Blendtec Classic Fit 破壁机史低价$164.47亚马逊现有 Blendtec Classic Fit 破壁机 史低价$164.47（原价$299.95）。这款破壁机带一个75 oz 大容量搅拌杯，可打水果、谷物、冰块，打碎的同时可加热，还可以制作冰淇淋。 Amazon Kindle Unlimited 服务首3个月仅需99c首次签订 Amazon Kindle Unlimited 服务的新用户，首三个月仅需99c！现有用户或曾经免费试用过这项服务的用户不可享受此优惠。Amazon Kindle Unlimited 提供上百万本电子书和有声书，包括当期杂志。三个月优惠期后恢复每月$9.99价格，可随时取消。电子书可在 Kindle、电脑或手机上（可下载 Kindle app）阅读。点击 这里 查看优惠信息；2018年11月30日截止。 Prime 会员首次登入 Amazon App 可获$15 Credit现在起到2018年12月31日，Prime 会员 首次登入 Amazon App 可获$15 Credit，可用于 在 app 里购买$30或以上的自营商品 （Sold &amp; Shipped by Amazon），不可用于购买电子书和礼卡。Credit 将在你首次登入 Amazon App 后7天内发出，此 credit 有效期至2019年1月31日。注意：卸载 Amazon App 再重装是行不通的。 购买$50礼卡获$5 Amazon Credit部分亚马逊用户购买$50礼卡可获$5 Amazon Credit，需要使用优惠码 SMS2018。可选择实体礼卡或电邮发送，可赠予他人或发送给自己！点击 这里 ，若显示 Unfortunately, you are not eligible for this offer. 则表示你这次运气不好，不能享受这个优惠。 Amazon 2018 黑五折扣精选 « 美国攻略","link":"/2019/08/02/Amazon%202018%20%E9%BB%91%E4%BA%94%E6%8A%98%E6%89%A3%E7%B2%BE%E9%80%89%20%C2%AB%20%E7%BE%8E%E5%9B%BD%E6%94%BB%E7%95%A5/"},{"title":"Java List面试题汇总","text":"Java List面试题汇总1、你知道的List都有哪些？ - ArrayList、LinkedList、Vector等。 2、List和Vector有什么区别？ - Vector是List接口下线程安全的集合。 3、List是有序的吗？ - List是有序的。 4、ArrayList和LinkedList的区别？分别用在什么场景？ - ArrayList和LinkedList数据结构不一样，前者用在查询较多的场合，后者适用于插入较多的场合。 5、ArrayList和LinkedList的底层数据结构是什么？ - ArrayList使用的是数组结构，LinkedList使用的是链表结构。 6、ArrayList默认大小是多少，是如何扩容的？ - Jdk1.7之前ArrayList默认大小是10，JDK1.7之后是0，JDK差异，每次约按1.5倍扩容。 7、List是线程安全的吗？如果要线程安全要怎么做？ - List中的Vector才是线程安全的，其他要实现线程安全使用工具类Collections.synchronizedList(new ArrayList())方法。 8、怎么给List排序？ - 使用List自身的sort方法，或者使用Collections.sort(list)方法; 9、Arrays.asList方法后的List可以扩容吗？ - Arrays.asList使用的是final数组，并且不支持add方法，不支持扩容。 10、List和Array之间如何互相转换？ - List&gt;Array使用toArray方法，Array&gt;List使用Arrays.asList(array)方法，由于它是固定的，不固定的可以使用new ArrayList(Arrays.asList(array))。","link":"/2019/08/02/Java%20List%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"},{"title":"Java Map集合面试题汇总","text":"Java Map集合面试题汇总1、 你都知道哪些常用的Map集合? - HashMap、HashTable、LinkedHashMap、ConcurrentHashMap。 2、Collection集合接口和Map接口有什么关系？ - 没关系，Collection是List、Set父接口不是Map父接口。 3、HashMap是线程安全的吗？线程安全的Map都有哪些？性能最好的是哪个？ - HashMap不是线程安全的。线程安全的有HashTable、ConcurrentHashMap、SynchronizedMap，性能最好的是ConcurrentHashMap。 4、使用HashMap有什么性能问题吗？ - 使用HashMap要注意避免集合的扩容，它会很耗性能，根据元素的数量给它一个初始大小的值。 5、HashMap的数据结构是怎样的？默认大小是多少？内部是怎么扩容的？ - HashMap是数组和链表组成的，默认大小为16，当hashmap中的元素个数超过数组大小*loadFactor（默认值为0.75）时就会把数组的大小扩展为原来的两倍大小，然后重新计算每个元素在数组中的位置。 6、怎么按添加顺序存储元素？怎么按A-Z自然顺序存储元素？怎么自定义排序？ - 按添加顺序使用LinkedHashMap,按自然顺序使用TreeMap,自定义排序TreeMap(Comparetor c)。 7、HashMap的链表结构设计是用来解决什么问题的？ - HashMap的链表结构设计是用来解决key的hash冲突问题的。 8、HashMap的键、值可以为NULL吗？HashTable呢？ - HashMap的键值都可以为NULL，HashTable不行。 9、HashMap使用对象作为key，如果hashcode相同会怎么处理？ - key的hash冲突，如果key equals一致将会覆盖值，不一致就会将值存储在key对应的链表中。 10、HashMap中的get操作是什么原理？ - 先根据key的hashcode值找到对应的链表，再循环链表，根据key的hash是否相同且key的==或者equals比较操作找到对应的值。","link":"/2019/08/02/Java%20Map%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"},{"title":"Java系统学习","text":"Java系统学习分布式专题 1.分布式基础 1.1网络通信： 1.1.1协议{TCP/IP,UDP/IP,Multicast} 1.1.2IO{BIO,NIO,AIO,Multicast} 1.2消息方式的系统间的通信： 1.2.1基于java包的通信（通过TCP/IP,UDP/IP,Multicast） 1.2.2基于开源框架（netty） 1.2.3系统性能（连接管理） 1.2.3.1连接池 1.2.3.2连接复用 1.2.3.3长连接/短连接 1.3通信 1.3.1webservice 1.3.2rmi 1.3.3http（RESTful） 1.3.4序列化 1.3.4.1xml 1.3.4.2json 1.3.4.3serializer 1.3.4.4hessian2 1.3.4.5kryo 1.3.5服务的路由和负载 2消息通信 2.1ActiveMQ 2.1.1JMS规范 2.1.2点对点模型 2.1.3发布订阅模型 2.2RocketMQ 2.3KafKa 2.3.1KafKa的基本原理 2.3.2KafKa的消息存储机制 2.3.3点对点模型及发布订阅模型的机制 2.3.4Kafka的高可用方案 3大型分布式应用框架基础 3.1SOA架构 3.1.1为什么需要SOA 3.1.2SOA是什么 3.2微服务架构 3.2.1什么是微服务架构 3.2.2SOA和微服务架构的区别 3.2.3Spring Boot实战练习 3.2.4Docker虚拟容器化技术 3.2.4.1镜像/仓库/容器 3.2.4.2服务编排 3.2.4.3docker整合spring boot 3.3高性能反向代理服务器Nginx 3.3.1反向代理/负载均衡 3.3.2nginx配载详解 3.3.3nginx+keepalived高可用 3.3.4nginx进程模型 4分布式服务治理 4.1Dubbo框架 4.1.1Dubbo是什么 4.1.2Dubbo企业级应用示例 4.1.3Dubbo实现原理及架构剖析 4.1.4Dubbo+spring集成 4.2分布式协调技术Zookeeper 4.2.1zookeeper集成安装部署 4.2.2zookeeper的基本原理，数据模型 4.2.3zookeeper java api的使用 4.2.4zookeeper实际应用场景分析及实战 4.2.5zookeeper+dubbo的实战演习5持久化存储 5.1Mysql 5.1.1业务拆分 5.1.2表拆分 5.1.2.1拆分策略 5.1.2.2水平/垂直拆分 5.1.3Mycat的使用 5.1.4读写分离实战 5.2HBase （高可靠性，高可扩展，实时读写，列存储数据库） 5.3Nosql 5.3.1Redis 5.3.1.1redis集群安装 5.3.1.2redis5中数据类型深入分析 5.3.1.3redis哨兵机制及原理 5.3.1.4redis java api 的使用 5.3.2MongoDB 5.3.2.1MongoDB是什么 5.3.2.2MongoDB的高可用方案 5.3.2.3MongoDB常用命令 5.3.2.4MongoDB集成spring实战 高性能/高并发 1.架构原理分析 1.1分布式压测系统： 1.2分布式配置系统： 1.3分布式缓存系统： 1.4秒杀系统实战： 1.5分布式消息系统： 2分布式服务通信 2.1网络通信 2.1.1协议（TCP/IP,UDP/IP,Multicast） 2.1.2IO（BIO,NIO,AIO） 2.1.3发布订阅模型 2.2消息方式的系统间通信 2.2.1基于开源框架-netty 2.2.1.1Netty线程模型 2.2.1.2实现IM聊天功能 2.2.2性能角度-连接管理 2.2.2.1连接池 2.2.2.2连接复用 2.2.2.3长连接/短连接 2.3通信 2.3.1webservice 2.3.2rmi 2.3.3http（RESTful） 2.3.4序列化 2.3.4.1xml 2.3.4.2json 2.3.4.3serializer 2.3.4.4hessian2 2.3.4.5kryo 2.4异步 2.4.1KafKa 2.4.1.1KafKa的基本原理 2.4.1.2KafKa的消息存储机制 2.4.1.3点对点模型及发布订阅模型的机制 2.4.1.4Kafka的高可用方案 2.4.2ActiveMQ 2.4.2.1JMS规范 2.4.2.2点对点模型 2.4.2.3发布订阅模型 3大型分布式架构基础 3.1SOA架构 3.1.1为什么需要SOA 3.1.2SOA是什么 3.2微服务架构 3.2.1什么是微服务架构 3.2.2SOA和微服务架构的区别 3.2.3Spring Boot实战练习 3.2.4Docker虚拟容器化技术 3.2.4.1镜像/仓库/容器 3.2.4.2服务编排 3.2.4.3docker整合spring boot 3.3高性能反向代理服务器Nginx 3.3.1反向代理/负载均衡 3.3.2nginx配载详解 3.3.3nginx+keepalived高可用 3.3.4nginx进程模型 3.4高性能反向代理服务器Nginx 3.4.1反向代理/负载均衡 3.4.2nginx配载详解 3.4.3nginx+keepalived高可用 3.4.4nginx进程模型4分布式服务治理 4.1Dubbo框架 4.1.1Dubbo是什么 4.1.2Dubbo企业级应用示例 4.1.3Dubbo实现原理及架构剖析 4.1.4Dubbo+spring集成 4.2分布式协调技术Zookeeper 4.2.1zookeeper集成安装部署 4.2.2zookeeper的基本原理，数据模型 4.2.3zookeeper java api的使用 4.2.4zookeeper实际应用场景分析及实战 4.2.5zookeeper+dubbo的实战演习 5持久化存储 5.1Mysql 5.1.1业务拆分 5.1.2表拆分 5.1.2.1拆分策略 5.1.2.2水平/垂直拆分 5.1.3Mycat的使用 5.1.4读写分离实战 5.2HBase （高可靠性，高可扩展，实时读写，列存储数据库） 5.3Nosql 5.3.1Redis 5.3.1.1redis集群安装 5.3.1.2redis5中数据类型深入分析 5.3.1.3redis哨兵机制及原理 5.3.1.4redis java api 的使用 5.3.2MongoDB 5.3.2.1MongoDB是什么 5.3.2.2MongoDB的高可用方案 5.3.2.3MongoDB常用命令 5.3.2.4MongoDB集成spring实战 工程化专题 1.maven 1.1maven的安装使用： 1.2setting.xml,pom.xml知其所以然： 1.3maven使用过程中常见的问题： 1.4手写maven插件，避免重复造轮子： 1.5架构师之路-手写archetype： 1.6maven profile的企业级应用： 1.7搭建本地仓库：2知识点回顾 2.1可以考虑找些面试题 2.2maven/jenkins爬坑技巧 2.3知识点回顾3 git 3.1git的安装和使用 3.2常用命令（fetch/pull/push/rebase） 3.3团队协作 git flow 3.4搭建gitlab环境 3.5git hook，教你怎么使用钩子4jenkins 4.1jenkins的安装使用 4.2jenkins界面常用功能介绍 4.3jenkins和git/maven整合 4.4test/pre/production多环境发布 双十一架构专题 1.分布式压测系统 1.1最简单的单机压测： 1.2压测应该关注的点： 1.3如何做分布式压测： 2分布式配置系统 2.1灵活配置热发布 2.2一切都是为了自动化 3分布式缓存系统 3.1五级缓存体系 3.2热点数据处理 4秒杀系统实战 4.1从0到1秒杀系统 4.2从all-in-one到分布式 4.3从1到100的优化重构 5跟踪系统 5.1如何梳理链路依赖 5.2如何做到优雅降级 6分布式消息系统 6.1异步化&amp;系统隔离 6.2应对瞬时大流量 性能优化专题 1.优化技巧 1.1衡量系统现状： 1.1.1先粗粒度划分 1.1.2再细粒度寻找目标 1.2设定调优目标： 1.3寻找性能瓶颈： 1.3.1定位消耗资源情况 1.3.1.1CPU(us，sy) 1.3.1.2文件io 1.3.1.3内存（jvm堆内存，堆以外内存） 1.3.1.4网络io 1.3.2定位执行慢的原因 1.3.2.1锁竞争 1.3.2.2未充分利用硬件资源 1.3.2.3数据量大 1.4秒杀系统实战： 1.5分布式消息系统： 2容器调优 2.1Nginx 2.1.1动静资源分离 2.1.2Nginx参数调优 2.1.3Nginx+Lua 2.1.4IP过滤配置 2.1.5Nginx缓存 2.2tomcat 2.2.1tomcat相关参数说明 2.2.2tomcat源码，架构剖析 2.2.3tomcat线程数配置 2.2.4tomcat NIO配置 3深入了解JVM 3.1java代码执行 3.1.1代码编译为class —javac 3.1.2装载class—ClassLoader 3.1.3执行class（解释执行，编译执行） 3.2内存管理 3.2.1内存空间（方法区，堆，jvm方法栈，本地方法栈，pc寄存器） 3.2.2内存分配（堆上分配，tlab分配，栈上分配） 3.2.3内存回收 3.2.3.1算法（copy，mark-sweep，mark-compact） 3.2.3.2JDK实现 3.2.3.2.1分代回收(新生代可用的gc，minor gc触发机制及日志格式，老年代可用的gc，full gc触发机制及日志格式) 3.2.3.2.2GC参数 3.2.3.2.3G1 3.2.4内存状况分析（jconsole，visualvm，jstat，jmap，MAT） 3.3线程资源同步和交互 3.3.1线程资源同步 3.3.1.1线程资源执行机制 3.3.1.2线程资源同步机制（synchronized实现机制，lock/unlock的实现机制） 3.3.2线程交互机制 3.3.2.1wait/notify/notifyall 3.3.2.2并发包提供的交互机制（发令枪，信号灯） 3.3.3线程状态及分析方法（jstack，TDA） 4数据库优化技巧（Mysql） 4.1分析执行计划 4.2索引的使用情况 4.3分库分表策略 4.4master/Slave读写分离 4.5SQL语句的优化技巧 4.6Mysql的事务策略分析 源码分析专题 1.Spring源码分析 1.1Spring的发展背景简介： 1.2Spring IOC/DI深入剖析： 1.3Spring IOC容器设计原理及高级特性： 1.4SpringAOP 设计原理及实践： 1.5Spring JDBC设计原理及手写实现： 1.6Spring MVC架构设计原理及手写实现： 1.7Struts2与Spring MVC的比较： 2Mybatis源码分析 2.1Mybatis3简介： 2.2Mybatis3 SqlMap哪些事儿： 2.3数据库连接池到底是什么： 2.4Mybatis3 SessionFactory实现原理： 2.5Mybatis3 配置文件详解： 2.6Mybatis3 事务管理与集成： 2.7浅谈 Hibernate： 2.8Mybatis3与Hibernate框架对比： 3Netty源码分析 3.1NIO通信原理剖析： 3.2深入了解Nio缓冲区Buffer： 3.3Nio Selector原理： 3.4AIO编程： 3.5Netty产生的背景以及基础入门： 3.6Netty高性能之道： 3.7Netty的HTTP与Socket通信原理： 3.8利用Netty搭建高性能的WebSocket聊天室： 3.9Netty的编码解码： 3.10Netty的拆包粘包操作： 3.11MsgPack与Netty整合： 3.12Netty HTTP通信与Spring整合： 3.13Netty RPC架构： 3.14Netty高性能之道： 3.15Netty与各种架构整合及Netty源码分析： 4java常见的类和包 4.1current包下的类 4.2集合类 4.3annotation包","link":"/2019/08/02/Java%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"},{"title":"Kafka Vs RabbitMQ","text":"Kafka Vs RabbitMQ","link":"/2019/08/02/Kafka%20Vs%20RabbitMQ/"},{"title":"PHP初级程序员的需要知道的一些知识点","text":"PHP初级程序员的需要知道的一些知识点前段时间（2017-09-04~2017-09-26）我们讨论了如下话题：【今日话题1】Linux下有哪些基本命令、操作、启动、基本服务配置（包括rpm安装文件，各种服务配置等）【今日话题2】Linux中shell脚本的使用（实用技能和小技巧）【今日话题3】Linux中awk的基本使用与常用语句【今日话题4】如何在Linux安装mysql，目前最适合使用什么版本的MySQL，mysql需要知道的基本的配置有哪些？例如：是通过下载源码编译安装，还是通过yum、brew这种，还是直接用一键安装包这种（lnmp）目前5.7.19是最好的选择吗？【今日话题5】MySql的常用配置及如何优化配置的参数(不同的业务技术如何设置)【今日话题6】PHP的安全攻防。例如：常用的测试漏洞工具有哪些，劫持和重定向漏洞，XSS和CSRF漏洞，注入漏洞，文件上传下载漏洞，敏感信息泄露漏洞，各种漏洞的防范 技巧【今日话题7】常用的mvc框架，不同的框架的运行机制，他们之间的区别有哪些？【今日话题8】你们常用的前端框架、JS的框架有哪些，用在什么系统上（内部 or 对外），有坑吗，什么坑？ 以上就是php初级程序员的需要知道的一些知识点。在10月9日，会开启中级程序员专属的话题讨论，敬请期待！","link":"/2019/08/02/PHP%E5%88%9D%E7%BA%A7%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"Spring面试题（70道，史上最全）","text":"Spring面试题1.什么是spring? 2.使用Spring框架的好处是什么？ 3.Spring由哪些模块组成? 4.核心容器（应用上下文)模块。 5.BeanFactory–BeanFactory实现举例。 6.XMLBeanFactory 7.解释AOP模块 8.解释JDBC抽象和DAO模块。 9.解释对象/关系映射集成模块。 10.解释WEB模块。 11.为什么说Spring是一个容器？ 12.Spring配置文件 13.什么是SpringIOC容器？ 14.IOC的优点是什么？ 15.ApplicationContext通常的实现是什么? 16.Bean工厂和Applicationcontexts有什么区别？ 17.一个Spring的应用看起来象什么？ 18.什么是Spring的依赖注入？ 19.有哪些不同类型的IOC（依赖注入）方式？ 20.哪种依赖注入方式你建议使用，构造器注入，还是Setter方法注入？ 21.什么是Springbeans? 22.一个SpringBean定义包含什么？ 23.如何给Spring容器提供配置元数据? 24.你怎样定义类的作用域? 25.解释Spring支持的几种bean的作用域。 26.Spring框架中的单例bean是线程安全的吗? 27.解释Spring框架中bean的生命周期。 28.哪些是重要的bean生命周期方法？你能重载它们吗？ 29.什么是Spring的内部bean？ 30.在Spring中如何注入一个java集合？ 31.什么是bean装配? 32.什么是bean的自动装配？ 33.解释不同方式的自动装配。 34.自动装配有哪些局限性? 35.你可以在Spring中注入一个null和一个空字符串吗？ 36.什么是基于Java的Spring注解配置?给一些注解的例子. 37.什么是基于注解的容器配置? 38.怎样开启注解装配？ 39.@Required注解 40.@Autowired注解 41.@Qualifier注解 42.在Spring框架中如何更有效地使用JDBC? 43.JdbcTemplate 44.Spring对DAO的支持 45.使用Spring通过什么方式访问Hibernate? 46.Spring支持的ORM 47.如何通过HibernateDaoSupport将Spring和Hibernate结合起来？ 48.Spring支持的事务管理类型 49.Spring框架的事务管理有哪些优点？ 50.你更倾向用那种事务管理类型？ 51.解释AOP 52.Aspect切面 53.在SpringAOP中，关注点和横切关注的区别是什么？ 54.连接点 55.通知 56.切点 57.什么是引入? 58.什么是目标对象? 59.什么是代理? 60.有几种不同类型的自动代理？ 61.什么是织入。什么是织入应用的不同点？ 62.解释基于XMLSchema方式的切面实现。 63.解释基于注解的切面实现 64.什么是Spring的MVC框架？ 65.DispatcherServlet 66.WebApplicationContext 67.什么是SpringMVC框架的控制器？ 68.@Controller注解 69.@RequestMapping注解 70.返回Json用什么注解？","link":"/2019/08/02/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8870%E9%81%93%EF%BC%8C%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%EF%BC%89/"},{"title":"Zookeeper面试题锦集","text":"Zookeeper面试题锦集1、zookeeper是什么框架？ 高可用的分布式数据管理与系统协调框架 2、有哪些应用场景？ 分布式锁、分布式协调、集群管理/Master选举、命名服务 3、使用什么协议？ ZAB 4、说说分布式一致性算法 Paxos 5、说一说选举算法及流程 6、zookeeper有哪几种节点类型？ 持久节点（PERSISTENT）、持久顺序节点（PERSISTENT_SEQUENTIAL）、临时节点（EPHEMERAL）、临时顺序节点（EPHEMERAL_SEQUENTIAL） 7、zookeeper对节点的watch监听通知是永久的吗？ 不是。官方声明：一个Watch事件是一个一次性的触发器，当被设置了Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了Watch的客户 端，以便通知它们 8、有哪几种部署模式？ 9、集群中的机器角色都有哪些？ Leader、Follower、Observe、Client 10、集群最少要几台机器，集群规则是怎样的 3台，奇数 11、集群如果有3台机器，挂掉一台集群还能工作吗？挂掉两台呢？ 半数以上 12、集群支持动态添加机器吗？ 不能 13、zookeeper的java客户端都有哪些？ 14、chubby是什么，和zookeeper比你怎么看？ 15、说几个zookeeper常用的命令。","link":"/2019/08/02/Zookeeper%E9%9D%A2%E8%AF%95%E9%A2%98%E9%94%A6%E9%9B%86/"},{"title":"【双11劲爆干货】阿里高级Java面试题（首发，70道，带详细答案）","text":"【双11劲爆干货】阿里高级Java面试题（首发，70道，带详细答案） 整理的70道阿里的Java面试题，都来挑战一下，看看自己有多厉害。下面题目都带超详细的解答，详情见底部。 1、java事件机制包括哪三个部分？分别介绍。 2、为什么要使用线程池？ 3、线程池有什么作用？ 4、说说几种常见的线程池及使用场景。 5、线程池都有哪几种工作队列？ 6、怎么理解无界队列和有界队列？ 7、线程池中的几种重要的参数及流程说明。 8、什么是反射机制？ 9、说说反射机制的作用。 10、反射机制会不会有性能问题？ 11、你怎么理解http协议？ 12、说说http协议的工作流程。 13、http有哪些请求提交方式？ 14、http中的200,302,403,404,500,503都代表什么状态？ 15、http get和post有什么区别？ 16、你怎么理解cookie和session，有哪些不同点？ 17、什么是web缓存？有什么优点？ 18、什么是https，说说https的工作原理？ 19、什么是http代理服务器，有什么用？ 20、什么是虚拟主机及实现原理？ 21、什么是Java虚拟机，为什么要使用？ 22、说说Java虚拟机的生命周期及体系结构。 23、说一说Java内存区域。 24、什么是分布式系统？ 25、分布式系统你会考虑哪些方面？ 26、讲一讲TCP协议的三次握手和四次挥手流程。 27、为什么TCP建立连接协议是三次握手，而关闭连接却是四次握手呢？为什么不能用两次握手进行连接？ 28、为什么TCP TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？ 29、什么是DoS、DDoS、DRDoS攻击？如何防御？ 30、描述一下Java异常层次结构。 31、什么是检查异常，不受检查异常，运行时异常？并分别举例说明。 32、finally块一定会执行吗？ 33、正常情况下，当在try块或catch块中遇到return语句时，finally语句块在方法返回之前还是之后被执行？ 34、try、catch、finally语句块的执行顺序。 35、Java虚拟机中，数据类型可以分为哪几类？ 36、怎么理解栈、堆？堆中存什么？栈中存什么？ 37、为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？ 38、在Java中，什么是是栈的起始点，同是也是程序的起始点？ 39、为什么不把基本类型放堆中呢？ 40、Java中的参数传递时传值呢？还是传引用？ 41、Java中有没有指针的概念？ 42、Java中，栈的大小通过什么参数来设置？ 43、一个空Object对象的占多大空间？ 44、对象引用类型分为哪几类？ 45、讲一讲垃圾回收算法。 46、如何解决内存碎片的问题？ 47、如何解决同时存在的对象创建和对象回收问题？ 48、讲一讲内存分代及生命周期。 49、什么情况下触发垃圾回收？ 50、如何选择合适的垃圾收集算法？ 51、JVM中最大堆大小有没有限制？ 52、堆大小通过什么参数设置？ 53、JVM有哪三种垃圾回收器？ 54、吞吐量优先选择什么垃圾回收器？响应时间优先呢？ 55、如何进行JVM调优？有哪些方法？ 56、如何理解内存泄漏问题？有哪些情况会导致内存泄露？如何解决？ 57、从分布式系统部署角度考虑，分哪几层？ 58、如何解决业务层的数据访问问题？ 59、为了解决数据库服务器的负担，如何做数据库的分布？ 60、什么是著名的拜占庭将军问题？ 61、为什么说TCP/IP协议是不可靠的？ 62、讲讲CAP理念。 63、怎么理解强一致性、单调一致性和最终一致性？ 64、分布式系统设计你会考虑哪些策略？ 65、最常见的数据分布方式是什么？ 66、谈一谈一致性哈希算法。 67、paxos是什么？ 68、什么是Lease机制？ 69、如何理解选主算法？ 70、OSI有哪七层模型？TCP/IP是哪四层模型。","link":"/2019/08/02/%E3%80%90%E5%8F%8C11%E5%8A%B2%E7%88%86%E5%B9%B2%E8%B4%A7%E3%80%91%E9%98%BF%E9%87%8C%E9%AB%98%E7%BA%A7Java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E9%A6%96%E5%8F%91%EF%BC%8C70%E9%81%93%EF%BC%8C%E5%B8%A6%E8%AF%A6%E7%BB%86%E7%AD%94%E6%A1%88%EF%BC%89/"},{"title":"一些可以说的系统整理","text":"一些可以说的系统整理Poi系统重构 升级1. memcache往redis迁移 2. redis分布式缓存架构 持久化 负载均衡 - 分布式 - 哨兵 3. 多级缓存架构 4. 可用性 5. es搜索引擎 6. 负载均衡 7. 消息队列 8. 异步更新图片系统 (和Poi一样)1. memcache往redis迁移 2. redis分布式缓存架构 持久化 负载均衡 - 分布式 - 哨兵 3. 多级缓存架构 4. 可用性 5. es搜索引擎 6. 负载均衡 7. 消息队列 8. 异步更新攻略体系搭建1. 所有模块组件化 2. 高复用模块sdk化 3. 独立部署","link":"/2019/08/02/%E4%B8%80%E4%BA%9B%E5%8F%AF%E4%BB%A5%E8%AF%B4%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86/"},{"title":"一位92年女生致周鸿祎：别再盯着我们看了-墙外楼","text":"一位92年女生致周鸿祎：别再盯着我们看了-墙外楼菲言菲语 周鸿祎叔叔，你好呀！ 我是一个92年的内容创业者，我们本身并没有什么交集：你是参加乌镇互联网大会，哪里饭好吃就去哪个饭局的大佬，回归A股直冲首富的“红衣教主”，是我一直以来学习的榜样。你是1970年出生的，比我妈妈大一岁，但是你却把360做成了中国最大的网络安全企业，用户规模在全球排名首位；我妈妈只是普通人，最厉害的事情就是生了我，嘻嘻。 我大学时就开始用360的好多产品，比如360浏览器。但是安了360以后，再使用其他浏览器时，360安全卫士就会拦截，怕我遇到危险，谢谢叔叔一直以来的照顾。2014年我大学毕业那会儿，周叔叔从美国巡游回来，说要做物联网，要全方位地把我们保护起来，立誓将用户的安全“从线上搬到线下”，于是有了360智能摄像头“小水滴”。周叔叔又增加新功能“水滴直播”，如果此时周叔叔在我旁边，我一定会向你投出仰慕的眼神。 我前几天还看到水滴直播上发出公告：幼儿园不限量免费申请360摄像头。在360的保护下我又感受到叔叔的温暖。我自己是做产品体验类视频的，出于职业的好奇心，我和同事发现水滴直播的内容真可谓是琳琅满目：有妖娆的舞蹈身姿、游乐园的儿童嬉戏、输入密码的特写、养殖场惬意的驴子 …… 12月2日那天风超级大，但是依然挡不住我和小伙伴躁动的心。我们按照水滴直播上的ID位置，找到了在北京西单附近的素食店。我和小伙伴坐成一排冲着前台，清晰得地出现在水滴直播画面上，在屏幕上的最里面则是一对情侣。如果周叔叔去了，说不定在水滴直播上能跟我们有合影呢。服务员阿姨很热情，跟我们说摄像头是360的，老板安的，在水滴直播上能看到他们家店。对了，周叔叔，你在水滴直播上说要让商家张贴直播告示，可是这家没有呢，阿姨也不知道。 我又在水滴直播界面上滑动着，发现了丰台刘家窑的一家连锁餐厅，他们家粥很好喝，画面上人头攒动，屏幕上飘的一行行弹幕也很惹眼。我们顺着ID又准确无误地找了过去。让用户在位置栏里选择自己定位，确实方便我们去寻找，嘻嘻。 进入店内，我们几个人的身影又出现在水滴直播上了。我们喝完粥，同事去前台结账，拿着直播中的画面去问前台，收银员说摄像头是360送的，老板安上去，不知道会被直播出去。 嗯，这个老板肯定喜欢监督员工，不允许办公室恋情，亲个小嘴这种事情也会被网友谴责的，吃饭的顾客也得做一个好公民。我们问了此时正在聊天的两个顾客，她们被直播上镜的感受，“你愿意被直播吗？一天24小时天天被直播你觉得会是什么感受？”我们得到这样的反问，说完她们就赶忙离开了饭店。 她们竟然不喜欢叔叔的保护，一点也不乖呢。一个带着孩子的母亲也疑惑和愤怒地说：“他们凭什么直播？！”从这点看大家显然不领叔叔的情。 12月3日我们继续寻找，也想帮叔叔做个调查。叔叔一直让大家张贴直播告示，《商家设置直播提供公告》要求在平台开播的商家需要在直播区域设置明显直播提示以告知顾客，提示贴纸需要在画面明显露出，或者在直播台简介中注明：“本店直播已告知顾客”类似文字。但我们发现商家就是不听话，极少有张贴。 如果贴了告示，商家就可以直播各种监控画面了，只要进屋就算用户默认愿意被直播，商家就不用再用户指责了，一指墙上的大字，用户不就微笑着开始直播自己肖像了嘛？ 我们又来到了丰台的小吃店，我和同事坐在摄像头正对面，这样上镜会更明显一点。在啃鸡腿的时候我也保持微笑，怕网友发弹幕说我吃相不可爱。对于一个女汉子来说我已经很努力了。我们饭后去前台问摄像头的问题，店家说是360送的，已经安了两年多了。 我不禁想到周叔叔的口号：“硬件免费”，我们又问道如果顾客被直播出去是否会涉及到隐私时，店家直言：“吃饭有什么隐私？”如果周叔叔和女童鞋来吃饭，此时弹幕应该是什么呢？ 紧接下来我们去了一家附近的网吧，也是在丰台，看来这片儿是周叔叔重点保护对象。同事们进入网吧，开了几台机器，玩起游戏来，也拿起水滴直播里这家网吧的画面跟旁边的一个年轻小伙子攀谈。 这位好奇地看着画面里的自己，很开心得一乐，看起来他很喜欢上镜。而后同事去前台问是否允许直播时，网吧服务员说：“没有人会知道你来xx网吧，没人会搭理你在xx网吧。”我们电话联系网吧老板，缺得到了训斥：“你去报警吧”，老板最后扔了这样一句话。 哎，是啊，我们平常老百姓哪有什么隐私可言呀，谁会在意我们呢？可看到直播上的弹幕，还是能看到不少吃瓜群众关心我们的私人生活。管理员说是水滴直播让他们开的，让我们去联系水滴直播，周叔叔你得为我们做主呀。 后来我们也去了丰台的一个健身馆，健身馆是在地下一层，顺着楼梯下去能看到一家大约3000平的场馆，在这里有好几个360摄像头，不同视角的监控画面会出现在水滴直播上面，一个正在练瑜伽的女孩引起了我们的注意，她正在粉红色瑜伽垫子上做着动作，我们顺势寻找着画面中的女孩，在瑜伽房里找到了她。 我悄悄的拿着正在直播的画面给她看，我也出现在这个画面，她有些不明白的看着我，却说不出什么话来，我跟她解释了一下，她怒气冲冲的往健身房的负责人办公室那里走，却没有得到负责人任何反馈，一直在说是平台的责任。我在想周叔叔怎么能有错呢？ 12月3日，我们历时两天的学习考察，马上就要结束了，最近也长胖了不少。我们来的最后一家是西城区的涮肉店，来得时候不是饭点儿，人很少。这家店的摄像头看起来比较高级，是360旋转摄像头。我和同事找地儿坐，一边点菜一边看着直播，“那女的不会是小三吧“、”父女“等词儿在屏幕上飘了起来。 我顾不上点菜了，麻利儿地把直播画面录屏了，四下环视寻找到弹幕评论的“焦点”——我身后的一桌正在就餐的男女。我小心翼翼地把直播视频拿给给他们，当他们看到画面中的自己和飘过的弹幕时，一脸惊愕。 我并不知道他们是什么关系，我虽然看到直播中女孩在给旁边的中年男人喂饭，但不代表我们可以随意揣测他们的关系。他们把商家叫来问话，商家很真诚地道歉并承诺把直播关闭，但是他又满脸委屈地解释说，只想通过直播打广告，“通过直播到店享受9折优惠”醒目得出现在直播简介里面。 女孩又说之前如果在店里丢东西了都不让看监控，这次却把监控放在网上直播，确实让她寒心。此时在一旁的我不知道说什么d把监控画面直播出去真的好吗？我沉默了，我不知道周叔叔看到这里会想说点什么。我在回家的路上下意识地打开了刚才直播的那家涮肉店，却发现直播依旧开着。 我知道周叔叔在让用户开播前签署免责协议，我上一篇文章也提过，可是叔叔你真的不管了吗？你在知乎上被称为曹操，IT界的枭雄，我明白你当时做3721的时候的坚持和笃定，我也知道你3Q大战时你发布“隐私保护器”专门搜集QQ软件是否侵犯用户隐私。 我知道水滴直播也是你的一种保护，可是用户却发出一次又一次到呐喊，媒体报道也众多：2017年4月，“各地中小学、幼儿园教师使用水滴平台分享课堂画面”引发关注。2017年4月28日，水滴平台做出回应称，360智能摄像机默认为关闭“水滴直播”功能，是否开启完全由用户自己决定；南方都市报也曾报道过《连内衣店、按摩馆都被大量直播画面让人心惊》等等。 周叔叔可能忙于事务没有关注到对360摄像机的水滴直播的报道，可现在您毕竟要成为首富了，回到A股，越来越多的老百姓也开始关注到有个伟大的公司叫：奇虎360，有个伟人叫：周鸿祎。那天我给我妈妈打电话说起周叔叔，妈妈连声称赞叔叔的丰功伟绩，却不让我成为你。 镜像链接： 谷歌镜像 | 亚马逊镜像 一位92年女生致周鸿祎：别再盯着我们看了-墙外楼","link":"/2019/08/02/%E4%B8%80%E4%BD%8D92%E5%B9%B4%E5%A5%B3%E7%94%9F%E8%87%B4%E5%91%A8%E9%B8%BF%E7%A5%8E%EF%BC%9A%E5%88%AB%E5%86%8D%E7%9B%AF%E7%9D%80%E6%88%91%E4%BB%AC%E7%9C%8B%E4%BA%86-%E5%A2%99%E5%A4%96%E6%A5%BC/"},{"title":"iOS 操作自动化神器：Workflow 规则大全（视频VIP快速扫码BT搜索等..） – 下1个好软件","text":"iOS 操作自动化神器：Workflow 规则大全（视频VIP/快速扫码/BT搜索等..） – 下1个好软件Workflow 是iOS上的流程自动化神器，能帮助我们省去每次重复操作的过程。可以说是提高效率必备的APP了，Workflow 从收费到被苹果收购免费下载，让更多用户开始使用Workflow。 Workflow 介绍： Workflow 通过流程化自动处理各种事情，内置 150+ 动作，如开启相机、获取当前 GPS 位置、生成 PDF、打开 URL 链接、新建 EeverNote 笔记等等，只要能巧妙组合，搭配合理，几乎能实现使用者任何的复杂任务流程。 举个栗子： 如果你要查询手机的剩余流量，就是 如果你要删除一张照片「你需要打开相册找到那张照片点进去 - 点右下角的垃圾桶 - 点删除照片」 一共 4 次点击 ；而 用 Workflow 删除一张照片则是「下拉通知栏 - 找到 Workflow 小部件 - 点删除照片 - 点确认」一共 2 次点击。 这就是自动化！简直就是懒人必备、提高效率的大杀器。 但是 Workflow 内置的规则不太符合中国用户使用，所以就有很多用户自己折腾了规则，例如：把 Apple Pay、支付宝、微信扫码支付集合在一起、在通知中心翻译句子、查询空气质量、快速切换苹果商店地区等，下面 下1个好软件 小编给大家分享一些Workflow 规则： 福利支付宝红包每天都可领取： https://workflow.is/workflows/55168c7038614d37a2d9029539c0a9ad 视频类全网视频VIP： https://workflow.is/workflows/62fbf95b774642cf846b144f070d4866 视频下载 8合1： https://workflow.is/workflows/d1342b439de542ffaee1994ebdadc90e FOOTAGE视频下载： https://workflow.is/workflows/72b4fd0a59c3434abec6b4a4a15ec5a0 抖音无水印视频下载： https://workflow.is/workflows/9f0abf4c29854639a4ef1fa9fce35ac2 muse无水印视频下载： https://workflow.is/workflows/7013cc54bfcb4964b06dde53801b2431 头条西瓜视频提取下载： https://workflow.is/workflows/b90846cfdd8f4b28963d1af14df43a61 获取QQ空间视频： https://workflow.is/workflows/3602bfa1918249248dc3eabfba0de0c4 获取贴吧视频： https://workflow.is/workflows/3eca4398479c43fbb2a11bda287b71a6 Parse Video： https://workflow.is/workflows/b191d90f8d0e4128b326c1404687d9a1 获取bilibili视频封面（B站载）： https://workflow.is/workflows/b981e2278e97430292fb455684587af9 Aio视频下载： https://workflow.is/workflows/e81023a434a6400f8cdbe4bd5b24f873 微信公众号（花果科技）全视频： https://workflow.is/workflows/d4dd978cb0a24f56aa7247624e28109c 80S 电影下载： https://workflow.is/workflows/5fcde685a6184e509d8c870a1150e40e 获取网易新闻视频： https://workflow.is/workflows/b9de542a7d5e42d885133e694996071c 今日头条视频下载： https://workflow.is/workflows/7cfdf731f7d54b80b2f50898ff660fab 秒拍视频保存到相册： https://workflow.is/workflows/aa005611c84945c78857c0ee2cfd359c 微博视频下载： https://workflow.is/workflows/5efd7e1d1704453993be62af01e813a8 电视直播： https://workflow.is/workflows/cf0205075f3f4809a30be1c3ad9064d1 电影蜜蜂（6.12）： https://workflow.is/workflows/2cc7c76a0e6a4fada44f39ccd940fab8 电影动漫资源搜索： https://workflow.is/workflows/87dee3ef9c924b72b39aaceec82fa598 音乐视频下载： https://workflow.is/workflows/dc747e13090b46348fac034fa61caa78 超级VIP视频1.2： https://workflow.is/workflows/331ad421a45b47e3a49783a2222f06e9 影视在线： https://workflow.is/workflows/22f9160e84cf40d59a0731c17cf54a2e 爱奇艺迅雷获取： https://workflow.is/workflows/dd4bad5a86b24abcbe49f3f57bec8b3a 高清影视种子： https://workflow.is/workflows/1c654255929748e8b0e0d564bdd73535 手机电视选播： https://workflow.is/workflows/e4a49bb652a7433ebd6113074a4edf64 硕鼠下载： https://workflow.is/workflows/1e3b894f798b48748f002b83acec39c2 百思不得姐： https://workflow.is/workflows/b4a7949d3dc147dd80fd52f3391fc6c2 获取贴吧视频并下载： https://workflow.is/workflows/ef1ae00fb15f45fd9478826c593384dd 汤不汤下载图片视频： https://workflow.is/workflows/627a5712aa8d4a22b27e2451f1016ed8 多媒体视频下载 包括facebook youtube 等： https://workflow.is/workflows/835158353688424e878f2787bbed3aca Tumblr视频保存到相册： https://workflow.is/workflows/628bb0345e60434eb047ef1e03db5d5d youtube保存到相册： https://workflow.is/workflows/ec284f18720c45e39ff31128e6d42602 youtube保存到各APP： https://workflow.is/workflows/01fdf6b4a30d43fcb1ae5f01763b4abc 新浪微博视频 先复制视频页地址 在运行： https://workflow.is/workflows/fd7fe0b7548046e689e9776b2182a8b1 从Twitter推特保存视频： https://workflow.is/workflows/75562e41b6c74540903786ae9b6f1c50 下载YouTube视频： https://workflow.is/workflows/73971870942c49da96cae6a490aea8e0 下载视频的tumblr： https://workflow.is/workflows/f8656cbb90524dffa1fe2eba8975946e 获取推特视频： https://workflow.is/workflows/087a0abf12c049dd9ab256afaec790c0 音乐类自定义换铃声： https://workflow.is/workflows/3f326b92ceff4daf93213a8156cf56f0 Echo歌曲封面下载： https://workflow.is/workflows/315c89de743c4fc5b2bfb3e17ca56daf 酷铃： https://workflow.is/workflows/5bc695db141344e18160b7f625a96cee 音乐全网搜： https://workflow.is/workflows/38beeda32d974b9590ac49f88af0f888 酷狗音乐下载： https://workflow.is/workflows/7533d9077ebc48e184124b69f4460300 音乐下载： https://workflow.is/workflows/d5c0b45fc7d042f591ed2e08a48e4aec 网易云MV下载到本地： https://workflow.is/workflows/61768ff0f8b641c4ba448f5ccf342b3c 一键听音识曲： https://workflow.is/workflows/87fb626a800a409d96b7fa9b932869a4 网易云音乐下载： https://workflow.is/workflows/fe5c7af3546e4f2c897eb3b5a9e26fd1 自带播放器控制： https://workflow.is/workflows/ecb94c5e577c4d908f4fd8e029aa342e 分享音乐到Instagram： https://workflow.is/workflows/402507226b8844258dee694d58b126e9 网易音乐分享到推特： https://workflow.is/workflows/dc191b2487e147e489072c801592b10 云MV下载： https://workflow.is/workflows/b7525adabf5c42269fba8cfd31b4ce78 云换铃声： https://workflow.is/workflows/e3c2fe9c7ece4499bd541fc173571d6a 音乐搜索下载： https://workflow.is/workflows/630a8faea48548b3a9edbf90ecde1634 中国广播电台： https://workflow.is/workflows/0f018325f13348148e6cefb54d7f275c 中国广播电台：（跳转Safari播放）： https://workflow.is/workflows/f656b3950d6c4c1abfff226b66b86c0f 网易云音乐听歌识曲： https://workflow.is/workflows/287ab4e34a5a4df78b19a268562cdb6d 图片处理类8的水印： https://workflow.is/workflows/7ed357d22eba41f9aff7ea9d919ffe99 8P的水印： https://workflow.is/workflows/dc0334ca795e44cf886099f6e7e68e23 Live 图片 GIF 视频互转： https://workflow.is/workflows/d9e289faeb1a4cd0ba2d042ebab0b077 带壳截图： 7f9d4d7581b24db88e5d199d1f9d6c00https://workflow.is/workflows/ 带壳截图3.5英寸： https://workflow.is/workflows/b26b8000dfb84d4989efd5f8f316a1db 4.0英寸： https://workflow.is/workflows/3f5e833b930d49e18715be5620bf5abd 4.7英寸： https://workflow.is/workflows/9f85cabc2f3d4075b1c45b424bef2bcd 5.5英寸： https://workflow.is/workflows/16d4b9c372744aa39c42462a8129795e GIF动图制作： https://workflow.is/workflows/a9585d506b3b4e36b83dfaf7d1574db3 头像加V： https://workflow.is/workflows/5b18a972306f4f6ba977fb2ff27bc7f6 炫彩带壳截图： https://workflow.is/workflows/04f20d736bd8499cb32db867a9efe288 长图拼接加壳： https://workflow.is/workflows/51c53c15488a4850b5e0a22d2d119ed5 删.改.拼.图片： https://workflow.is/workflows/c82d7c20470041749242979830ca0580 GIF拼图： https://workflow.is/workflows/013f619506e740d9a955bfdada1b27c9 调整图片大小： https://workflow.is/workflows/a1d7833cea9c496f9b0ade7511e9bf11 图片处理： https://workflow.is/workflows/3858d10b37504070bc7f2e1fe1b10487 添加水印： https://workflow.is/workflows/df11bd30e77d4e71ae2d25f96fad6caa 图片瘦身： https://workflow.is/workflows/a5ce48af71fe4ab98a8f36006e5bd0ef 清理当天照片： https://workflow.is/workflows/48492391bd9d460e9a0983b1f8a17d2c 图片处理： https://workflow.is/workflows/2cb29c09bd33491d9e649cf3083235c9 截图处理： https://workflow.is/workflows/3509c9d8d84b4f498870353dad16693b 九宫格发朋友圈： https://workflow.is/workflows/3124002e75c9491f87d7b20144dc3efc 全能图片处理： https://workflow.is/workflows/cc5ffb42b76145199963aa1ffb754fd3 保存网页为pdf到ibook： https://workflow.is/workflows/2027271452ce4712853838f43550d326 从Instagram保存图片： https://workflow.is/workflows/73aa53dfae9c45729befb49cdc6863f0 照片添加日期： https://workflow.is/workflows/3658b5536e774200b99941794b6e8872 软件类支付宝： h ttps://workflow.is/workflows/b76322a536784eb28082ecf38685388e 支付宝： https://workflow.is/workflows/0dee7e5b0f7f4596aa9e96cec9958d97 修改版 保存到iCloud： https://workflow.is/workflows/08f3cc0e184844339eb2f5caa58a316b 内涵段子： https://workflow.is/workflows/590cd4e617504660ae3f35a3fda83cd1 描述文件安装： https://workflow.is/workflows/8a8ad7cfdfa24a4b8eeb96bc8ca05e8d 限免软件： https://workflow.is/workflows/b1923a7bb91e4ca8b28e60e9f9260793 提取应用IPA地址： https://workflow.is/workflows/ae4559ec421d481fb7df53dbbdb67080 说不出的痛的规则更新器： https://workflow.is/workflows/925d045723464cdea92febefdf966be2 追书神器2.41： https://workflow.is/workflows/50cf570466304b69a493cde50b120f87 花果科技： https://workflow.is/workflows/3fb238670487430c965fc1d4ddbfbe4d 知乎日报： https://workflow.is/workflows/bdeee3e64a854ea4a425b327c4e28366 全能下载器更新： https://workflow.is/workflows/e59b85f26dba48449ea4a961757a3b87 百度知道日报： https://workflow.is/workflows/4f17200f5fe649c29cd0450647b60724 颜文字大全： https://workflow.is/workflows/7c76410b6aeb4e4c807097fb34a81936 百度云链接提取 https://workflow.is/workflows/7d5e23304a6b4437ae0613841791ee35 中国天气预报： https://workflow.is/workflows/c57648ee0a7b467f867d51274507c924 支付宝工具： https://workflow.is/workflows/0601916fca2b444e8c0a1567ae09cf53 扫一扫付款： https://workflow.is/workflows/684e1d36cb4547a7abc92f13248f1b9d 新建印象笔记： https://workflow.is/workflows/290bbbb30d8c45e196a7454746d2f55a 支付宝 微信码： h ttps://workflow.is/workflows/b76322a536784eb28082ecf38685388e BT快搜： https://workflow.is/workflows/516802f894a1448498b59b43121f4eb2 手机迅雷下载： http://ithunder-ota.a.88cdn.com/download-guide/index.html?from=gongzhonghao 种子搜索： https://workflow.is/workflows/a7c1f0e38a084a74a1d856e247cbf5a4 Workflow 大全搜索版： https://workflow.is/workflows/6d7852c6d5014404b2ba8620c261ec0e 磁力搜索： https://workflow.is/workflows/e3a06bb11140499ab775fb48bbe47baf bt全能： https://workflow.is/workflows/1853f5d3286247769d1cb8ef4944ce52 制作和扫描二维码： https://workflow.is/workflows/4ce01285d2874d898092f833a87b7f77 小良规则更新器（6.12）： https://workflow.is/workflows/b9e60f9403324204a025820169026bd4 长按识别二维码： https://workflow.is/workflows/5c77f7aca79e4b748fe27db2057ed8c4 小良免越狱APP下载器： https://workflow.is/workflows/f57b46b0ff7f42b184e715ebbbd4511b 百度云直达： https://workflow.is/workflows/9cae28afb19d4ce7837b3167df089685 i苹果助手： https://workflow.is/workflows/9c39b2a50c90434dbcbb06b807ea3419 小良更新器2.0： https://workflow.is/workflows/89676c5c53ca4770903bd1069b31111d 小良更新器 2.1： https://workflow.is/workflows/0901294fe3b14d59a2304dc65720b53b （这两个里面的内容不一样的哦） 视频 音乐 图片 格式转化： https://workflow.is/workflows/b2c5b7fdd01143f78e3cdeb126852f4d 万能扫码： https://workflow.is/workflows/2847d71fd9a244ad8e3d3f367fc392b4 翻译类网页翻译： https://workflow.is/workflows/f109a46d8b254b2da8755d88e2c26510 翻译： https://workflow.is/workflows/a51df78f80414edf8469727f892d662d （好像是谷歌翻译） 百度翻译： https://workflow.is/workflows/39e0fed899824a14a2dd2f729cf98dac OCR+翻译： https://workflow.is/workflows/dc226a211c0d48ba82c24c78ef04a29d 语言互译： https://workflow.is/workflows/6a8a934d2ada4a5a89d437300449a7ad 有道翻译： https://workflow.is/workflows/eff8ab0e2971445f88eb8c0d79c57029 插件 工具类微信改步： https://workflow.is/workflows/ee001fd20a144b008b3928f29404f4d8 请在“健康”→“步数”→数据源与访问权→点击右上角“编辑”，将Workfiow移动到iphone**上面（ps：此处会优先读取Workfiow的数据） 剪贴板操作： https://workflow.is/workflows/270f34a977fd48788fcb8874c718d4ea 立即录音： https://workflow.is/workflows/fa0380bd65e04a1abcae61d82de723b0 APP store 搜索地区切换： https://workflow.is/workflows/8d3fb4db12b24a8ba7ae1775954b36c1 定位开关： https://workflow.is/workflows/9468ef77fa06427a8dcd287fb0cac8a6 展开网址的tumblr： https://workflow.is/workflows/62a9534d3ee1467080cd4136578d3d35 下载Twitter的GIF： https://workflow.is/workflows/aa9821c4bce44b6f8febcbda6245c1f0 备份workflow工作流： https://workflow.is/workflows/c5421ebe19bd4bf885da8b74d2cbaded 剪切板列表： https://workflow.is/workflows/db3321f2eec84c4eb2caf29a6df81286 剪贴板翻译： https://workflow.is/workflows/5de0062c54c041a386be048dd84fa361 复制到剪贴板： https://workflow.is/workflows/3242da310c4a45ec8270a09e49e6aa37 书签： https://workflow.is/workflows/86a36fe10ac54a0cbe21c0016e762dee 电池： https://workflow.is/workflows/febeed3ed07a4c78b9e77c2f48136a2a 低功耗模式： https://workflow.is/workflows/640ae7eb22f143a093c77215a6e373e2 通知中心找IP和位置： https://workflow.is/workflows/ea529c591a2740169388c0d2b8ca6505 货币换算： https://workflow.is/workflows/50f0132cbe654370bc35189e1cf31b86 今天的天气： https://workflow.is/workflows/cf6db9a3c90c4bc7adec27f739480937 生成二维码： https://workflow.is/workflows/19a590ffc2c54cffbbe7e8c8a58c1a3a 扫描二维码： https://workflow.is/workflows/2be2c6a4cb1348c684d51075adba803b 快捷开关： https://workflow.is/workflows/fef60e8bed1446f6bf1284ddd6e3e05e 安装字体： https://workflow.is/workflows/f9da142fe53946cd985459f96d2637e9 TestFlight内测申请： https://workflow.is/workflows/200219ed6526470cb9f5cbff28f71f67 假装自己有iPhone X： https://workflow.is/workflows/497375614fa44cff9abcdeecc595ee8c 应用二维码制作： https://workflow.is/workflows/19b128cce32b4232aafa485defe52e19 通知中心日历： https://workflow.is/workflows/df2e1cd93f5b410d90b4f2e233973af8 免费拉圈圈： https://workflow.is/workflows/695fe958e47944068d9500ec155e99ce DownFi： https://workflow.is/workflows/480f7264dd194a14afa3171b852f9cb0 小工具： https://workflow.is/workflows/e34d524eb6ab47188fba6484dd5b126d 外汇自由转换： https://workflow.is/workflows/b2ce086294ec4de3b87add9e829f048f Add to Reminder： https://workflow.is/workflows/31b38a2dc4234d8f81cd6de702d9edeb 时间： https://workflow.is/workflows/1620aeb3fba14da295802288ba633d65 历史上的今天： https://workflow.is/workflows/9d749cc9c1d9440b852f7f636ed916f5 贴吧一键签到： https://workflow.is/workflows/6fd8253918584af5849da5097fa2eefe Emoji Shortener： https://workflow.is/workflows/d817a6ac40c54be28412ea5c2b405305 长短链接转换： https://workflow.is/workflows/0f768fdbe8b54fa28258fd4363b65e17 Save App Store Assets： https://workflow.is/workflows/a6d26724248e4933bf09ac19bbc21d4b Day Count： https://workflow.is/workflows/66e40e40852b47f3af326fd0dcd6eab0 今年百分比： https://workflow.is/workflows/fa6b77fa9624481bb1af527eac722f0e 发送联系人消息： https://workflow.is/workflows/2cab2a99edc247a8990822fb8299e6bc 藏头诗： https://workflow.is/workflows/e0b897d9be4649c4b0cbd8b7b8a9787e 曲面立体壁纸： https://workflow.is/workflows/6b6df45ebe4247a099c60e77cb540efb 每日Bing壁纸： https://workflow.is/workflows/07ea8a5b08d742068375774823c03460 今日星座运势： https://workflow.is/workflows/c8928d815df24ce287e0831d83aee4c6 拓展列表更新： https://workflow.is/workflows/745e9f62d44a4f9cbcc130945c668111 拓展列表小屏版更新： https://workflow.is/workflows/2df723ec4fcb4d02bcde0d88ebc90c86 快捷添加规则： https://workflow.is/workflows/fece894ed914426b97bb0422df0551df 固件状态检验： https://workflow.is/workflows/022a3f833b2f47fba6c6b8103438368b 我家WIFI： https://workflow.is/workflows/330a4705aa024c67ae2daeefce3a5a9e 计算器： https://workflow.is/workflows/b804addbe79a4cd3adebd0c43885fc92 励志语录： https://workflow.is/workflows/913cd677bb2541338f08935e4468cf15 中关村壁纸获取： https://workflow.is/workflows/20890e3a2b8144989506d08b70e415c4 下载地址转换： https://workflow.is/workflows/88b5cb65d34d493dacc153a26758cd0c 拓展列表： https://workflow.is/workflows/6399954de5514409b6a1584828527339 闪念胶囊： https://workflow.is/workflows/b59471ea6b6e4c29b7b92255421f5c0d 图标任意摆： https://workflow.is/workflows/35a9b8a48477402eb29b4b5c721f17fd 小辫儿Emoji表情： https://workflow.is/workflows/b94010b415384b67873ef4afa0582619 今日NBA： https://workflow.is/workflows/6732722ce99e40de9e8a4348f9da851a 快速拨号： https://workflow.is/workflows/4ee67371c9064b85ad47b366074c29ab Cydia常用源添加： https://workflow.is/workflows/ef9a02459e62408fa9d6b63fa2641ff3 群发短信： https://workflow.is/workflows/72e9ce9bb92f458698b14429f1b7703d 分享截图： https://workflow.is/workflows/f634d4366a5e4050b630eb85b3ba34bf 金额小写转大写： https://workflow.is/workflows/bb1f3050209d4fd8b089b711614efe14 快捷设置： https://workflow.is/workflows/ad62901a1db74f7195ac90fd26d3bede 新建备忘录： https://workflow.is/workflows/e23901d69a724796bb3ebe56f1682d98 打开程序设置： https://workflow.is/workflows/17e84cd6ba6c4c4ebcc1cb1c3a7c6d8f 打开常用程序： https://workflow.is/workflows/9a3adf41fe314a9cb75c558f9116d869 自定义提醒事项： https://workflow.is/workflows/d880d59819e94488a1d6e374b2e4bd80 WF备份清理与恢复： https://workflow.is/workflows/97e08a3d338e4b3797abf8e49e600b2a 详查App.信息： https://workflow.is/workflows/aa4b3c9daf334f699ceac4472df83e31 zip or unzip： https://workflow.is/workflows/67ff59ada3664f5a913a6041e7858607 中国天气预报： https://workflow.is/workflows/ed6f51ce691e4877b7ac1c46b67fe451 上角标生成器： https://workflow.is/workflows/36ee090cb98d4d769789d8ef09360e7f 路由器管理： https://workflow.is/workflows/a2b5bc90e86542a09dc415ea37a71c6f 短信轰炸： https://workflow.is/workflows/1d56b34f626f45889eb0d81c7a4c7879 群发短信： https://workflow.is/workflows/9f0d2a497d6b4e5797ca1959d7dcb722 时间节日提醒： https://workflow.is/workflows/0fdee9ae359e4060ab4acf1ee6dbebbf 搜索查询淘宝搜索： https://workflow.is/workflows/64363e7312274ade87f20ae1a781e909 百度搜索： https://workflow.is/workflows/b18f1d4121ed40a2bdb65a8bbc014d45 电影搜索： https://workflow.is/workflows/99680d2c220346288353ac0ddfba1775 单词查询： https://workflow.is/workflows/d4700f755e254f4398ec30177063212b 百度以图搜索： https://workflow.is/workflows/c4b68fa776df49b2a493638fb5d4e958 链接用浏览器打开： https://workflow.is/workflows/62bcee657bd84c5c94e6d35ff3c368f1 APP 查询： https://workflow.is/workflows/c49b467e5ed143b0a6b7c6a5c9b5553f 读取照片位置并导航： https://workflow.is/workflows/3933da88677a42618a0f4438663bb0cb 快递查询： https://workflow.is/workflows/8bfb633d09fd40a58079c8c62928d537 获取本机IP信息： https://workflow.is/workflows/2d0f218b5799413fa3511810df01bff0 自定义搜索： https://workflow.is/workflows/ac4b4abac0a2490e872b7134f5f9ca8a 多引擎搜索： https://workflow.is/workflows/7921f8c6ca7b48529cfe9b8d0f17466d 流量查询： https://workflow.is/workflows/068d7774623245a8849b5a051c41ee6d 快捷查询工具_beta3： https://workflow.is/workflows/a5fd63c35d2749ae97a0c1abe90c0152 快捷百度搜索： https://workflow.is/workflows/2b17916de5e14838a2bdfbef63acc662 搜索工具大全： https://workflow.is/workflows/5b9f7e7e375640a19483497f03738e21 全国火车查询： https://workflow.is/workflows/e31a38bbd1a84c91b41abf96a2e38f50 豆瓣电影查询： https://workflow.is/workflows/2fcbce53a5bc47dc8dd0cb1910e2c2c1 百度一键导航： https://workflow.is/workflows/d8033d962930480ca383b55a7790bd89 高德一键导航： https://workflow.is/workflows/4d36c3d1b8fa4fd5a59900803838ffd2 生日生肖查询： https://workflow.is/workflows/2252a01dcf8f488b87d0a971517e40e9 以上就是小编分享的 Workflow 规则大全，如果有其它不错的规则可以留言或者加QQ群（16009963）交流。 唯一不足就是 Workflow 目前没有支持中文语言，让很多新手用户感觉 Workflow 太过于复杂。 如何使用：先安装 Workflow，然后在手机上点开规则地址就可以安装了。 iOS 操作自动化神器：Workflow 规则大全（视频VIP/快速扫码/BT搜索等..） – 下1个好软件","link":"/2019/08/02/iOS%20%E6%93%8D%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96%E7%A5%9E%E5%99%A8%EF%BC%9AWorkflow%20%E8%A7%84%E5%88%99%E5%A4%A7%E5%85%A8%EF%BC%88%E8%A7%86%E9%A2%91VIP%E5%BF%AB%E9%80%9F%E6%89%AB%E7%A0%81BT%E6%90%9C%E7%B4%A2%E7%AD%89..%EF%BC%89%20%E2%80%93%20%E4%B8%8B1%E4%B8%AA%E5%A5%BD%E8%BD%AF%E4%BB%B6/"},{"title":"京东金融云，有意思","text":"京东金融云，有意思注意：此文为自愿五毛党，有不适者请赶快离开。 京东金融云，由京东金融集团发布（和京东云没有半毛关系）。旨在输出金融科技，目的在于快速搭建金融调度交换平台，快速与金融机构合作对接，做到智慧资金调度信贷匹配，让资金信贷周转最大化，让金融风控全程埋点与监控控制。 京东看似是线上零售商，有很多的现金流沉淀，但金融业务是一个对资金需求量更大的业务，所以京东金融必须调动社会所有资金，利用自己手中的数据（不断搭建资金调度平台也可以吸纳更多的新鲜数据）、企业客户和消费者客户、技术平台，做到资金巨量批发过来，智慧调度零售出去。 资金嘛，不就是一个特殊的商品嘛，本质一样，也需要批发买过来，也需要引流、零售卖出去。 至于这些科技能卖出多大规模的大钱？嘿嘿嘿。反正互联网的玩法一直是：羊毛出在狗身上，项庄舞剑意在沛公。当然，中国金融业在加速上云（不过这里面有非常完整的IT供应商利益链条），中国金融业也在加速以消费业务为重心，大量开展互联网业务应用（这是类似京东金融这样的互联网金融科技公司的机会）。 另外想起今天中午一件事：是关于万达飞凡严重重组事件。人家线上零售商业地产商阿里是靠金铺流量+金融赚钱，万达作为线下零售商业地产商是把万达广场金铺和金融业务隔离出去，纯粹靠IT想挣钱，王健林难道不知道在中国IT不值钱、不能直接依赖IT产品变现挣钱？人家阿里都还没从IT直接挣上大钱呢。 （1）营销科技 一、线下流量平台 1、引流应用：自助会员、iSee、北极光、互动营销、时光广告机 2、统计分析：客流量统计与分析、热力分布 二、广告营销管理平台 1、营销内容搭建平台 2、广告投放平台 3、数据分析平台 （2）智能支撑 一、人工智能视觉识别 1、人脸识别、人脸属性、人脸防伪、物体识别、生物识别、活体检测、动作识别、文字识别 二、语言处理 1、语音识别 三、自然语言处理 1、基础平台：文本处理、智能标注、个性化推荐 2、应用：智能舆情 四、机器学习平台 1、深度学习框架、京东超脑 （3）大数据支撑 一、大数据应用 1、金融风控：风险洞察、智能反欺诈、反洗钱 2、用户大数据：地址画像、用户关系网络、标签管理中心 3、业务应用引擎：策略回测引擎、策略实盘引擎、量化风控模型 二、大数据处理平台 1、数据管理平台、建模管理平台、数据运营平台 2、数据交易平台、API封装平台、服务接口平台、客户端数据服务平台 3、网络爬虫平台 （4）基础云计算支撑 一、开发平台 1、多终端开发平台 2、代码管理平台JCode 3、客户端测试平台 4、持续交付系统JCI、流程管理系统MagicFlow 5、自动化部署系统Pandora 二、PaaS分布式技术中间件 1、接入层网关平台JEN 2、服务化框架SSF 3、分布式缓存平台R2M 4、消息中间件FMQ 5、分布式配置中心 6、分布式调度Schedule 7、精准时间服务 8、弹性搜索JES 三、PaaS分布式数据库 1、分库分表中间件CDS、数据库高可用PyMHA 2、数据交换平台DBRep 3、基础数据平台DataBee 4、虚机云数据库VDB、物理云数据库HDB、容器云数据库CDB 5、HBase数据中心Hcenter 6、数据库管理平台Mega、数据库操作引擎 DBEE 四、自动化监控运维 1、监控：服务监控治理SGM、网络设备监控 NPM、主机监控系统DTinM、统一日志Digger、告警中心UWC 2、管理：配置管理平台WanderB、应用信息中心Sure、资产管理系统Asset 五、安全服务 1、主机安全：主机入侵检测HIDS 2、网络安全：DDos高防服务 JDGuard、DDos攻击检测服务 Detector 3、Web安全：CA证书中心、Web安全防火墙 JDShield 4、应用安全：业务安全SkyEye、漏洞扫描平台 VMS、移动加固服务 MRI、App漏洞检测平台 AppHunter 5、数据安全：数据安全系统 AKS、Web数据安全 SafeH5 六、云计算平台 1、云主机：弹性计算JEC 2、云网络：虚拟专有网VPC、弹性公网IP、云NAT网关、金融云负载均衡 SLB、软负载均衡系统 LBS、分布式DNS管控平台 WYDNS、域名解析系统 ADNS、移动安全DNS HDNS 3、资源管理：资源管理平台IaaS、网络管理平台NIMS 长按二维码向我转账 受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。 京东金融云，有意思","link":"/2019/08/02/%E4%BA%AC%E4%B8%9C%E9%87%91%E8%9E%8D%E4%BA%91%EF%BC%8C%E6%9C%89%E6%84%8F%E6%80%9D/"},{"title":"你不是Google，一语点醒技术人","text":"你不是Google，一语点醒技术人软件工程师总是着迷于荒唐古怪的事。我们看起来似乎很理性，但在面对技术选型时，总是陷入抓狂——从 Hacker News 到各种博客，像一只飞蛾一样，来回折腾，最后精疲力尽，无助地飞向一团亮光，跪倒在它的前面——那就是我们一直在寻找的东西。真正理性的人不是这样做决定的。不过工程师一贯如此，比如决定是否使用 MapReduce。Joe Hellerstein 在他的大学数据库教程视频中说道： 1世界上只有差不多 5 个公司需要运行这么大规模的作业。至于其他公司……他们使用了所有的 IO 来实现不必要的容错。在 2000 年代，人们狂热地追随着 Google：“我们要做 Google 做过的每一件事，因为我们也运行着世界上最大的互联网数据服务。” 超出实际需求的容错没有什么问题，但我们却为此付出了的惨重的代价：不仅增加了 IO，还有可能让原先成熟的系统——包含了事务、索引和查询优化器——变得破碎不堪。这是一个多么严重的历史倒退！有多少个 Hadoop 用户是有意识地做出这种决定的？有多少人知道他们的决定到底是不是一个明智之举？MapReduce 已经成为一个众矢之的，那些盲目崇拜者也意识到事情不对劲。但这种情况却普遍存在：虽然你使用了大公司的技术，但你的情况却与他们大不一样，而且你的决定并没有经过深思熟虑，你只是习以为常地认为，模仿巨头公司就一定也能给你带来同样的财富。是的，这又是一篇劝大家“不要盲目崇拜”的文章。不过这次我列出了一长串有用的清单，或许能够帮助你们做出更好的决定。 很酷的技术？UNPHAT如果你还在使用 Google 搜索新技术来重建你的软件架构，那么我建议你不要再这么做了。相反，你可以考虑应用 UNPHAT 原则。 1 在彻底了解（Understand）你的问题之前，不要急着去寻找解决方案。你的目标应该是在问题领域内“解决”问题，而不是在方案领域内解决问题。 2 列出（eNumerate）多种方案，不要只把眼睛盯在你最喜欢的方案上。 3 选择一个候选方案，并阅读相关论文（Paper）。 4 了解候选方案的产生背景（Historical context）。 5 比较优点（Advantages）和缺点，扬长避短。 6 思考（Think）！冷静地思考候选方案是否适合用于解决你的问题。要出现怎样异常的情况才会让你改变注意？例如，数据要少到什么程度才会让你打消使用 Hadoop 的念头？ 你不是 AmazonUNPHAT 原则十分直截了当。最近我与一个公司有过一次对话，这个公司打算在一个读密集的系统里使用 Cassandra，他们的数据是在夜间加载到系统里的。他们阅读了 Dynamo 的相关论文，并且知道 Cassandra 是最接近 Dynamo 的一个产品。我们知道，这些分布式数据库优先保证写可用性（Amazon 是不会让“添加到购物车”这种操作出现失败的）。为了达到这个目的，他们在一致性以及几乎所有在传统 RDBMS 中出现过的特性上做出了妥协。但这家公司其实没有必要优先考虑写可用性，因为他们每天只有一次写入操作，只是数据量比较大。他们之所以考虑使用 Cassandra，是因为 PostgreSQL 查询需要耗费几分钟的时间。他们认为是硬件的问题，经过排查，我们发现数据表里有 5000 万条数据，每条数据最多 80 个字节。如果从 SSD 上整块地读取所有数据大概需要 5 秒钟，这个不算快，但比起实际的查询，它要快上两个数量级。我真的很想多问他们几个问题（了解问题！），在问题变得愈加严重时，我为他们准备了 5 个方案（列出多个候选方案！），不过很显然，Cassandra 对于他们来说完全是一个错误的方案。他们只需要耐心地做一些调优，比如对部分数据重新建模，或许可以考虑使用（当然也有可能没有）其他技术……但一定不是这种写高可用的键值存储系统，Amazon 当初创建 Cassandra 是用来解决他们的购物车问题的！ 你不是 LinkedIn我发现一个学生创办的小公司居然在他们的系统里使用 Kafka，这让我感到很惊讶。因为据我所知，他们每天只有很少的事务需要处理——最好的情况下，一天最多只有几百个。这样的吞吐量几乎可以直接记在记事本上。Kafka 被设计用于处理 LinkedIn 内部的吞吐量，那可是一个天文数字。即使是在几年前，这个数字已经达到了每天数万亿，在高峰时段每秒钟需要处理 1000 万个消息。不过 Kafka 也可以用于处理低吞吐量的负载，或许再低 10 个数量级？或许工程师们在做决定时确实是基于他们的预期需求，并且也很了解 Kafka 的适用场景。但我猜测他们是抵挡不住社区对 Kafka 的追捧，并没有仔细想过 Kafka 是否适合他们。要知道，那可是 10 个数量级的差距！ 再一次，你不是 Amazon比 Amazon 的分布式数据库更为著名的是它的可伸缩架构模式，也就是面向服务架构。Werner Vogels 在 2006 年的一次访谈中指出，Amazon 在 2001 年时就意识到他们的前端需要横向伸缩，而面向服务架构有助于他们实现前端伸缩。工程师们面面相觑，最后只有少数几个工程师着手去做这件事情，而几乎没有人愿意将他们的静态网页拆分成小型的服务。不过 Amazon 还是决定向 SOA 转型，他们当时有 7800 个员工和 30 亿美元的销售规模。当然，并不是说你也要等到有 7800 个员工的时候才能转向 SOA……只是你要多想想，它真的能解决你的问题吗？你的问题的根源是什么？可以通过其他的方式解决它们吗？如果你告诉我说，你那 50 个人的公司打算转向 SOA，那么我不禁感到疑惑：为什么很多大型的公司仍然在乐此不彼地使用具有模块化的大型单体应用？ 甚至 Google 也不是 Google使用 Hadoop 和 Spark 这样的大规模数据流引擎会非常有趣，但在很多情况下，传统的 DBMS 更适合当前的负载，有时候数据量小到可以直接放进内存。你是否愿意花 10,000 美金去购买 1TB 的内存？如果你有十亿个用户，每个用户仅能使用 1KB 的内存，所以你的投入远远不够。或许你的负载大到需要把数据写回磁盘。那么你需要多少磁盘？你到底有多少数据量？Google 之所以要创建 GFS 和 MapReduce，是要解决整个 Web 的计算问题，比如重建整个 Web 的搜索索引。或许你已经阅读过 GFS 和 MapReduce 的论文，Google 的部分问题在于吞吐量，而不是容量，他们之所以需要分布式的存储，是因为从磁盘读取字节流要花费太多的时间。那么你在 2017 年需要使用多少设备吞吐量？你一定不需要像 Google 那么大的吞吐量，所以你可能会考虑使用更好的设备。如果都用上 SSD 会给你增加多少成本？或许你还想要伸缩性。但你有仔细算过吗，你的数据增长速度会快过 SSD 降价的速度吗？在你的数据撑爆所有的机器之前，你的业务会有多少增长？截止 2016 年，Stack Exchange 每天要处理 2 亿个请求，但是他们只用了 4 个 SQL Server，一个用于 Stack Overflow，一个用于其他用途，另外两个作为备份复本。或许你在应用 UNPHAT 原则之后，仍然决定要使用 Hadoop 或 Spark。或许你的决定是对的，但关键的是你要用对工具。Google 非常明白这个道理，当他们意识到 MapReduce 不再适合用于构建索引之后，他们就不再使用它。 先了解你的问题我所说的也不是什么新观点，不过或许 UNPHAT 对于你们来说已经足够了。如果你觉得还不够，可以听听 Rich Hickey 的演讲“吊床驱动开发（Hammock Driven Development）”，或者看看 Polya 的书《How to Solve It》， 或者学习一下 Hamming 的课程“The Art of Doing Science and Engineering”。我恳请你们一定要多思考！在尝试解决问题之前先对它们有充分的了解。最后送上 Polya 的一个金句名言：回答一个你不了解的问题是愚蠢的，到达一个你不期望的终点是悲哀的。","link":"/2019/08/02/%E4%BD%A0%E4%B8%8D%E6%98%AFGoogle%EF%BC%8C%E4%B8%80%E8%AF%AD%E7%82%B9%E9%86%92%E6%8A%80%E6%9C%AF%E4%BA%BA/"},{"title":"全文搜索引擎 ElasticSearch 入门教程","text":"全文搜索引擎 ElasticSearch 入门教程全文搜索 属于最常见的需求，开源的 ElasticSearch （以下简称 Elastic）是目前全文搜索引擎的首选。 它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它。 Elastic 的底层是开源库 Lucene 。但是，你没法直接用 Lucene，必须自己写代码去调用它的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。 本文从零开始，讲解如何使用 Elastic 搭建自己的全文搜索引擎。每一步都有详细的说明，大家跟着做就能学会。 一、安装Elastic 需要 Java 8 环境。如果你的机器还没安装 Java，可以参考 这篇文章 ，注意要保证环境变量 JAVA_HOME 正确设置。 安装完 Java，就可以跟着 官方文档 安装 Elastic。直接下载压缩包比较简单。 123$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.1.zip$ unzip elasticsearch-5.5.1.zip$ cd elasticsearch-5.5.1/ 接着，进入解压后的目录，运行下面的命令，启动 Elastic。 1$ ./bin/elasticsearch 如果这时 报错“max virtual memory areas vm.max map count [65530] is too low”，要运行下面的命令。 1$ sudo sysctl -w vm.max_map_count=262144 如果一切正常，Elastic 就会在默认的9200端口运行。这时，打开另一个命令行窗口，请求该端口，会得到说明信息。 12$ curl localhost:9200 { &quot;name&quot; : &quot;atntrTf&quot;, &quot;cluster_name&quot; : &quot;elasticsearch&quot;, &quot;cluster_uuid&quot; : &quot;tf9250XhQ6ee4h7YI11anA&quot;, &quot;version&quot; : { &quot;number&quot; : &quot;5.5.1&quot;, &quot;build_hash&quot; : &quot;19c13d0&quot;, &quot;build_date&quot; : &quot;2017-07-18T20:44:24.823Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;6.6.0&quot; }, &quot;tagline&quot; : &quot;You Know, for Search&quot;} 上面代码中，请求9200端口，Elastic 返回一个 JSON 对象，包含当前节点、集群、版本等信息。 按下 Ctrl + C，Elastic 就会停止运行。 默认情况下，Elastic 只允许本机访问，如果需要远程访问，可以修改 Elastic 安装目录的 config/elasticsearch.yml 文件，去掉 network.host 的注释，将它的值改成 0.0.0.0 ，然后重新启动 Elastic。 1network.host: 0.0.0.0 上面代码中，设成 0.0.0.0 让任何人都可以访问。线上服务不要这样设置，要设成具体的 IP。 二、基本概念2.1 Node 与 ClusterElastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。 单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。 2.2 IndexElastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。 所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。 下面的命令可以查看当前节点的所有 Index。 1$ curl -X GET 'http://localhost:9200/_cat/indices?v' 2.3 DocumentIndex 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。 Document 使用 JSON 格式表示，下面是一个例子。 12{ &quot;user&quot;: &quot;张三&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;数据库管理&quot;} 同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。 2.4 TypeDocument 可以分组，比如 weather 这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。 不同的 Type 应该有相似的结构（schema），举例来说， id 字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的 一个区别 。性质完全不同的数据（比如 products 和 logs ）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。 下面的命令可以列出每个 Index 所包含的 Type。 1$ curl 'localhost:9200/_mapping?pretty=true' 根据 规划 ，Elastic 6.x 版只允许每个 Index 包含一个 Type，7.x 版将会彻底移除 Type。 三、新建和删除 Index新建 Index，可以直接向 Elastic 服务器发出 PUT 请求。下面的例子是新建一个名叫 weather 的 Index。 1$ curl -X PUT 'localhost:9200/weather' 服务器返回一个 JSON 对象，里面的 acknowledged 字段表示操作成功。 12{ &quot;acknowledged&quot;:true, &quot;shards_acknowledged&quot;:true} 然后，我们发出 DELETE 请求，删除这个 Index。 1$ curl -X DELETE 'localhost:9200/weather' 四、中文分词设置首先，安装中文分词插件。这里使用的是 ik ，也可以考虑其他插件（比如 smartcn ）。 1$ ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.1/elasticsearch-analysis-ik-5.5.1.zip 上面代码安装的是5.5.1版的插件，与 Elastic 5.5.1 配合使用。 接着，重新启动 Elastic，就会自动加载这个新安装的插件。 然后，新建一个 Index，指定需要分词的字段。这一步根据数据结构而异，下面的命令只针对本文。基本上，凡是需要搜索的中文字段，都要单独设置一下。 123$ curl -X PUT 'localhost:9200/accounts' -d '{ &quot;mappings&quot;: { &quot;person&quot;: { &quot;properties&quot;: { &quot;user&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_max_word&quot; }, &quot;title&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_max_word&quot; }, &quot;desc&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_max_word&quot; } } } }}' 上面代码中，首先新建一个名称为 accounts 的 Index，里面有一个名称为 person 的 Type。 person 有三个字段。 这三个字段都是中文，而且类型都是文本（text），所以需要指定中文分词器，不能使用默认的英文分词器。 Elastic 的分词器称为 analyzer 。我们对每个字段指定分词器。 12&quot;user&quot;: { &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_max_word&quot;} 上面代码中， analyzer 是字段文本的分词器， search_analyzer 是搜索词的分词器。 ik_max_word 分词器是插件 ik 提供的，可以对文本进行最大数量的分词。 五、数据操作5.1 新增记录向指定的 /Index/Type 发送 PUT 请求，就可以在 Index 里面新增一条记录。比如，向 /accounts/person 发送请求，就可以新增一条人员记录。 123$ curl -X PUT 'localhost:9200/accounts/person/1' -d '{ &quot;user&quot;: &quot;张三&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;数据库管理&quot;}' 服务器返回的 JSON 对象，会给出 Index、Type、Id、Version 等信息。 12{ &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;_version&quot;:1, &quot;result&quot;:&quot;created&quot;, &quot;_shards&quot;:{&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0}, &quot;created&quot;:true} 如果你仔细看，会发现请求路径是 /accounts/person/1 ，最后的 1 是该条记录的 Id。它不一定是数字，任意字符串（比如 abc ）都可以。 新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。 123$ curl -X POST 'localhost:9200/accounts/person' -d '{ &quot;user&quot;: &quot;李四&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;系统管理&quot;}' 上面代码中，向 /accounts/person 发出一个 POST 请求，添加一个记录。这时，服务器返回的 JSON 对象里面， _id 字段就是一个随机字符串。 12{ &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;AV3qGfrC6jMbsbXb6k1p&quot;, &quot;_version&quot;:1, &quot;result&quot;:&quot;created&quot;, &quot;_shards&quot;:{&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0}, &quot;created&quot;:true} 注意，如果没有先创建 Index（这个例子是 accounts ），直接执行上面的命令，Elastic 也不会报错，而是直接生成指定的 Index。所以，打字的时候要小心，不要写错 Index 的名称。 5.2 查看记录向 /Index/Type/Id 发出 GET 请求，就可以查看这条记录。 1$ curl 'localhost:9200/accounts/person/1?pretty=true' 上面代码请求查看 /accounts/person/1 这条记录，URL 的参数 pretty=true 表示以易读的格式返回。 返回的数据中， found 字段表示查询成功， _source 字段返回原始记录。 12{ &quot;_index&quot; : &quot;accounts&quot;, &quot;_type&quot; : &quot;person&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 1, &quot;found&quot; : true, &quot;_source&quot; : { &quot;user&quot; : &quot;张三&quot;, &quot;title&quot; : &quot;工程师&quot;, &quot;desc&quot; : &quot;数据库管理&quot; }} 如果 Id 不正确，就查不到数据， found 字段就是 false 。 12$ curl 'localhost:9200/weather/beijing/abc?pretty=true' { &quot;_index&quot; : &quot;accounts&quot;, &quot;_type&quot; : &quot;person&quot;, &quot;_id&quot; : &quot;abc&quot;, &quot;found&quot; : false} 5.3 删除记录删除记录就是发出 DELETE 请求。 1$ curl -X DELETE 'localhost:9200/accounts/person/1' 这里先不要删除这条记录，后面还要用到。 5.4 更新记录更新记录就是使用 PUT 请求，重新发送一次数据。 1234$ curl -X PUT 'localhost:9200/accounts/person/1' -d '{ &quot;user&quot; : &quot;张三&quot;, &quot;title&quot; : &quot;工程师&quot;, &quot;desc&quot; : &quot;数据库管理，软件开发&quot;}' { &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;_version&quot;:2, &quot;result&quot;:&quot;updated&quot;, &quot;_shards&quot;:{&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0}, &quot;created&quot;:false} 上面代码中，我们将原始数据从”数据库管理”改成”数据库管理，软件开发”。 返回结果里面，有几个字段发生了变化。 123&quot;_version&quot; : 2,&quot;result&quot; : &quot;updated&quot;,&quot;created&quot; : false 可以看到，记录的 Id 没变，但是版本（version）从 1 变成 2 ，操作类型（result）从 created 变成 updated ， created 字段变成 false ，因为这次不是新建记录。 六、数据查询6.1 返回所有记录使用 GET 方法，直接请求 /Index/Type/_search ，就会返回所有记录。 12$ curl 'localhost:9200/accounts/person/_search' { &quot;took&quot;:2, &quot;timed_out&quot;:false, &quot;_shards&quot;:{&quot;total&quot;:5,&quot;successful&quot;:5,&quot;failed&quot;:0}, &quot;hits&quot;:{ &quot;total&quot;:2, &quot;max_score&quot;:1.0, &quot;hits&quot;:[ { &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;AV3qGfrC6jMbsbXb6k1p&quot;, &quot;_score&quot;:1.0, &quot;_source&quot;: { &quot;user&quot;: &quot;李四&quot;, &quot;title&quot;: &quot;工程师&quot;, &quot;desc&quot;: &quot;系统管理&quot; } }, { &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;_score&quot;:1.0, &quot;_source&quot;: { &quot;user&quot; : &quot;张三&quot;, &quot;title&quot; : &quot;工程师&quot;, &quot;desc&quot; : &quot;数据库管理，软件开发&quot; } } ] }} 上面代码中，返回结果的 took 字段表示该操作的耗时（单位为毫秒）， timed_out 字段表示是否超时， hits 字段表示命中的记录，里面子字段的含义如下。 total ：返回记录数，本例是2条。 max_score ：最高的匹配程度，本例是 1.0 。 hits ：返回的记录组成的数组。返回的记录中，每条记录都有一个 _score 字段，表示匹配的程序，默认是按照这个字段降序排列。 6.2 全文搜索Elastic 的查询非常特别，使用自己的 查询语法 ，要求 GET 请求带有数据体。 123$ curl 'localhost:9200/accounts/person/_search' -d '{ &quot;query&quot; : { &quot;match&quot; : { &quot;desc&quot; : &quot;软件&quot; }}}' 上面代码使用 Match 查询 ，指定的匹配条件是 desc 字段里面包含”软件”这个词。返回结果如下。 12{ &quot;took&quot;:3, &quot;timed_out&quot;:false, &quot;_shards&quot;:{&quot;total&quot;:5,&quot;successful&quot;:5,&quot;failed&quot;:0}, &quot;hits&quot;:{ &quot;total&quot;:1, &quot;max_score&quot;:0.28582606, &quot;hits&quot;:[ { &quot;_index&quot;:&quot;accounts&quot;, &quot;_type&quot;:&quot;person&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;_score&quot;:0.28582606, &quot;_source&quot;: { &quot;user&quot; : &quot;张三&quot;, &quot;title&quot; : &quot;工程师&quot;, &quot;desc&quot; : &quot;数据库管理，软件开发&quot; } } ] }} Elastic 默认一次返回10条结果，可以通过 size 字段改变这个设置。 123$ curl 'localhost:9200/accounts/person/_search' -d '{ &quot;query&quot; : { &quot;match&quot; : { &quot;desc&quot; : &quot;管理&quot; }}, &quot;size&quot;: 1}' 上面代码指定，每次只返回一条结果。 还可以通过 from 字段，指定位移。 123$ curl 'localhost:9200/accounts/person/_search' -d '{ &quot;query&quot; : { &quot;match&quot; : { &quot;desc&quot; : &quot;管理&quot; }}, &quot;from&quot;: 1, &quot;size&quot;: 1}' 上面代码指定，从位置1开始（默认是从位置0开始），只返回一条结果。 6.3 逻辑运算如果有多个搜索关键字， Elastic 认为它们是 or 关系。 123$ curl 'localhost:9200/accounts/person/_search' -d '{ &quot;query&quot; : { &quot;match&quot; : { &quot;desc&quot; : &quot;软件 系统&quot; }}}' 上面代码搜索的是 软件 or 系统 。 如果要执行多个关键词的 and 搜索，必须使用 布尔查询 。 123$ curl 'localhost:9200/accounts/person/_search' -d '{ &quot;query&quot;: { &quot;bool&quot;: { &quot;must&quot;: [ { &quot;match&quot;: { &quot;desc&quot;: &quot;软件&quot; } }, { &quot;match&quot;: { &quot;desc&quot;: &quot;系统&quot; } } ] } }}' 七、参考链接 ElasticSearch 官方手册 A Practical Introduction to Elasticsearch（完） 全文搜索引擎 ElasticSearch 入门教程","link":"/2019/08/02/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%20ElasticSearch%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"title":"厉害了，关于String的10道经典面试题。","text":"厉害了，关于String的10道经典面试题。1、String是基本数据类型吗？ 2、String是可变的话？ 3、怎么比较两个字符串的值一样，怎么比较两个字符串是否同一对象？ 4、switch中可以使用String吗？ 5、String str = new String(“abc”);创建了几个对象，为什么？ 6、String、StringBuffer、StringBuilder有什么区别？ 7、String.trim()方法去掉的是哪些字符？ 8、String可以被子类继承吗？ 9、可以自定义java.lang.String类并使用吗？ 10、String与byte[]两者相互之间如何转换？ 上面的10道经典的String面试题，你都会吗？如果不会或者说不清楚，你想想为什么面试官不选你，而选择别人，这是有原因的。本公众号会通过一系列的面试题来解析java核心技术。","link":"/2019/08/02/%E5%8E%89%E5%AE%B3%E4%BA%86%EF%BC%8C%E5%85%B3%E4%BA%8EString%E7%9A%8410%E9%81%93%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%82/"},{"title":"去BAT面试完的Mysql面试题总结","text":"去BAT面试完的Mysql面试题总结1、一张表里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把mysql重启，再insert一条记录，这条记录的ID是18还是15 ？ 2、mysql的技术特点是什么？ 3、Heap表是什么？ 4、mysql服务器默认端口是什么？ 5、与Oracle相比，mysql有什么优势？ 6、如何区分FLOAT和DOUBLE？ 7、区分CHAR_LENGTH和LENGTH？ 8、请简洁描述mysql中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别？ 9、在mysql中ENUM的用法是什么？ 10、如何定义REGEXP？ 11、CHAR和VARCHAR的区别？ 12、列的字符串类型可以是什么？ 13、如何获取当前的mysql版本？ 14、mysql中使用什么存储引擎？ 15、mysql驱动程序是什么？ 16、TIMESTAMP在UPDATE CURRENT_TIMESTAMP数据类型上做什么？ 17、主键和候选键有什么区别？ 18、如何使用Unix shell登录mysql？ 19、 myisamchk是用来做什么的？ 20、mysql数据库服务器性能分析的方法命令有哪些? 21、如何控制HEAP表的最大尺寸？ 22、MyISAM Static和MyISAM Dynamic有什么区别？ 23、federated表是什么？ 24、如果一个表有一列定义为TIMESTAMP，将发生什么？ 25、列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？ 26、怎样才能找出最后一次插入时分配了哪个自动增量？ 27、你怎么看到为表格定义的所有索引？ 28、LIKE声明中的％和_是什么意思？ 29、如何在Unix和mysql时间戳之间进行转换？ 30、列对比运算符是什么？ 31、我们如何得到受查询影响的行数？ 32、mysql查询是否区分大小写？ 33、LIKE和REGEXP操作有什么区别？ 34、BLOB和TEXT有什么区别？ 35、mysql_fetch_array和mysql_fetch_object的区别是什么？ 36、我们如何在mysql中运行批处理模式？ 37、MyISAM表格将在哪里存储，并且还提供其存储格式？ 38、mysql中有哪些不同的表格？ 39、ISAM是什么？ 40、InnoDB是什么？ 41、mysql如何优化DISTINCT？ 42、如何输入字符为十六进制数字？ 43、如何显示前50行？ 44、可以使用多少列创建索引？ 45、NOW（）和CURRENT_DATE（）有什么区别？ 46、什么样的对象可以使用CREATE语句创建？ 47、mysql表中允许有多少个TRIGGERS？ 48、什么是非标准字符串类型？ 49、什么是通用SQL函数？ 50、解释访问控制列表 51、mysql支持事务吗？ 52、mysql里记录货币用什么字段类型好？ 53、mysql数据表在什么情况下容易损坏？ 54、mysql有关权限的表都有哪几个？ 55、mysql中有哪几种锁？","link":"/2019/08/02/%E5%8E%BBBAT%E9%9D%A2%E8%AF%95%E5%AE%8C%E7%9A%84Mysql%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"后端架构师技术图谱","text":"后端架构师技术图谱SKILLMAP/后端架构师技术图谱.md at master · DonxYu/SKILLMAP · GitHub","link":"/2019/08/02/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/"},{"title":"发票纳税识别号","text":"发票纳税识别号南京途牛科技有限公司【纳税识别号】91320102797102919G【地址、电话】南京市玄武区长江后街6号东大科技园6号楼 025-86853969【开户银行及账号】工商银行南京市软件园支行 4301032019000004654","link":"/2019/08/02/%E5%8F%91%E7%A5%A8%E7%BA%B3%E7%A8%8E%E8%AF%86%E5%88%AB%E5%8F%B7/"},{"title":"史上最全Java多线程面试题及答案","text":"史上最全Java多线程面试题及答案1、多线程有什么用？ 1）发挥多核CPU的优势 随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。 2）防止阻塞 从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。 3）便于建模 这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。 2、线程和进程的区别是什么？ 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 3、Java实现线程有哪几种方式？ 1、继承Thread类实现多线程2、实现Runnable接口方式实现多线程3、使用ExecutorService、Callable、Future实现有返回结果的多线程 参考：http://mp.weixin.qq.com/s/39Sb60J0DC2mNN6DYvpFtg 4、启动线程方法start()和run()有什么区别？ 只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。 5、怎么终止一个线程？如何优雅地终止线程？ stop终止，不推荐。参考：https://mp.weixin.qq.com/s/FPhtbM7Wdyr0iZqbdKecpA 6、一个线程的生命周期有哪几种状态？它们之间如何流转的？ 参考：http://mp.weixin.qq.com/s/hD3ie47XEWQQ577tX0Sawg 7、线程中的wait()和sleep()方法有什么区别？ 这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器 参考：http://mp.weixin.qq.com/s/7E8ywAQO8QS7C94LJN2vww 8、多线程同步有哪几种方法？ Synchronized关键字，Lock锁实现，分布式锁等。 9、什么是死锁？如何避免死锁？ 死锁就是两个线程相互等待对方释放对象锁。参考：http://mp.weixin.qq.com/s/soQG2pxTymgHzzNQqYYNgg 10、多线程之间如何进行通信？ wait/notify 11、线程怎样拿到返回结果？实现Callable接口。 12、violatile关键字的作用？ 一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个： 参考：http://mp.weixin.qq.com/s/TixFzi3JjXy0nQtviuVFOA 1、多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据 2、代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率 从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。 13、新建T1、T2、T3三个线程，如何保证它们按顺序执行？ 用join方法。参考：http://mp.weixin.qq.com/s/at8NynjnYvqkFw61kn3Apg 14、怎么控制同一时间只有3个线程运行？ 用Semaphore。 15、为什么要使用线程池？ 我们知道不用线程池的话，每个线程都要通过new Thread(xxRunnable).start()的方式来创建并运行一个线程，线程少的话这不会是问题，而真实环境可能会开启多个线程让系统和程序达到最佳效率，当线程数达到一定数量就会耗尽系统的CPU和内存资源，也会造成GC频繁收集和停顿，因为每次创建和销毁一个线程都是要消耗系统资源的，如果为每个任务都创建线程这无疑是一个很大的性能瓶颈。所以，线程池中的线程复用极大节省了系统资源，当线程一段时间不再有任务处理时它也会自动销毁，而不会长驻内存。 16、常用的几种线程池并讲讲其中的工作原理。 参考：http://mp.weixin.qq.com/s/L2KKLlmOKJUQKfLdFa-1FA 17、线程池启动线程submit()和execute()方法有什么不同？ execute没有返回值，如果不需要知道线程的结果就使用execute方法，性能会好很多。submit返回一个Future对象，如果想知道线程结果就使用submit提交，而且它能在主线程中通过Future的get方法捕获线程中的异常。 18、CyclicBarrier和CountDownLatch的区别？ 两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：1、CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行2、CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务3、CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了 参考：http://mp.weixin.qq.com/s/JqTKpkH19at31aadfmVk9whttp://mp.weixin.qq.com/s/mZ-eht0bDwffdGQ_HXr0Ag 19、什么是活锁、饥饿、无锁、死锁？ 参考：http://mp.weixin.qq.com/s/_z4yNYunaunqSDjktKU7EQ 20、什么是原子性、可见性、有序性？ 参考：http://mp.weixin.qq.com/s/DWaxnysIQ8NSWN1NME_HvA 21、什么是守护线程？有什么用？ 参考：http://mp.weixin.qq.com/s/Tb0_mdWN46bAdeRlbBQO1w 22、一个线程运行时发生异常会怎样？ 如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。 23、线程yield()方法有什么用？ Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。 24、什么是重入锁？ 所谓重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的。 25、Synchronized有哪几种用法？ 锁类、锁方法、锁代码块。 26、Fork/Join框架是干什么的？ 大任务自动分散小任务，并发执行，合并小任务结果。参考：http://mp.weixin.qq.com/s/YQa2_daDZbJsTxrqv45-QQ 27、线程数过多会造成什么异常？ 线程过多会造成栈溢出，也有可能会造成堆异常。 28、说说线程安全的和不安全的集合。 参考：http://mp.weixin.qq.com/s/5Y5_6qn2g6kIVmQia_0R6g 29、什么是CAS算法？在多线程中有哪些应用。 CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。 java.util.concurrent.atomic包下面的Atom****类都有CAS算法的应用。 参考：http://mp.weixin.qq.com/s/HOAvNG6UcTdpb0mhPSTakg 30、怎么检测一个线程是否拥有锁？ java.lang.Thread#holdsLock方法 31、Jdk中排查多线程问题用什么命令？ jstack 32、线程同步需要注意什么？ 1、尽量缩小同步的范围，增加系统吞吐量。2、分布式同步锁无意义，要使用分布式锁。3、防止死锁，注意加锁顺序。 33、线程wait()方法使用有什么前提？ 要在同步块中使用。 34、Fork/Join框架使用有哪些要注意的地方？ 如果任务拆解的很深，系统内的线程数量堆积，导致系统性能性能严重下降；如果函数的调用栈很深，会导致栈内存溢出； 35、线程之间如何传递数据？ 通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的 36、保证”可见性”有哪几种方式？ synchronized和viotatile 37、说几个常用的Lock接口实现锁。 ReentrantLock、ReadWriteLock 38、ThreadLocal是什么？有什么应用场景？ ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 用来解决数据库连接、Session管理等。 参考：http://mp.weixin.qq.com/s/V9w7rZP0138Kg3C9mBFfeg 39、ReadWriteLock有什么用？ ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。 40、FutureTask是什么？ FutureTask表示一个异步运算的任务，FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。 41、怎么唤醒一个阻塞的线程？ 如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。 42、不可变对象对多线程有什么帮助？ 不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。 43、多线程上下文切换是什么意思？ 多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。 44、Java中用到了什么线程调度算法？ 抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。 45、Thread.sleep(0)的作用是什么？ 由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。 46、Java内存模型是什么，哪些区域是线程共享的，哪些是不共享的？ 参考：http://mp.weixin.qq.com/s/4uXp1n1nlSLuOSPo2Us8mQ 47、什么是乐观锁和悲观锁？ 乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。 悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。 48、Hashtable的size()方法为什么要做同步？ 同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性 CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成机器码执行的，机器码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句”return count”假设被翻译成了三句汇编语句执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。 49、同步方法和同步块，哪种更好？ 同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。 50、什么是自旋锁？ 自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时才能进入临界区。 51、Runnable和Thread用哪个好？ Java不支持类的多重继承，但允许你实现多个接口。所以如果你要继承其他类，也为了减少类之间的耦合性，Runnable会更好。 52、Java中notify和notifyAll有什么区别？ notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。 53、为什么wait/notify/notifyAll这些方法不在thread类里面？ 这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。 54、为什么wait和notify方法要在同步块中调用？ 主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。 55、为什么你应该在循环中检查等待条件？ 处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因，你可以在Eclipse中创建模板调用wait和notify试一试。 56、Java中堆和栈有什么不同？ 每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。 57、你如何在Java中获取线程堆栈？ 对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。 58、如何创建线程安全的单例模式？参考：http://mp.weixin.qq.com/s/iOvBuv2yFb8Jyw_6WRWpsA 59、什么是阻塞式方法？ 阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。 60、提交任务时线程池队列已满会时发会生什么？ 当线程数小于最大线程池数maximumPoolSize时就会创建新线程来处理，而线程数大于等于最大线程池数maximumPoolSize时就会执行拒绝策略。","link":"/2019/08/02/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"title":"基于 GitHub 的敏捷学习方法之道与术","text":"基于 GitHub 的敏捷学习方法之道与术 「持续行动，持续反思，持续进步。」—— via. 敏捷学习宣言 需要好多年才能懂得，最好不是去震惊世界，而是要像易卜生所说的，生活在世界上。 我们都一样，渴望着建树功勋、改变世界，可是伴随着年岁的增长，却发现想要实现的梦想依然那么遥远，而时间却依然残酷得流逝着，不会仅仅因为「你」而发生丝毫的改变。如《奇特的一生》当中所言，我对时间始终充满着敬畏之心，最好的方式也不过是奢求时间能够跟自己做朋友，伴随着我这也许注定朴实无华的一生，共同成长。 在我们的一生所能做的事情里边儿，睡眠占去 1/3，此生只剩 2/3，除去非做不可的 基本生活维护成本 过后，剩下的时间要么选择浪费而荒度此生，要么选择目标而奋力向前，让这一生不留遗憾。Follow your heart，你需要找到一些愿意为其付诸终身的「目标」，以这样的姿态「生活在这世界上」。 敏捷与个人成长就像软件开发一样，一个人的成长也应该要有自己的方法论。人的一生若是顺风顺水一成不变的话，那未免太无趣了，正是由于世界的未知在等着我们去探索，不一样的经历才会让人感到惊喜和有趣。想做的事情永远都不会嫌多，就像柳比歇夫最开始是研究生物学的，却在科学的道路上越走越远，进而研究起了数学、物理、哲学，甚至于美学，而更关键的是，他在每一方面都做出了很大贡献并且留下了诸多著作。 时间充当着 Product Owner 的角色在不断着向你提出各种各样的需求，敏捷当中最重要的一大前提就是「拥抱变化」，而在「 记录时间这件小事儿 」里面我提到的 GTD 流程便可以用于处理这源源不断的需求，即收集、整理、执行、回顾，对应到敏捷当中的几大会议显然也可以由个人完成，自己就是自己的 IM &amp; PM，当然也是 BA &amp; Dev &amp; QA。（当然不用担心人格分裂，😂） 实践之术 我都没想到写着写着怎么就把开头写成了鸡汤文，捂脸。但是咧，如果说前面的讲的是「道」，那么接下来就会具体到基于 GitHub 的「术」，即各种实践。 首先呢，让我们从需求出发，从市面上来寻找一款符合敏捷的学习软件，别想了，当然是没有的。对于一名程序猿来说， 最理想的答案其实就是 GitHub ，作为全球最大的程序猿交友网站，GitHub 本身以及围绕 GitHub 的各种插件使得其项目管理能力其实远比你所能想象的厉害得多。 收集：需求无时无刻，无处不在，anywhere anytime 整理：as BA 即分析，Elaboration &amp; Estimation &amp; IPM =&gt; 确定 MVP &amp; Efforts 执行：as Dev &amp; QA，Developing &amp; Testing &amp; Review/Sign-Off 回顾：Retrospection，Introspection，持续反思，持续进步…通过 GitHub Issues 收集需求 首先你可以给自己建一个 GitHub 仓库作为主页，比如我的 JimmyLv/jimmylv.github.io: Agile Learning based on GitHub issues 其实最开始就是从 个人博客 的主仓库发展而来。那么，如何快速得收纳自己的想法呢？以解决问题为导向，当然就是有什么需求就直接给自己的 repo 建一个 issue 作为 Story Card，然后了却这个需求的最终形态就是 close 掉这个 Issue，比如我要写这篇文章就始于这个 issue： 基于 GitHub 的敏捷学习方法总结 · Issue #36 · JimmyLv/jimmylv.github.io 。 GitHub issues 的进阶用法 与此同时，新建 issue 还有更高级的用法，也就是通过 ISSUE_TEMPLATE 这样一个模板来新建某个 issue，从而更快地定位问题所在和解析自己的想法，最主要的是能够输出更具体的 TODOs，即下一步行动的具体内容，这个还会在后面详细解释的。 issue 和 issue 之间是可以通过 # 相互连接的，甚至可以跨仓库，被 reference 的 issue 也会出现在另外一边的 issue 里面； 而通过 #! 符号是可以在 comments 里面直接新建一个 issue 的，这在思维爆炸的时候来得特别爽快； 你还可以随意艾特你的小伙伴们 @linesh-simplicity @Yaowenjie ，互相监督、互相学习或者给出 Constructive Feedback 之类的，😂； 更甚至于，若是在 Intellij 里面关联了 GitHub，就可以在 git commit 信息里面直接看到你所要关联的 issues 列表了。这种方式仿佛学习中的大脑，神经网络被连通了的感觉。 移动端的解决方案 而在移动端则可以通过 GitDo 这个 App 来轻松新建和管理自己的 Issues，没错，就是有人把 GitHub issues 做成了一个 Todos 类 App，还做得很漂亮功能很完善。只可惜不知道这软件最近为啥被下架了，伤感，我就又重新把滴答清单（TickTick）作为自己的万能收集箱了，之后再把比较重要的、需要进一步追踪的事项添加到 GitHub issues 里面来。 整理你的 GitHub Issues大胆地把 issues 作为你的个人需求列表吧，需要解决的问题可以大到做一个开源项目，或者小到读一本书、写一篇文章。对于比较大的需求，你还可以将其转化为 Epic 然后把拆分过后的小 issues 们加入到这个列表里面来。 而 GitHub (with ZenHub ) 强大的 issues 管理能力绝对会让你的迭代工作变得井井有条，使用 GitHub 新出的 Projects 特性或者使用 ZenHub 的 Boards 应该就可以让你瞬间有了日常敏捷工作的感觉了吧！ 计划与执行具体任务制定迭代计划 首先呢，让我们来新建一个 Milestone 来制定计划，也就是决定在一个 Iteration 里面你需要完成哪些 issues。在这里我所制定的阶段性计划周期为一个月，当然你也可以勤快一点以 2 周作为一个 Iteration，享受一下自己的计划要完不成了这个 Milestone 就要废了，没法向「时间」这个一生的朋友交付所有需求的快感吧，🙂 当然咯，一般我会在月初做计划的时候给自己准备专门的时间来做 Elaboration，把 Backlog 里面的卡拖到 Rethink/Plan 这一列，然后经过分析和详细输出 TODOs 以及所对应的估点 points 之后便可以将其拖到 Ready For Todo 了，一般我给自己估的点数就是完成这件事情所需要的时间，一小时即对应一个 point。 这样你就可以愉快得选择 Filter Issues by Milestone 专注于当前 Iteration，专注于 In Progress 这一列所要做的事情，并且垂涎于 Ready For Todo 里面将要做的事情，每次做完还可以放到 Review/SignOff 里面写写对这件事情的总结和感想什么的，每次挪卡都充满了敏捷的仪式感（认真脸）。 进度的把控 GitHub 在 issues 里面直接集成了 Markdown 的 TODO 语法，甚至于可以在渲染过后直接拖动某个 item 进行排序，而且前面的勾选项可以直接打勾 ☑️ 标记为完成，而且完成之后这个 issue 还能直接显示完成进度；前面所提到的 Epic 也能直接显示子 issues 的完成情况即 closed 比例，两者结合起来简直不能再美好，😂 比如说拿来作为读书列表的记录就很不错，每本书作为一个 issue 还可以把章节划分为具体的 TODOs，结合估点可以追踪自己看书的进度和速度，顺便在 comments 底下做个笔记也不错啊！ 专注当下 而且 ZenHub 还提供了一个基于 GitHub Issues 的 Todo List，你可以只用关注 Today 这一个列表，专心于当前要完成的任务。而且更有趣的是这个 list 可以加入 GitHub 的任何 issues，也就是说是全局的，所以你就可以加入很多在 GitHub 上通过 issues 写的 blog，比如徐飞的这篇文章 流动的数据——使用 RxJS 构造复杂单页应用的数据逻辑 · Issue #38 · xufei/blog ，被我加入到了 Reading 的列表当中。 与此同时我还会使用 Toggl 来记录每个 issue 具体实施的时间，以便于在时间花费上能够获得及时的反馈。这样做会让你真切地感受到时间的流逝，而在回顾记录的时候也能够进行总结分析，从而在下一次的计划当中能够更精确地预估时间（点数）。比方说这篇文章我估了 5 个点现在已经写了 4.5 hours 了，不过这是另外一个大话题，可以参考 记录时间这件小事儿 这个 issue。 迭代回顾与总结分析ZenHub 也提供了 Burndown 和 Velocity tracking 图，可以得出这个迭代总体的完成情况，看看跟预期有何不同；也可以跟其他迭代进行对比，看看有何不同的地方，然后进行下一步的具体分析。 还可以根据 GitHub 和 Toggl 里面的数据进行汇总和分析，下面这个表格就是我在 11 月这个迭代完成后一部分 issues 的具体 Estimation Points 和 Time Efforts，再结合 issues 里面所记录下的各种笔记和 references，就可以有一个比较直观的总结和复盘了。 NUMBER &amp; DESCRIPTIONESTIMATION POINTSTIME EFFORTS #85 记录时间这件小事儿304:26:18 #96 如何对时间进行分类？803:00:09 #102 建立个人 Wiki 系统202:53:56 #101 技术雷达宣讲：enzyme 测试框架506:11:19 #90 Working time improvement133:27 min #97 如何使用 XX 的标签系统？125:21 min其他辅助工具 看板：as Jira/ Trello ，可视化当前进度 =&gt; GitHub Issues group by @Projects / 日历 in @滴答清单；如果你不想用 ZenHub 可以试试 Gitlo 可以在 GitHub issues 和 Trello 之间进行双向同步。 晨间日记 / 每日回顾：as Stand-Up，只用关注 Timeline/Done/Todo/Blocker 以及当天的心情 / 天气等等，使用 @ 格志日记 的一个特点就是可以通过问答的方式对一天进行回顾。 时间记录：@ 时间块 的优点在于记录非常得简单、快捷，用户评论最省时间的时间记录工具没有之一，推荐新手可以试试。但由于个人需要更加详细的记录细节和报告分析，以及多平台（包括 Chrome Extension）的支持，从而选择了 @ Toggl 。 白噪声：作为一款时间记录工具，@ Toggl 本身就支持 Pomodoro 的 25 分钟提示，而作为专注力辅助的白噪声软件我在手机上用的 @ 潮汐 ，电脑上则选择了 @ Noizio 。后话 也许你很喜欢这个解决方案但又不太想公开自己的 issues 列表，那可以试试 GitHub 的 private repo（需要付费），免费的可以试试 GitLab，支持从 GitHub 一键导入，并且已经原生支持了 pipeline 和 kanban 功能。当然咯，不限于工具或软件，这一套方法论其实是可以运用在任何地方的，甚至于我们可以来做一个结合敏捷方法论的个人学习管理软件也不错嘛！ 但是于我而言，选择在 GitHub 这样一个公开环境下记录学习的最大一个动机就在于「开源」，很喜欢一句话，大意是「 在这个互联网时代，能限制住学习的只有你的求知欲 」。当你从互联网这个广阔的知识海洋当中汲取知识的时候，也应当有所输出到即反哺到整个互联网当中去。我会经常写博客 / 笔记来总结分享自己的所学，但是一篇文章诞生的背后往往还有很多其他知识和经验的相互交融与沉淀。 Issues · JimmyLv/jimmylv.github.io 这个列表里面的某个 issues 最终能否演变成一篇文章我不知道，但是基于 GitHub 开放式的学习历程都会被这些 issues 如实地记录着，任何一个想法都能追本溯源被找出最开始的缘由。 相比于软件开发这件小事儿，健康快乐地成长显然要重要得多。—— 立青 基于 GitHub 的敏捷学习方法之道与术","link":"/2019/08/02/%E5%9F%BA%E4%BA%8E%20GitHub%20%E7%9A%84%E6%95%8F%E6%8D%B7%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E4%B9%8B%E9%81%93%E4%B8%8E%E6%9C%AF/"},{"title":"大型分布式架构设计","text":"大型分布式架构设计需求分析初级架构设计系统容量预估 架构优化业务垂直拆分应用集群部署 （分布式 RPC进行远程通信 集群 负载均衡）多级缓存单点登录数据库集群（读写分离，分库分表）服务化消息队列还有CDN、反向代理、分布式文件系统、大数据处理等系统","link":"/2019/08/02/%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"},{"title":"图书资源","text":"图书资源Kindle 电子书下载不用愁，一页精品解您忧。网上流传着很多 Kindle 电子书资源网站汇总，但是有很多都是以讹传讹，相当多的网站要么打不开，要么质量无法保证，为了解决这个问题，「书伴」（原“Kindle 伴侣”）在本页集合了一些精选的、更新频率高、质量好的 Kindle 电子书下载类网址资源，都提供 Kindle 电子书免费下载，且包含各种格式如 azw3、epub、mobi 电子书下载。它们有的是论坛如 Kindle 114、Kindle人，有的是专门的资源站，都可以免费地获取自己感兴趣的 Kindle 电子书。如果您也有好的资源推荐敬请在本页面留言分享给众多小伙伴。本列表不定期验证更新，发现错误请留言。 目录 一、精选免费 Kindle 电子书资源（中文）二、精选免费 Kindle 电子书资源（英文）三、中亚 Kindle 商店电子书资源导航四、精选 Kindle 报刊杂志资源五、精选 Kindle 订阅 RSS 地址资源六、精选 PDF 格式高清扫描版古籍善本 以下是各类电子书资源，如没有找到您所需要的电子书，也可尝试书伴推送服务的“ 凑钱买书 ”功能。 一、精选免费 Kindle 电子书资源（中文）下面列表中的电子图书资源大部分都适用于 6 寸 Kindle 产品，如 MOBI、EPUB 以及 6 寸PDF 格式，有的可以直接推送，有的需要下载到本地自己推送，因为拷贝到 Kindle 中或推送到云端个人文档的电子书只支持 MOBI 等有限的几种格式，所以如果你下载到的是 EPUB 等不支持的格式，可以按照教程《 Calibre使用教程之转换电子书格式 》自行转换一下即可。 亚马逊提供上万本免费电子书，包括免费中文电子书和免费外文电子书。这些免费电子书大多属于经典的公版图书，当然也有少量比较新的图书。非常好的资源，可以善加利用。 「书伴」推出的图书系列推荐，精选不同主题的好书，不定时更新。 以网友分享的 ePub 格式电子书为主，可使用 KindleGen 将其转换成适合 Kindle 的 mobi 格式。 网友分享的电子书。一般为网盘共享的方式。 资源较少，需注册账号并设置推送邮箱后推送，无法直接下载。 大多是网友上传的电子书，有各种格式供选择，有下载次数限制。 可直接下载，多格式，图书有简介。 GitBook 是一个开源出书平台，从很多方面都与 GitHub 类似的网络出版平台，作者可以方便利用各种数字工具在上面撰写书籍的章节，然而整理成册，再形成电子书，进行出版。 高清kindle格式漫画下载，支持推送漫画到kindle设备。24 小时内，邮箱未验证最多可推送 5 本，验证后最多 30 本。 可免费下载 MOBI 或 EPUB 格式电子图书。 提供 ePub3 和 mobi 格式下载。 这是一个在线电子书阅读网站，如果想要放到 Kindle 中阅读需要手动提取页面制作。 台湾华文电子书库（Taiwan eBook）启用上线，电子书 12178 册、政府出版品 595 册、百人千书 1005 册，免费开放读者在线阅览。 二、精选免费 Kindle 电子书资源网址（英文） 免费提供 MOBI、EPUB 等格式的电子书下载。古登堡计划是世界上第一个数字图书馆，提供大量版权过期而进入公有领域的书籍（公版书）。 这里 也提供一些中文版公版书下载。 阿德莱德大学\b电子书图书馆。可按作者、书名、主题、添加时间检索，也可通过关键词搜索。提供在线阅读，也提供 EPUB、MOBI 等格式下载。注意下载某一本书的时候要点击底部的“Kindle”才能下载适用于 Kindle 阅读的 MOBI 格式文件。 提供免费的科幻、奇幻类书籍。提供在线阅读，也提供多格式下载，如HTML、MOBI、EPUB、RTF、SONY 电子书格式、微软阅读器格式等。 免费电子书库，超过 20,000 本免费电子书，提供 MOBI、EPUB、PDF 等格式电子书。 提供高质量 EPUB 格式和适用于 Kindle 的 MOBI 格式公版电子书，其中有许多办好插图和脚注。下载电子书前必须使用邮箱注册并激活账号。 免费的女性作家电子书，提供适合 Kindle 阅读的 PRC 格式，以及 EPUB、PDF、微软阅读器、PDB和纯文本格式。 MobileRead 论坛的无版权 MOBI 格式电子书上传区，无需注册可直接下载。 MobileRead 论坛的无版权 EPUB 格式电子书上传区，无需注册可直接下载。 最新出版的计算机技术类电子书，大部分来自 O’Reilly 出版社。提供 Mobi、PDF、Epub 格式下载。 英文电子书下载站点。有 epub、mobi、pdf 格式，但并不是每本书每种格式都包含。 英文电子书下载站点。有 epub、mobi、pdf 格式，但并不是每本书每种格式都包含。 英文原版书 23G 一万多本。资源较老，没有近几年新出的书，包括流行小说、文学名著和各类畅销书。二十个文件是二十个分卷，必须全下载下来放在一个盘里才能解压。一个作者一个文件夹。 三、中亚 Kindle 商店电子书资源导航四、精选 Kindle 报刊杂志资源 经济学人、时代周刊、纽约客、大西洋月刊 MOBI 格式电子杂志订阅，定期推送到指定邮箱。 《读者》為中国发行量最大的杂志之一，双月刊，由甘肃人民出版社出版发行。《读者》属于文摘类杂志，自身只发表少量原创内容，大多数文章通过摘取其他报刊杂志并支付稿酬来发表。 英国《卫报》是英国著名的综合性报刊，发表“世界领先的自由派声音”。近年来，《卫报》开始扩展其数字业务，《卫报》官方网站的新闻涵盖时政、体育、娱乐、财经、科技等方面。 《新语丝》月刊是一份由方舟子等海外中国学人在 1994 年 2 月创办的一份电子文化性综合刊，名称源自中国新文化运动时期由鲁迅、周作人、钱玄同、林语堂等人在北京创办的同人刊物《语丝》。 五、精选 Kindle 订阅 RSS 地址资源Kindle 除了可以用来看电子书外，还能变身电子报纸哦。您可以把自己喜欢的新闻、博客甚至微信号的 RSS 源集结成一本电子书，设置每天或几天推送一次，这样就可以集中阅读这些新鲜资讯，不仅可以节省时间还能提高阅读效率。实现这种功能也很简单，可以选择使用开源软件 KindleEar、RedKindle 架设私有推送服务器，也可以选择现成类似的免费（如 zhred.net ）或收费服务。 以下是「书伴」为小伙伴们精选的 RSS 地址源，他们共同的的特点是远离娱乐，提供严肃的内容，每一篇都值得花费时间阅读，而不像国内那些喜欢把那哗众取宠的娱乐新闻，或者明显违反常识的伟光正掺杂其中。资讯阅读其实也可以如此安静。如果您有好的 RSS 源也欢迎留言推荐。 1RSS地址：http://www.bbc.com/zhongwen/simp/index.xml 英国广播公司（英语：British Broadcasting Corporation，缩写：BBC；又常译名为英国国家广播公司以强调其公营地位），是英国的一家资金主要来自英国国民缴纳的电视牌照费且独立运作的公共媒体，也是世界最大的公共广播公司，长久以来一直被认为是全球最受尊敬的媒体。 1RSS地址：http://cn.nytimes.com/rss.html 《纽约时报》（英语：The New York Times，缩写NYT）是一份在美国纽约出版的日报，在全世界发行，有相当的影响力。它是美国严肃报刊的代表。由于风格古典严肃，它有时也被戏称为“灰色女士”（The Gray Lady）。 1RSS地址：http://songshuhui.net/feed 科学松鼠会的成员自称松鼠，他们遍布全球，大多数具有理工科背景，站长嵇晓华拥有复旦大学颁发的神经生物学博士学位。他们希望科学松鼠会能够成为“国内最好的科学博客”。 1RSS地址：http://pansci.tw/feed PanSci 泛科学网由台湾数位文化协会 (ADCT) 成立，邀请台湾科学研究者、教育者、爱好者、以及所有受科学影响的人们，共同畅谈科学、将高深庞杂的科学发展重新放置回台湾公共论坛中，并且用理性思考社会议题中的科学面向。 1RSS地址：http://feeds.feedburner.com/yeeyanselect 译言是由一群志愿翻译者于2006年成立的翻译社区网站，原主要是将国际新闻如卫报及ReadWriteWeb的来源内容翻译成中文为主，并以社群内部的荣誉制度来鼓励参与。 1RSS地址：http://www.nbweekly.com/rss.xml 中国新锐城市杂志。中国唯一一份以城市为关注对象的新闻杂志。新锐的观点、故事文本的新闻呈现形式契合城市中坚的阅读习惯与精神气质，是城市高端人群的品质读物。 1RSS地址：http://feeds.feedburner.com/letscorp/aDmw 网络热门话题追踪，新闻资讯紧跟时事热点。 1RSS地址：http://www.dushumashang.com/feed 一个能解决认真阅读严肃内容的方案。 1RSS地址：http://feeds.feedburner.com/solidot Solidot 是 ZDNet 中国旗下的科技资讯网站,主要面对开源自由软件和关心科技资讯读者群,包括众多中国开源软件的开发者,爱好者和布道者。口号是“奇客的资讯,重要的东西”。 1RSS地址：http://cn.engadget.com/rss.xml Engadget 是一个关于消费电子产品的流行科技网志与播客。该网志曾赢得数个奖项。现时 Engadget 拥有九个不同网站，全都以各自的员工同时地运作，以各自的语言覆盖全球不同地方的科技新闻。本源为 Engadget 中国版，原名“瘾科技”已弃用。 六、精选 PDF 格式高清扫描版古籍善本 书格（Shug.org）是一个自由开放的在线古籍图书馆。致力于开放式分享、介绍、推荐有价值的古籍善本，并鼓励将文化艺术作品数字化归档。提供 PDF 格式高清彩色古籍扫描图书，质量上乘（请注意可能不适合六吋 Kindle 阅读）。 早稻田大学图书馆对外提供其馆藏的约 30 万册的部分古籍影像资料，日本古籍居多，也有大量中国古籍的扫描版本可供下载，是不可多得的珍贵资料。。 图书资源","link":"/2019/08/02/%E5%9B%BE%E4%B9%A6%E8%B5%84%E6%BA%90/"},{"title":"如何免费的让网站启用HTTPS","text":"如何免费的让网站启用HTTPS今天，我把CoolShell变成https的安全访问了。我承认这件事有点晚了，因为之前的HTTP的问题也有网友告诉我，被国内的电信运营商在访问我的网站时加入了一些弹窗广告。另外，HTTP的网站在搜索引擎中的rank会更低。所以，这事早就应该干了。现在用HTTP访问CoolShell会被得到一个 301 的HTTPS的跳转。下面我分享一下启用HTTPS的过程。 我用的是 Let’s Encrypt 这个免费的解决方案。Let’s Encrypt 是一个于2015年推出的数字证书认证机构，将通过旨在消除当前手动创建和安装证书的复杂过程的自动化流程，为安全网站提供免费的SSL/TLS证书。这是由 互联网安全研究小组 （ISRG – Internet Security Research Group，一个公益组织）提供的服务。主要赞助商包括 电子前哨基金会 ， Mozilla基金会 ， Akamai 以及Cisco等公司（ 赞助商列表 ）。 2015年6月，Let’s Encrypt得到了一个存储在硬件安全模块中的离线的RSA根证书。这个由IdenTrust证书签发机构交叉签名的根证书被用于签署两个证书。其中一个就是用于签发请求的证书，另一个则是保存在本地的证书，这个证书用于在上一个证书出问题时作备份证书之用。因为IdenTrust的CA根证书目前已被预置于主流浏览器中，所以Let’s Encrypt签发的证书可以从项目开始就被识别并接受，甚至当用户的浏览器中没有信任ISRG的根证书时也可以。 以上介绍文字来自 Wikipedia 的 Let’s Encrypt 词条 。 为你的网站来安装一个证书十分简单，只需要使用电子子前哨基金会EFF的 Certbot ，就可以完成。 1）首先，打开 https://certbot.eff.org 网页。 2）在那个机器上图标下面，你需要选择一下你用的 Web 接入软件 和你的 操作系统。比如，我选的， nginx 和 Ubuntu 14.04 3）然后就会跳转到一个安装教程网页。你就照着做一遍就好了。 以Coolshell.cn为例 – Nginx + Ubuntu 首先先安装相应的环境： 1$ sudo apt-get update $ sudo apt-get install software-properties-common $ sudo add-apt-repository ppa:certbot/certbot $ sudo apt-get update $ sudo apt-get install python-certbot-nginx 然后，运行如下命令： 1$ sudo certbot --nginx certbot 会自动检查到你的 nginx.conf 下的配置，把你所有的虚拟站点都列出来，然后让你选择需要开启 https 的站点。你就简单的输入列表编号（用空格分开），然后，certbot 就帮你下载证书并更新 nginx.conf 了。 你打开你的 nginx.conf 文件 ，你可以发现你的文件中的 server 配置中可能被做了如下的修改： 1listen 443 ssl; # managed by Certbot ssl_certificate /etc/letsencrypt/live/coolshell.cn/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/coolshell.cn/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot 和 1# Redirect non-https traffic to https if ($scheme != &quot;https&quot;) { return 301 https://$host$request_uri; } # managed by Certbot 这里建议配置 http2，这要求 Nginx 版本要大于 1.9.5。HTTP2 具有更快的 HTTPS 传输性能，非常值得开启（ 关于性能你可以看一下这篇文章 ）。需要开启HTTP/2其实很简单，只需要在 nginx.conf 的 listen 443 ssl; 后面加上 http2 就好了。如下所示： 1listen 443 ssl http2; # managed by Certbot ssl_certificate /etc/letsencrypt/live/coolshell.cn/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/coolshell.cn/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot 然后，就 nginx -s reload 就好了。 但是， Let’s Encrypt 的证书90天就过期了 ，所以，你还要设置上自动化的更新脚本，最容易的莫过于使用 crontab 了。使用 crontab -e 命令加入如下的定时作业（每个月都强制更新一下）： 10 0 1 * * /usr/bin/certbot renew --force-renewal 5 0 1 * * /usr/sbin/service nginx restart 当然，你也可以每天凌晨1点检查一下： 10 1 * * * certbot renew 注：crontab 中有六个字段，其含义如下： 第1个字段：分钟 (0-59) 第2个字段：小时 (0-23) 第3个字段：日期 (1-31) 第4个字段：月份 (1-12 [12 代表 December]) 第5个字段：一周当中的某天 (0-7 [7 或 0 代表星期天]) /path/to/command – 计划执行的脚本或命令的名称 这么方便的同时，我不禁要问，如果是一些恶意的钓鱼网站也让自己的站点变成https的，这个对于一般用来说就有点难以防范了。哎……* 当然，在nginx或apache上启用HTTPS后，还没有结束。因为你可能还需要修改一下你的网站，不然你的网站在浏览时会出现各种问题。 启用HTTPS后，你的网页中的所有的使用 http:// 的方式的地方都要改成 https:// 不然你的图片，js， css等非https的连接都会导致浏览器抱怨不安全而被block掉 。所以，你还需要修改你的网页中那些 hard code http:// 的地方。 对于我这个使用wordpress的博客系统来说，有这么几个部分需要做修改。 1）首先是 wordpress的 常规设置中的 “ WordPress 地址 ” 和 “ 站点地址 ” 需要变更为 https 的方式。 2）然后是文章内的图片等资源的链接需要变更为 https 的方式。对此，你可以使用一个叫 “ Search Regex ” 插件来批量更新你历史文章里的图片或别的资源的链接。比如：把 http://coolshell.cn 替换成了 https://coolshell.cn 3）如果你像我一样启用了文章缓存（我用的是 WP-SuperCache 插件），你还要去设置一下 “ CDN ” 页面中的 “Site URL” 和 “off-site URL” 确保生成出来的静态网页内是用https做资源链接的。 基本上就是这些事。希望大家都来把自己的网站更新成 https 的。 嗯，12306，你什么时候按照这个教程做一下你的证书？ （全文完） 如何免费的让网站启用HTTPS","link":"/2019/08/02/%E5%A6%82%E4%BD%95%E5%85%8D%E8%B4%B9%E7%9A%84%E8%AE%A9%E7%BD%91%E7%AB%99%E5%90%AF%E7%94%A8HTTPS/"},{"title":"如何快速全面建立自己的大数据知识体系？","text":"如何快速全面建立自己的大数据知识体系？摘要：很多人都看过不同类型的书，也接触过很多有关大数据方面的文章，但都是很零散不成系统，对自己也没有起到多大的作用，所以作者第一时间，带大家从整体体系思路上，了解大数据产品设计架构和技术策略。 作者经过研发多个 大数据 产品，将自己形成关于大数据知识体系的干货分享出来，希望给大家能够快速建立起大数据产品的体系思路，让大家系统性学习和了解有关大数据的设计架构。 很多人都看过不同类型的书，也接触过很多有关大数据方面的文章，但都是很零散不成系统，对自己也没有起到多大的作用，所以作者第一时间，带大家从整体体系思路上，了解大数据产品设计架构和技术策略。 大数据产品，从系统性和体系思路上来做，主要分为五步： 针对前端不同渠道进行数据埋点，然后根据不同渠道的采集多维数据，也就是做大数据的第一步，没有全量数据，何谈大数据分析； 第二步，基于采集回来的多维度数据，采用ETL对其各类数据进行结构化处理及加载； 然后第三步，对于ETL处理后的标准化结构数据，建立数据存储管理子系统，归集到底层数据仓库，这一步很关键，基于数据仓库，对其内部数据分解成基础的同类数据集市； 然后基于归集分解的不同数据集市，利用各类R函数包对其数据集进行数据建模和各类算法设计，里面算法是需要自己设计，个别算法可以用R函数，这个过程产品和运营参与最多；这一步做好了，也是很多公司用户画像系统的底层。 最后根据建立的各类数据模型及算法，结合前端不同渠道不同业务特征，根据渠道触点自动匹配后端模型自动展现用户个性化产品和服务。 建立系统性数据采集指标体系 建立数据采集分析指标体系是形成营销数据集市的基础，也是营销数据集市覆盖用户行为数据广度和深度的前提，数据采集分析体系要包含用户全活动行为触点数据，用户结构化相关数据及非结构化相关数据，根据数据分析指标体系才能归类汇总形成筛选用户条件的属性和属性值，也是发现新的营销事件的基础。 构建营销数据指标分析模型，完善升级数据指标采集，依托用户全流程行为触点，建立用户行为消费特征和个体属性，从用户行为分析、商业经营数据分析、营销数据分析三个维度，形成用户行为特征分析模型。用户维度数据指标是不同维度分析要素与用户全生命周期轨迹各触点的二维交叉得出。 目前做大数据平台的公司，大多数采集的数据指标和输出的可视化报表，都存在几个关键问题： 采集的数据都是以渠道、日期、地区统计，无法定位到具体每个用户； 计算统计出的数据都是规模数据，针对规模数据进行挖掘分析，无法支持； 数据无法支撑系统做用户获客、留存、营销推送使用。所以，要使系统采集的数据指标能够支持平台前端的个性化行为分析，必须围绕用户为主线来进行画像设计，在初期可视化报表成果基础上，将统计出来的不同规模数据，细分定位到每个用户，使每个数据都有一个用户归属。 将分散无序的统计数据，在依据用户来衔接起来，在现有产品界面上，每个统计数据都增加一个标签，点击标签，可以展示对应每个用户的行为数据，同时可以链接到其他统计数据页面。 由此可以推导出，以用户为主线来建立数据采集指标维度：用户身份信息、用户社会生活信息、用户资产信息、用户行为偏好信息、用户购物偏好、用户价值、用户反馈、用户忠诚度等多个维度，依据建立的采集数据维度，可以细分到数据指标或数据属性项。 ① 用户身份信息维度 性别，年龄，星座，居住城市，活跃区域，证件信息，学历，收入，健康等。 ② 用户社会生活信息维度 行业，职业，是否有孩子，孩子年龄，车辆，住房性质，通信情况，流量使用情况…… ③ 用户行为偏好信息 是否有网购行为，风险敏感度，价格敏感度，品牌敏感度，收益敏感度，产品偏好，渠道偏好…… ④ 用户购物偏好信息 品类偏好，产品偏好，购物频次，浏览偏好，营销广告喜好，购物时间偏好，单次购物最高金额…… ⑤ 用户反馈信息维度 用户参与的活动，参与的讨论，收藏的产品，购买过的商品，推荐过的产品，评论过的产品…… 基于采集回来的多维度数据，采用ETL对其各类数据进行结构化处理及加载 数据补缺：对空数据、缺失数据进行数据补缺操作，无法处理的做标记。 数据替换：对无效数据进行数据的替换。 格式规范化：将源数据抽取的数据格式转换成为便于进入仓库处理的目标数据格式。 主外键约束：通过建立主外键约束，对非法数据进行数据替换或导出到错误文件重新处理。 数据合并：多用表关联实现（每个字段加索引，保证关联查询的效率） 数据拆分：按一定规则进行数据拆分 行列互换、排序/修改序号、去除重复记录数据处理层 由 Hadoop集群 组成 , Hadoop集群从数据采集源读取业务数据，通过并行计算完成业务数据的处理逻辑，将数据筛选归并形成目标数据。 数据建模、用户画像及特征算法 提取与营销相关的客户、产品、服务数据，采用聚类分析和关联分析方法搭建数据模型，通过用户规则属性配置、规则模板配置、用户画像打标签，形成用户数据规则集，利用规则引擎实现营销推送和条件触发的实时营销推送，同步到前端渠道交互平台来执行营销规则，并将营销执行效果信息实时返回到大数据系统。 根据前端用户不同个性化行为，自动匹配规则并触发推送内容 根据用户全流程活动行为轨迹，分析用户与线上渠道与线下渠道接触的所有行为触点，对营销用户打标签，形成用户行为画像，基于用户画像提炼汇总营销筛选规则属性及属性值，最终形成细分用户群体的条件。每个用户属性对应多个不同属性值，属性值可根据不同活动个性化进行配置，支持用户黑白名单的管理功能。 可以预先配置好基于不同用户身份特性的活动规则和模型，当前端用户来触发配置好的营销事件，数据系统根据匹配度最高的原则来实时自动推送营销规则，并通过实时推送功能来配置推送的活动内容、优惠信息和产品信息等，同时汇总前端反馈回的效果数据，对推送规则和内容进行优化调整。 大数据系统结合客户营销系统在现有用户画像、用户属性打标签、客户和营销规则配置推送、同类型用户特性归集分库模型基础上，未来将逐步扩展机器深度学习功能，通过系统自动搜集分析前端用户实时变化数据，依据建设的机器深度学习函数模型，自动计算匹配用户需求的函数参数和对应规则，营销系统根据计算出的规则模型，实时自动推送高度匹配的营销活动和内容信息。 机器自学习模型算法是未来大数据系统深度学习的核心，通过系统大量采样训练，多次数据验证和参数调整，才能最终确定相对精准的函数因子和参数值，从而可以根据前端用户产生的实时行为数据，系统可自动计算对应的营销规则和推荐模型。 大数据系统在深度自学习外，未来将通过逐步开放合作理念，对接外部第三方平台，扩展客户数据范围和行为触点，尽可能覆盖用户线上线下全生命周期行为轨迹，掌握用户各行为触点数据，扩大客户数据集市和事件库，才能深层次挖掘客户全方位需求，结合机器自学习功能，从根本上提升产品销售能力和客户全方位体验感知。 本文转自作者个人微信号「互联网金融干货」，版权归作者所有。 作者：刘永平 ，11年以上互联网电商、互联网金融项目实操经验，任职高级产品总监，产品运营专家，曾亲自主导参与项目超过15个，10个以上从0到1实操经验。 如何快速全面建立自己的大数据知识体系？","link":"/2019/08/02/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%85%A8%E9%9D%A2%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%EF%BC%9F/"},{"title":"开启 macOS 系统隐藏功能","text":"开启 macOS 系统隐藏功能编注： 「新手问号」是少数派的一个全新栏目。它面向完全「零基础」的新手用户，通过最简单易懂的方式，帮助你快速掌握关于系统和软硬件的入门知识。 栏目文章回顾： Mac 中有一个图标是「黑色的窗口」名为「终端 Terminal」的应用，对于一个普通人用户来说，它就好像有一层神秘的面纱，时常让人觉得只有技术流、程序员才能驾驭。而命令行这种东西似乎也都是存在想象里的，一个人对着空白的窗口噼里啪啦的打下一行代码，然后电脑便自动给你执行相应的任务。其实作为新手的我们一样也可以让它发挥出一定的作用，今天的这一篇文章就带你了解一些你可能也能用到的命令行，让你轻松开启系统的隐藏功能。 配置 Launchpad在大家安装好应用去 Launchpad 里寻找的时候，时常会发现原生的配置让 Launchpad 看的稍许拥挤，但是在系统偏好设置里我们是无法修改的。为了让我们的 Launchpad 识别度更高并且更加美观，可以通过终端对排列方式进行修改，复制以下代码至终端即可： 1defaults write com.apple.dock springboard-columns -int 11; defaults write com.apple.dock springboard-rows -int 10; defaults write com.apple.dock ResetLaunchPad -bool TRUE; killall Dock 命令中有两个数字 8 和 7，它们分别代表的是布局中的列数和行数，如果想更清除的了解该段命令，可以参考《 通过终端命令改变 Launchpad 中应用图标的大小 》。 除了可以对 Launchpad 的布局进行更改，还可以根据自己的喜好对北背景的模糊程度进行更改，复制以下代码至终端即可： 1defaults write com.apple.dock springboard-blur-radius -int 100; killall Dock 命令中有一个数字 100，它代表的背景模糊的程度，你可以在 0 ~ 255 的范围内选择。 修改截图属性Mac 上自带的截图非常的还用，可以区域、窗口、延时截图。但是截图会默认保存在你的桌面上，时间一长，你的桌面就会被五花八门的截图堆满。对此，我们可以新建一个文件夹专门来存放截图，新建一个 screenshots 的文件夹在桌面或者任意一个你希望它待在的地方，将下述代码复制进终端即可： 1defaults write com.apple.screencapture location /Users/DonxYu/Pictures/ScreenShot; killall SystemUIServer ~ 之后填写你相应的文件夹路径即可，如果不清楚路径的写法，可以打开该文件夹右键点击任何一个文件「显示简介」，复制「位置」之后的内容即可，也可以直接将文件夹拖拽至终端以此显示路径。 除此之外，你也可以使用以下命令修改截图保存的类型，例如你想保存 JPG 格式的截图： 1efaults write com.apple.screencapture type jpg &amp;&amp; killall SystemUIServe 显示隐藏文件夹在 Windows 上隐藏文件夹大家应该都是老手了，转到 Mac 后，却发现隐藏文件夹和自己想象有那么一些不一样。为了更好的把大家的「小秘密」藏到内心最深处的地方，也可以使用两段命令来完成操作。跟前文一样，我们需要获取文件夹的路径，然后在终端中输入以下代码： 1chflags hidden ~/Desktop/Hidden 你也可以使用 nohidden 重新让该文件夹显示。如果你要显示全部文件，推荐大家直接使用快捷键「 Shift + Command + . 」即可显示全部隐藏文件。 除此之外，如果你觉得自己桌面太乱了，但是这会又有人来看你的电脑，你可以使用一段命令行将桌面的文件全部隐藏起来，让桌面回归清爽，文件也依旧可以通过 Finder 中的桌面中找到： 1defaults write com.apple.finder CreateDesktop -bool false; killall Finder 如果想重新看到桌面的图标，将 false 替换为 true 输入终端即可。 Dock 栏属性修改Mac 中为了获得更大的可视空间，在不使用 Dock 时我们可以隐藏它。若要查看隐藏的 Dock，可以将指针移到 Dock 所在屏幕的边缘。但是这个显示速度存在了一定的延迟，为了加速这个过程，我们可以使用一段命令行，让你的隐藏 Dock 弹出的时候更加的顺滑流畅： 1defaults write com.apple.Dock autohide-delay -float 0 &amp;&amp; killall Dock 使用后的效果，可以说是非常明显了，再也不会有在「挤牙膏」的感觉。 如果在你的使用下，Dock 栏上摆满了各类 App，却发现这不是自己想要的结果。你可以通过终端来重置你的 Dock 栏，让它回到最开始的状态： 1defaults delete com.apple.dock; killall Dock 让屏幕亮的更久Mac 在运行一段时间后，会自动进入睡眠。如果大家不想 Mac 那么快的进入书面，可以采用一些第三方软件来达到此目的。其实与其下载一个软件占用 Mac 上精贵的储存，不如使用一段命令行就可以解决这些问题了。下方命令行中的 3600 单位是秒，即你希望多长时间内你的 Mac 不会进入睡眠： 应用安装与更新MAS 的连接情况大家也很清楚，时常会因为情绪不稳定导致你无法获得最完美的下载体验，况且还有很多应用并不在商店上架，或是非商店版本有更多的功能。原来的时候，我们需要查找一个又一个的官网，然后下载安装，其实这么多繁琐操作，在终端里可以更快的完成。你只需要输入： 将 App 替换为你需要安装的软件的名字即可。但是使用前，需要你在电脑中安装 Homebrew Cask ，具体可以参考《 再谈 Homebrew Cask 在 macOS 上安装应用的轻松感 》。大多数通过 Cask 安装的软件都自带更新选项，如果没有该选项，用户依旧可以通过终端进行更新，在终端中输入 brew tap buo/cask-upgrade ，然后再输入下段命令即可更新全部应用： 1brew cu 如果你希望安装 MAS 上的应用，也可以绕过原生的商店应用，直接采用终端进行安装。你可以先通过刚才安装的 Homebrew 安装一个我们需要的 mas ，即在终端输入： 1brew install mas 然后，可以在终端中搜索需要的软件，或者直接输入关键字段加上应用的识别码进行安装： 1mas install AppID 友情提示 ⚠️终端操作虽然说很快捷，可能你也觉得很高端。但是，在网络上经常会有人拿终端命令开玩笑，比如前面带有 sudo 或者 rm -rf 类型字段的，一定要谨慎使用。可能就是这一步操作，电脑就会「爆炸」，也希望大家也不要开这一类玩笑，给大家一个美好的环境！ 简单几条命令，轻松开启 macOS 系统隐藏功能 | 新手问号","link":"/2019/08/02/%E5%BC%80%E5%90%AF%20macOS%20%E7%B3%BB%E7%BB%9F%E9%9A%90%E8%97%8F%E5%8A%9F%E8%83%BD/"},{"title":"手机换了新卡后，我换绑了这些账户的手机号","text":"手机换了新卡后，我换绑了这些账户的手机号最近各大运营商推出的流量套餐越来越多，虽说近来老用户办理新套餐的难度有所下降，不过如果自己心仪的套餐频频在别家推出，自己就只能眼巴巴地爬墙头了。当然，忍无可忍的你也可以选择跳槽重新来过。不过在你急不可耐地销掉原号之前，还得记得把一众绑定着手机号码的互联网账号也一起带走，以免日后需要短信验证时的尴尬，也避免账户被号码新主人登陆的危险。笔者尝试了一些常用账号的换绑方式，总结了一下流程，顺便可以一窥各种验证方式的安全性，希望能够帮助到有需要的你。 哪些账号是用手机注册的？当下用手机号注册的互联网账号越来越多，注册时候的确很方便，不过换号的时候就需要一个一个转换账号信息了。在更换注册信息前首先要快速地想起都有哪些账号是使用手机注册的。如果你使用1Password 等密码管理软件，最快的方式就是打开它搜索一下。如果你平时的密码管理就不太规整，大概就要花一点时间仔细想想。当然，你也可以跟着下面的文章内容回忆起自己常用的账号都有哪些。 微信仰仗于国内的社交环境，你大概怎么也不会把微信忘了。微信的验证机制有些特殊，在我的手机上插入新电话卡，并在设置中选择“更换手机号”之后，只要在弹出的页面上输入新手机号，然后填入用新手机号接收的验证码，即可完成更换步骤。此时如果退出账号，靠新号接收短信验证码就可以完成登录。 微信更换绑定步骤 不过微信如何保证被换绑的手机号不是陌生人的呢？为此我和朋友专门做了一个测试：首先在我的微信换绑设置里输入她的号码，填入她收到的验证码，在这一步，绑定账号成功。接下来，使用她的设备再通过手机验证码登录我的微信账号时，我的手机微信上会弹出提示，告诉我有人在登录我的微信账号： 他人登录提醒 同时，她的设备上会显示这是一个新的设备，需要验证身份。选择验证后提供了两种途径：一是使用原设备扫描二维码，二是让至少两位好友向该账号发送一个验证码。 新设备登录验证 至此大概可以看出，微信进行身份识别是基于你的常用设备信息，或者你的通讯录关系。如果你的朋友趁你不备拿着你的手机来一出恶作剧，小心自己的微信号被绑定上TA 的号码哦！ 支付宝作为日常支付手段之一，牵涉财务的支付宝也不要忘记换绑。进入设置中更换手机号码的界面，首先依然在更改电话号码的界面输入新的号码，然后填入收到的验证码，这时支付宝跳出了一个“正在进行智能检测”的页面，检测通过的话无需任何其他认证即可继续换绑。 这时支付宝会将账户退出，你需要使用新号码重新登录（这里默认填入的是旧号码），不过这时已经可以使用新号接收短信验证码登录了。登录过后才会提示换绑完成，然后它会让你再登录一次。 支付宝更换绑定过程 为了验证安全性，我又用朋友的手机做了一次试验。选择更换为她的号码，然后填入她接收到的验证码，接下来的“智能检测”就没有通过，页面跳出了输入 支付密码 的要求。如果把它叉掉，可以看到“验证指纹或支付密码”或“填写银行卡信息”两种验证方式。（所以你家到底什么时候支持Face ID） 更换陌生手机号后出现了身份验证 至此，虽然不知道中间的“智能检测”的算法是怎样的，由于试验过多现在我自己的两个手机号互换也不能通过智能检测了。不过支付宝看起来也保证了我们的账号不会轻易被他人换绑。 淘宝关掉支付宝，我们默默打开了还留存着双十一烧钱余温的淘宝客户端。不过打开之后我们发现淘宝账号绑定的手机已经随着支付宝更改过了。不过如果你是先在淘宝账号中更改的手机号，可以选择如下方式： 首先在设置里找到更改手机这一项之后，输入新手机号，然后在新手机上接收短信验证码。而在接下来的页面中会要求输入支付密码。如果年久不用而忘记了它，还可以选择联系客服。 淘宝验证要求 选择联系客服之后，实际上会进入支付宝的网页登录界面，而登录之后也是在如下问题列表中选择你需要的问题。不过这个答案好像与我们的目的并无联系。选择“向我提问”之后，出现智能机器人，回复关键词”修改手机号“，答案引导我们去支付宝中修改手机号码。不过如果依然执着，我们可以点开温馨提示1 里的“点击查看”，千呼万唤始出来，我们终于看到了人工处理的方式……然后就可以关掉手机打开电脑，去申请人工处理了。另外提醒大家，以上的过程中千万不要点击左上角的返回，否则就会回到最开始，重新来过…… 联系客服处理 我们可以看到，同一个手机绑定的支付宝和淘宝账号是联动的，更换其中之一即可。如果你的“支付密码”和“银行卡信息”两条路都走不通，还可以去支付宝的网页上申请人工处理。 京东淘宝之后，我们来到另一家网购平台。京东的换绑在设置 - 账户安全中，点击”手机验证“后选择原手机能否接收验证码，如果可以输入验证码即可；选择不能接收验证码会进入输入“支付密码”的界面。同样你也可以选择下方的申诉功能。 京东手机端验证 不过即使你的手机不在身边、或是忘记了支付密码，你也可以进入网页版进行更改。京东网页版提供了一个“三选二”的验证方式，你可以在手机验证码、支付密码、银行卡信息之间选择两个，颇有些两步验证的感觉。 京东网页版验证方式 友情提示：上面两个收获地址里的电话别忘了改哦！ 新浪微博微博官方客户端的换绑设置在“账号与安全”里，点进去会发现微博是可以添加多个手机号的，但能作为登录账号的只有一个。添加一个手机号需要原号码的验证码许可。添加副号码会开启登录保护功能，副号码只能在陌生设备登录时接收验证码使用，不可以作为登录用户名。 这里我们选择更换“登录手机”，在下一个界面中点击“获取短信验证码”会向旧号码发送一个验证码，填入这个验证码后就可以继续输入新的手机号以及新号中接收到的验证码了。然后点击确认即可。 微博换绑流程 不过如果你的旧手机不在身边，你可以在第一个获取短信验证码的界面下点击”其他验证方式“。微博会首先请求填入完整的绑定手机号，填写正确就可以继续添加新号码。如果在这个页面再点击“其他验证方式”，会出现通过实名认证验证身份的页面。出于对个人信息安全的考虑，笔者就没有再继续了。还是推荐大家使用短信验证的方式，比较方便快捷。 两种其他验证方式 知乎知乎的普通验证方式包括手机和邮箱验证码两种，接收验证码后即可更改新手机。不过这里提一下知乎的人工申诉，可以说是事无巨细地验证了各种信息，必填与选填一应俱全，最后还要再填一遍接收消息的手机和收到的验证码。这样就更看得出使用验证码的便利性啦。 知乎的人工申诉 百度笔者的百度账号在上大学初换号码时就没有更换，种种原因导致一直拖到先在也没有换绑。由于没有安装百度旗下的App，所以这里使用Mac 上的Safari 登录账号后在账号设置页找到更换手机的位置，会弹出页面要求使用旧手机验证码验证。由于旧手机号不可用，下拉菜单选择申诉，然后百度就会引导我们扫码下载App 进行申诉…… 百度账号申诉流程 下载完App 后，在设置 - 账号管理里可以更改手机，选择“更换手机号”后依然需要旧设备验证码，填入即可换绑。不过我们仍然继续点击申诉并确定，输入联系手机号码，这时App 会要求向指定号码发送一个短信。发送完成后，点击页面上的“我已发送短信，继续下一步”，会弹出提示框“请先获取验证码”。 在手机百度上进行申诉 截止发稿前，笔者还在等待百度获取到验证码…… 视频网站这里以Bilibili、爱奇艺与优酷为例，三家的验证方式都差不多。B 站的身份验证方式有手机和邮箱两种，获得验证码后再填入新号即可。如果两种验证方式都不可用，也可以选择向帮助邮箱发送邮件让客服帮你处理，这里就不调戏Bilibili 娘了。 Bilibili 爱奇艺上可以选择原手机验证码和人工申诉两种，点击人工申诉的话，还是会首先推荐你使用自家App 扫码继续，不过这里却可以点击下面小小的链接进入客服申诉。 爱奇艺 优酷的验证方式只有使用原号码验证码一种，如果原号码已经不可用，大概是要联系客服了商讨解决了，不过本质上还是人工申诉嘛。 优酷 外卖账号由于日常好吃懒做外卖App 在我们生活中也越来越重要，而且里面存放着我们的地址等敏感信息。饿了吗的正常更改途径也是使用原号码的验证码，这里就不再赘述。页面下方有一个小小的“在线申诉”按钮，点击进入，输入新手机号以及接收到的验证码提交审核。 饿了吗 美团App 在进入更换号码的页面之前也有一个安全环境检测的界面。在我这里，连接WiFi 的时候就被判定为环境安全，而使用蜂窝数据的时候就被认为不安全，此时需要输入支付密码，或者可更换为使用短信验证。但我的校园WiFi 又是被iOS 建议为安全性较低的，真是不知道谁说得对。验证后输入新的手机号码并接收验证码换绑就完成了。 美团 其他12306 12306 就像Mac 上避不开的Office，每次看着都不爽却每次都不得不用它。手机端打开App 不能点击任何按钮，于是只能登录网页端。Safari 打开只有无休止地转圈，又不得不使用Chrome。进入账号安全当中的手机核验，原手机号已经列出，这里需要填入新手机号和 登录密码 。点击确认后弹出了一个”手机双向验证“的提示框，实际上就是主动请求一个验证码而已。至此就可以完成了。 12306 工商银行 银行账户虽然不是互联网账户，不过绑定的安全性也很重要。我这里只有工商银行的卡，所以只以其为例作为尝试。感谢评论区里侧脸君的提醒，我才发现工行App 的设置中有 调整注册手机号 和 手机号管理 两项，看起来一个像是登录手机银行用的，另一个像是业务联系用的。先来更改第一个。进入页面后输入新号码，填入发来的验证码（它每次都会发两次），第三页的验证方式是 使用工行的密码器获取动态密码 ，与以上各种方式都不相同，虽然略有麻烦但出于安全还是可以理解的。 调整注册手机号 在手机号管理的页面里，可以看到这里是一个联系信息的修改，第二层页面中看到该手机号关联的几项业务。输入短信验证码后依然需要工行的密码器验证。 手机号管理 不过在疑惑以上两个手机号到底哪个才是我们通常上认为的“预留手机号”的时候，我在智能机器人里发现了如下答案： 还是得去营业厅…… 看来虽然改了两个号码了，但谁也不是，最后还是得去营业厅办理。虽然麻烦一点，不过还是提醒大家一定要记得更改自己的银行、社保账户等绑定的手机号码，我的同学直到前几天还在接收提醒上一任机主交社保的短信…… 尾巴以上，不同家的设备换绑和验证方式虽然大同小异，但在便利性和安全性的权衡上，也演化出了各种细微的差别，顺带也可以看得出各家拥有的用户信息量各有不同。不过不论是使用常用设备、银行信息还是实名认证等方式，使用原号码作为验证还是最普遍的，所以换手机号之后不要急着注销旧号，否则可能会在需要解绑时遇到一些麻烦。 移动网络设备的发展降低了手机号码的联络性功能，可能不知道对方的手机号我们也可以毫无障碍地联系到TA，然而作为各种账号的绑定中心，当前阶段它依然起到维系互联网生活的重要作用。及时更换绑定不光涉及使用便利性，也关乎信息安全。记得及时解绑不用的账号，也是保护我们信息安全的有效途径。 文中涉及的截图可能有的左上角时间顺序不对，因为版本控制不力所致；另外，涉及不同App 在不同网络环境下的安全检测以及软件升级等原因，换绑流程也可能与各位实际使用时略有差异，敬请谅解！如果你还有什么补充的账号解绑姿势，欢迎在评论区补充与大家分享哦！ 还在纠结换什么套餐？这些文章值得读： 👉 老用户能自由更换手机套餐，我们整理了最全面的操作指南 - 少数派 👉 手机想换互联网套餐不知道哪款合适？这款小程序能给你满意答案 - 少数派 手机换了新卡后，我换绑了这些账户的手机号","link":"/2019/08/02/%E6%89%8B%E6%9C%BA%E6%8D%A2%E4%BA%86%E6%96%B0%E5%8D%A1%E5%90%8E%EF%BC%8C%E6%88%91%E6%8D%A2%E7%BB%91%E4%BA%86%E8%BF%99%E4%BA%9B%E8%B4%A6%E6%88%B7%E7%9A%84%E6%89%8B%E6%9C%BA%E5%8F%B7/"},{"title":"扩展性","text":"扩展性1、避免单点故障：任何东西都要有两个。这增加了成本和复杂度，但却能在可用性和负载性能上获益。而且，这有助于设计者采用一种分布式优先的思维。2、横向扩展，而不是纵向扩展：升级服务器（纵向）的成本是指数增长的，而增加另一台商用服务器（横向）的成本是线性增长的。3、尽量减少应用程序核心所需要完成的工作。4、API优先：将应用程序视为一个提供API的服务，而且，不假定服务的客户端类型（手机应用、Web站点、桌面应用程序）。5、总是缓存。6、提供尽可能新的数据：用户可能不需要立即看到最新的数据，最终一致性可以带来更高的可用性。7、设计时要考虑维护和自动化：不要低估应用程序维护所需要的时间和工作量。软件首次公开发布是一个值得称赞的里程碑，但也标志着真正的工作要开始了。8、宁异步，不同步。9、努力实现无状态：状态信息要保存在尽可能少的地方，而且要保存在专门设计的组件中。10、为故障做好准备：将故障对终端用户的影响最小化。 性能可扩展：性能无法完全实现线性扩展，但要尽量使用具有并发性和异步性的组件。具备完成通知功能的工作队列要优于同步连接到数据库。 可用性可扩展：CAP理论表明，分布式系统无法同时提供一致性、可用性和分区容错性保证。许多大规模Web应用程序都为了可用性和分区容错性而牺牲了强一致性，而后者则有赖于最终一致性来保证。 维护可扩展：软件和服务器都需要维护。在使用平台&amp;工具监控和更新应用程序时，要尽可能地自动化。 成本可扩展：总拥有成本包括开发、维护和运营支出。在设计一个系统时，要在重用现有组件和完全新开发组件之间进行权衡。现有组件很少能完全满足需求，但修改现有组件的成本还是可能低于开发一个完全不同的方案。另外，使用符合行业标准的技术使组织更容易聘到专家，而发布独有的开源方案则可能帮助组织从社区中挖掘人才。","link":"/2019/08/02/%E6%89%A9%E5%B1%95%E6%80%A7/"},{"title":"技术架构图","text":"技术架构图搜索引擎技术架构 供应链系统架构 个性化推荐引擎技术架构 大数据平台技术架构 云平台技术架构 Iaas架构设计 分布式文件存储应用架构 HDFS， 分布式 文件 系统， Hadoop 的 核心 组成部分。MapReduce， 分布式 数据处理， Hadoop 核心 之一。HBase， 一个 分布式 的， 列 存储 数据库， 使用 HDFS 作为 底层 存储， 同时 支持 MapReduce 的 批量 式 计算 和 点 查询。Zookeeper， 一个 分布式 的， 高 可用 的 协调 服务。 提供 分布式 锁 之类 的 基本 服务， 用于 构建 分布式 应用。Hive， 分布式 数据 仓库， Hive 管理 HDFS 中 存储 的 数据， 并提 供 基于 SQL 的 查询 语言 用以 查询 数据。Hama， 建立 在 Hadoop 上 的 分布式 并行 计算 框架， 基于 Map/ Reduce 和 Bulk Synchronous 的 实现 框架， 运行 环境 需要 关联 Zookeeper、 HBase、 HDFS 组件。Mahout， 一个 基于 MapReduce 的 机器 学习 算 法库， 运行 在 Hadoop 集群 上。Cassandra， 一种 混合 的 非 关系 型 数据库， 类似于 Google 的 BigTable。 以上 就是 数据 存储 层 中， 用到 的 一些 开源 数据 框架， 我们 继续 看 大数 据 平台 的 其他 组成部分。","link":"/2019/08/02/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%9B%BE/"},{"title":"技术点","text":"技术点高可用 高并发1. 分布式应用集群 2. 负载均衡 3. 分布式缓存集群 4. redis读写分离 5. 分布式数据库 读写分离 6. 多级缓存架构 nginx 缓存服务 ehcache - nginx抗热点数据+redis抗大规模离线请求+ehcache抗redis崩溃的三级缓存架构 7. 动静分离 动态模板渲染 8. 异步 9. 消息队列 10. 服务分层 11. zookeeper 12. redis备份恢复 RDB AOF 13. Hystrix 快速失败 快速恢复 execute queue1234567Hystrix如何解决依赖隔离1: Hystrix使用命令模式HystrixCommand(Command)包装依赖调用逻辑，每个命令在单独线程中/信号授权下执行。2: 可配置依赖调用超时时间,超时时间一般设为比99.5%平均时间略高即可.当调用超时时，直接返回或执行fallback逻辑。3: 为每个依赖提供一个小的线程池（或信号），如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。4: 依赖调用结果分:成功，失败（抛出异常），超时，线程拒绝，短路。 请求失败(异常，拒绝，超时，短路)时执行fallback(降级)逻辑。5: 提供熔断器组件,可以自动运行或手动调用,停止当前依赖一段时间(10秒)，熔断器默认错误率阈值为50%,超过将自动运行。6: 提供近实时依赖的统计和监控 安全1. xss 内容过滤 2. 持久性 3. 反射性 1. sql注入 1. sql验证 2. 参数绑定 2. csrf 1. 用户身份认证 token生成 2. 验证码 3. reffer校验自动开关降级自动降级是根据系统负载、资源使用情况、SLA等指标进行降级。 超时降级当访问的数据库/http服务/远程调用响应慢或者长时间响应慢，且该服务不是核心服务的话可以在超时后自动降级；比如商品详情页上有推荐内容/评价，但是推荐内容/评价暂时不展示对用户购物流程不会产生很大的影响；对于这种服务是可以超时降级的。如果是调用别人的远程服务，和对方定义一个服务响应最大时间，如果超时了则自动降级。之前总结过一些的文章《使用httpclient必须知道的参数设置及代码写法、存在的风险》和《dbcp配置及jdbc超时设置总结》。在实际场景用一定主要配置好超时时间和超时重试次数和机制。 统计失败次数降级有时候依赖一些不稳定的API，比如调用外部机票服务，当失败调用次数达到一定阀值自动降级；然后通过异步线程去探测服务是否恢复了，则取消降级。 故障降级比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据）。 限流降级当我们去秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时开发者会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）。 熔断服务不可用 熔断机制收集失败次数 达到阈值 做熔断 -&gt; 半熔断 -&gt; 恢复 Redis redis cluster 自动将数据分片 每个master上放置部分数据 提供内置高可用支持，部分master不支持时，可以继续工作 哨兵 集群监控 消息通知 故障转移 选举 配置中心 如果故障转移发生了，通知client新的master地址 数据一致性1. hash算法 2. 一致性hash算法 3. redis cluster的hash slot","link":"/2019/08/02/%E6%8A%80%E6%9C%AF%E7%82%B9/"},{"title":"技术点整理","text":"技术点整理资源隔离限流与过载保护熔断优雅降级容错超时控制监控高并发高可用高性能负载均衡分布式应用分布式缓存分布式数据库Redis redis cluster 自动将数据分片 每个master上放置部分数据 提供内置高可用支持，部分master不支持时，可以继续工作 哨兵 集群监控 消息通知 故障转移 选举 配置中心 如果故障转移发生了，通知client新的master地址 数据一致性 hash算法 一致性hash算法 redis cluster的hash slot","link":"/2019/08/02/%E6%8A%80%E6%9C%AF%E7%82%B9%E6%95%B4%E7%90%86/"},{"title":"携程大数据实践：高并发应用架构及推荐系统案例","text":"携程大数据实践：高并发应用架构及推荐系统案例摘要：本文来自携程技术中心基础业务研发部的《应用架构涅槃》系列分享。 本文来自携程技术中心基础业务研发部的《应用架构涅槃》系列分享。据基础业务研发部负责人李小林介绍，互联网二次革命的移动互联网时代，如何吸引用户、留住用户并深入挖掘用户价值，在激烈的竞争中脱颖而出，是各大电商的重要课题。通过各类 大数据 对用户进行研究，以数据驱动产品是解决这个课题的主要手段，携程的大数据团队也由此应运而生；经过几年的努力，大数据的相关技术为业务带来了惊人的提升与帮助。以基础大数据的用户意图服务为例，通过将广告和栏位的“千人一面”变为“千人千面”，在提升用户便捷性，可用性，降低费力度的同时，其转化率也得到了数倍的提升，体现了大数据服务的真正价值。 在李小林看来，大数据是互联网行业发展的趋势，互联网的从业人员需要高度关注大数据相关的技术及应用，也希望通过这一系列大数据相关的讲座，让各位同学有所收获。 首场《应用架构涅磐》分享来自基础业务研发部的董锐，包括业务高速发展带来的应用架构挑战、应对挑战的架构涅磐、应用系统整体架构和 推荐系统 案例等四个部分。 一、业务高速发展带来的应用架构挑战公司业务高速发展带来哪些主要的变化，以及给我们的系统带来了哪些挑战？ 业务需求的急速增长，访问请求的并发量激增，2016年1月份以来，业务部门的服务日均请求量激增了5.5倍。 业务逻辑日益复杂化，基础业务研发部需要支撑起OTA数十个业务线，业务逻辑日趋复杂和繁多。 业务数据源多样化，异构化，接入的业务线、合作公司的数据源越来越多；接入的数据结构由以前的数据库结构化数据整合转为Hive表、评论文本数据、日志数据、天气数据、网页数据等多元化异构数据整合。 业务的高速发展和迭代，部门一直以追求以最少的开发人力，以架构和系统的技术优化，支撑起携程各业务线高速发展和迭代的需要。在这种新形势下，传统应用架构不得不变，做为工程师也必然要自我涅槃，改为大数据及新的高并发架构，来应对业务需求激增及高速迭代的需要。计算分层分解、去SQL、去数据库化、模块化拆解的相关技改工作已经刻不容缓。 以用户意图（AI 点金杖）的个性化服务为例， 面对BU业务线的全面支持的迫切需要，其应用架构必须解决如下技术难点： 高访问并发：每天近亿次的访问请求； 数据量大：每天TB级的增量数据，近百亿条的用户数据，上百万的产品数据； 业务逻辑复杂：复杂个性化算法和LBS算法；例如：满足一个复杂用户请求需要大量计算和30次左右的SQL数据查询，服务延时越来越长； 高速迭代上线：面对OTA多业务线的个性化、Cross-saling、Up-saling、需满足提升转化率的迫切需求，迭代栏位或场景要快速，同时减少研发成本。二、应对挑战的架构涅磐 面对这些挑战，我们的应用系统架构应该如何涅磐？主要分如下三大方面系统详解: 存储的涅磐 ，这一点对于整个系统的吞吐量和并发量的提升起到最关键的作用，需要结合数据存储模型和具体应用的场景。 计算的涅磐 ，可以从横向和纵向考虑：横向主要是增加并发度，首先想到的是分布式。纵向拆分就是要求我们找到计算的结合点从而进行分层，针对不同的层次选择不同的计算地点。然后再将各层次计算完后的结果相结合，尽可能最大化系统整体的处理能力。 业务层架构的涅磐 ，要求系统的良好的模块化设计，清楚的定义模块的边界，模块自升级和可配置化。三、应用系统的整体架构 认识到需要应对的挑战，我们应该如何设计我们的系统呢，下面将全面的介绍下我们的应用系统整体架构。 下图就是我们应用系统整体架构以及系统层次的模块构成。 数据源部分，Hermes是携程框架部门提供的消息队列，基于Kafka和MySQL做为底层实现的封装，应用于系统间实时数据传输交互通道。Hive和HDFS是携程海量数据的主要存储，两者来自Hadoop生态体系。Hadoop大家已经很熟悉，如果不熟悉的同学只要知道Hadoop主要用于大数据量存储和并行计算批处理工作。 Hive是基于Hadoop平台的数据仓库，沿用了关系型数据库的很多概念。比如说数据库和表，还有一套近似于SQL的查询接口的支持，在Hive里叫做HQL，但是其底层的实现细节和关系型数据库完全不一样，Hive底层所有的计算都是基于MR来完成，我们的数据工程师90%都数据处理工作都基于它来完成。 离线部分，包含的模块有MR、Hive、Mahout、SparkQL/MLLib。Hive上面已经介绍过，Mahout简单理解提供基于Hadoop平台进行数据挖掘的一些机器学习的算法包。Spark类似hadoop也是提供大数据并行批量处理平台，但是它是基于内存的。SparkQL 和Spark MLLib是基于Spark平台的SQL查询引擎和数据挖掘相关算法框架。我们主要用Mahout和Spark MLLib进行数据挖掘工作。 调度系统zeus，是淘宝开源大数据平台调度系统，于2015年引进到携程，之后我们进行了重构和功能升级，做为携程大数据平台的作业调度平台。 近线部分，是基于Muise来实现我们的近实时的计算场景，Muise是也是携程OPS提供的实时计算流处理平台，内部是基于Storm实现与HERMES消息队列搭配起来使用。例如，我们使用MUSIE通过消费来自消息队列里的用户实时行为，订单记录，结合画像等一起基础数据，经一系列复杂的规则和算法，实时的识别出用户的行程意图。 后台/线上应用部分，MySQL用于支撑后台系统的数据库。ElasticSearch是基于Lucene实现的分布式搜索引擎，用于索引用户画像的数据，支持离线精准营销的用户筛选，同时支持线上应用推荐系统的选品功能。HBase 基于Hadoop的HDFS 上的列存储NoSQL数据库，用于后台报表可视化系统和线上服务的数据存储。 这里说明一下, 在线和后台应用使用的ElasticSearch和HBase集群是分开的，互不影响。Redis支持在线服务的高速缓存，用于缓存统计分析出来的热点数据。 四、推荐系统案例介绍完我们应用系统的整体构成，接下来分享基于这套系统架构实现的一个实例——携程个性化推荐系统。 推荐系统的架构图： 1、存储的涅磐1）NoSQL (HBase+Redis) 我们之前存储使用的是MySQL，一般关系型数据库会做为应用系统存储的首选。大家知道MySQL非商业版对分布式支持不够，在存储数据量不高，查询量和计算复杂度不是很大的情况下，可以满足应用系统绝大部分的功能需求。 我们现状是需要安全存储海量的数据，高吞吐，并发能力强，同时随着数据量和请求量的快速增加，能够通过加节点来扩容。另外还需要支持故障转移，自动恢复，无需额外的运维成本。综上几个主要因素，我们进行了大量的调研和测试，最终我们选用HBase和Redis两个NoSQL数据库来取代以往使用的MySQL。我们把用户意图以及推荐产品数据以KV的形式存储在HBase中，我对操作HBase进行一些优化，其中包括rowkey的设计，预分配，数据压缩等，同时针对我们的使用场景对HBase本身配置方面的也进行了调优。目前存储的数据量已经达到TB级别，支持每天千万次请求，同时保证99%在50毫秒内返回。 Redis和多数应用系统使用方式一样，主要用于缓存热点数据，这里就不多说了。 2）搜索引擎 (ElasticSearch) ES索引各业务线产品特征数据，提供基于用户的意图特征和产品特征复杂的多维检索和排序功能，当前集群由4台大内存物理机器构成，采用全内存索引。对比某一个复杂的查询场景，之前用MySQL将近需要30次查询，使用ES只需要一次组合查询且在100毫秒内返回。目前每天千万次搜索，99%以上在300毫秒以内返回。 2、计算的涅磐1）数据源，我们的数据源分结构化和半结构化数据以及非结构化数据。 结构化数据主要是指携程各产线的产品维表和订单数据，有酒店、景酒、团队游、门票、景点等，还有一些基础数据，比如城市表、车站等，这类数据基本上都是T+1，每天会有流程去各BU的生产表拉取数据。 半结构化数据是指，携程用户的访问行为数据，例如浏览、搜索、预订、反馈等，这边顺便提一下，这些数据这些是由前端采集框架实时采集，然后下发到后端的收集服务，由收集服务在写入到Hermes消息队列，一路会落地到Hadoop上面做长期存储，另一路近线层可以通过订阅Hermes此类数据Topic进行近实时的计算工作。 我们还用到外部合作渠道的数据，还有一些评论数据，评论属于非结构化的，也是T+1更新。 2）离线计算，主要分三个处理阶段。 预处理阶段，这块主要为后续数据挖掘做一些数据的准备工作，数据去重，过滤，对缺失信息的补足。举例来说采集下来的用户行为数据，所含有的产品信息很少，我们会使用产品表的数据进行一些补足，确保给后续的数据挖掘使用时候尽量完整的。 数据挖掘阶段，主要运用一些常用的数据挖掘算法进行模型训练和推荐数据的输出(分类、聚类、回归、CF等)。 结果导入阶段，我们通过可配置的数据导入工具将推荐数据，进行一系列转换后，导入到HBase、Redis以及建立ES索引，Redis存储的是经统计计算出的热点数据。 3）近线计算（用户意图、产品缓存） 当用户没有明确的目的性情况下，很难找到满足兴趣的产品，我们不仅需要了解用户的历史兴趣，用户实时行为特征的抽取和理解更加重要，以便快速的推荐出符合用户当前兴趣的产品，这就是用户意图服务需要实现的功能。 一般来说用户特征分成两大类：一种是稳定的特征（用户画像），如用户性别、常住地、主题偏好等特征；另一类是根据用户行为计算获取的特征，如用户对酒店星级的偏好、目的地偏好、跟团游/自由行偏好等。基于前面所述的计算的特点，我们使用近在线计算来获取第二类用户特征，整体框图如下。从图中可以看出它的输入数据源包括两大类：第一类是实时的用户行为；第二类是用户画像，历史交易以及情景等离线模块提供的数据。结合这两类数据，经一些列复杂的近线学习算法和规则引擎，计算得出用户当前实时意图列表存储到HBase和Redis中。 携程用户意图框架近线另一个工作是产品数据缓存，携程的业务线很多，而我们的推荐系统会推各个业务线的产品，因此我们需要调用所有业务线的产品服务接口，但随着我们上线的场景的增加，这样无形的增加了对业务方接口的调用压力。而且业务线产品接口服务主要应用于业务的主流程或关键型应用，比较重，且SLA服务等级层次不齐，可能会影响到整个推荐系统的响应时间。 为了解决这两个问题，我们设计了近在线计算来进行业务的产品信息异步缓存策略，具体的流程如下。 我们会将待推荐的产品Id全部通过Kafka异步下发，在Storm中我们会对各业务方的产品首先进行聚合，达到批处理个数或者时间gap时，再调用各业务方的接口，这样减少对业务方接口的压力。通过调用业务方接口更新的产品状态临时缓存起来（根据各业务产品信息更新周期分别设置缓存失效时间），在线计算的时候直接先读取临时缓存数据，缓存不存在的情况下，再击穿到业务的接口服务。 产品异步缓存框架 4）在线计算（2个关键业务层架构模块介绍） ①业务层架构-数据治理和访问模块 ，支持的存储介质，目前支持的存储介质有Localcache、Redis、HBase、MySQL可以支持横向扩展。统一配置，对同一份数据，采用统一配置，可以随意存储在任意介质，根据id查询返回统一格式的数据，对查询接口完全透明。 穿透策略和容灾策略，Redis只存储了热数据，当需要查询冷数据则可以自动到下一级存储如HBase查询，避免缓存资源浪费。当Redis出现故障时或请求数异常上涨，超过整体承受能力，此时服务降级自动生效，并可配置化。 ②业务层架构-推荐策略模块 ，整个流程是先将用户意图、用户浏览，相关推荐策略生成的产品集合等做为数据输入，接着按照场景规则，业务逻辑重新过滤，聚合、排序。最后验证和拼装业务线产品信息后输出推荐结果； 我们对此流程每一步进行了一些模块化的抽象，将重排序逻辑按步骤抽象解耦，抽象如右图所示的多个组件，开发新接口时仅需要将内部DSL拼装便可以得到满足业务需求的推荐服务；提高了代码的复用率和可读性，减少了超过50%的开发时间；对于充分验证的模块的复用，有效保证了服务的质量。 转自：极客头条 链接：http://geek.csdn.net/news/detail/96708","link":"/2019/08/02/%E6%90%BA%E7%A8%8B%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E8%B7%B5%EF%BC%9A%E9%AB%98%E5%B9%B6%E5%8F%91%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%A1%88%E4%BE%8B/"},{"title":"服务降级","text":"服务降级 自动开关降级自动降级是根据系统负载、资源使用情况、SLA等指标进行降级。 超时降级当访问的数据库/http服务/远程调用响应慢或者长时间响应慢，且该服务不是核心服务的话可以在超时后自动降级；比如商品详情页上有推荐内容/评价，但是推荐内容/评价暂时不展示对用户购物流程不会产生很大的影响；对于这种服务是可以超时降级的。如果是调用别人的远程服务，和对方定义一个服务响应最大时间，如果超时了则自动降级。之前总结过一些的文章《使用httpclient必须知道的参数设置及代码写法、存在的风险》和《dbcp配置及jdbc超时设置总结》。在实际场景用一定主要配置好超时时间和超时重试次数和机制。 统计失败次数降级有时候依赖一些不稳定的API，比如调用外部机票服务，当失败调用次数达到一定阀值自动降级；然后通过异步线程去探测服务是否恢复了，则取消降级。 故障降级比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据）。 限流降级当我们去秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时开发者会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）。","link":"/2019/08/02/%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/"},{"title":"架构师大纲","text":"架构师大纲源码分析+ 常用设计模式 + Proxy 代理 + Factory 工厂 + Singleton 单例 + Delegate 委派 + Strategy 策略 + Prototype 原型 + Template 模版 + Sprint5 + Beans + Context + Transaction + MVC + spring5新特性 + Mybatis + 代码自动生成器 + 1对多 多对多 嵌套结果 嵌套查询 + 一级缓存 二级缓存使用场景及选择策略 + Mybatis与Sprint集成 + Sprint集成下的Session、Mapper + 事务 + 动态代理的真正实现 + 一步步手写Mybatis 1.0-&gt;2.0分布式架构+ 漫谈分布式架构 + 分布式架构策略-分而治之 + Dubbo + RPC + Zookeeper + 分布式架构-中间件 + 消息 ActiveMQ + 消息 Kafka + 消息 RabbitMQ + 分布式缓存 Redis + 数据存储 Nosql mongoDB Mysql + 数据库中间件 Mycat + 后台服务 Nginx+lua + 高性能NIO框架 基于Netty + 分布式解决方案微服务架构+ 微框架 + Sprint Boot + Spring Cloud + Docker 虚拟化 + 漫谈微服务架构 + SOA性能优化+ 理解性能优化 + JVM调优 + Tomcat调优 + Mysql调优团队协作效率+ Maven + Jekins + Sonar + Git项目实战","link":"/2019/08/02/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%A4%A7%E7%BA%B2/"},{"title":"架构评审的意义","text":"架构评审的意义许多公司的项目流程中都有架构评审环节，却鲜少有人提起，大概对于参与者来说都并不是多么愉快的经历，一提都要皱着眉头，各有一肚子苦水涌上心头，慨叹不堪回首。￼被评审的同学感觉像是过堂，冥冥中有人在高声呼喝“升堂威武”，生怕自己一句话没说明白，对面的黑脸胖子就会蹦起来叫“开铡”，没通过评审连死的心都有。￼依我看，这源于认知冲突（这个词儿是从《架构即未来》里学的），参与各方的认知不一致，甚至引发情感冲突。今天简单说说我对架构评审的认识，主要是评审的意义所在，理解了意义，目标一致，自然同心协力。 曾经有次架构评审，两位其他部门的同事问我架构设计有什么特别思维，要掌握哪些不为人知的高能技巧。我当时心思还在方案上，顺口回答其实跟编程做开发都是一脉相承的，该怎么拆分解耦怎么抽象聚合，道理上都是一样一样一样的啊。大概这个答案不符合两位同事的预期，他们脸上有些失望，还有些不以为然，可能认为我在敷衍或者是本身就其实难副，就没再继续交流下去。似乎不久之后，他们都离开了那个公司，不知如今是否找寻到了满意的答案。如今再想，当年的确回答得太狭隘了，架构设计还要考虑很多其他方面。 架构评审、跟技术方案评审、CodeReview一样，都是项目流程必要环节，是指对架构设计方案进行评审。 在传统的软件工程理论中，设计阶段产出物就是设计文档，包括概要设计/详细设计，但不分产品和研发，所以文档既包括功能描述，也包括技术实现，有些对日外包的项目，甲方发过来的文档里连伪代码都写好了，就等着你翻译成代码，外包工程师纯粹就是一个翻译机器。而到了互联网时代，提倡敏捷迭代，总嫌传统方式太重，流程复杂，影响效率，什么都希望短平快，在扁平化的组织中，经常是需求火速分发到一线研发，然后就靠个人折腾去了。实际上达到一定规模的公司多半会进行架构评审，即由架构评审组织（架构评审委员会之类）制定架构设计文档规范，设计人员根据规范编写方案，设计人员当面向评审人员讲解方案，回答评审人员问题，评审人员提出意见和建议，双方进行讨论以充分沟通，最终由评审人员决定是否通过，一次评审不通过可以修改后再次评审。 本质上架构评审跟测试相同，都为了保证质量，也没见谁对测试有多反感，宣称不需要测试通过就可以直接上线的。由于技术人员普遍存在文人相轻的心理，对于参加评审被人挑毛拣刺的活动容易有所抵触。评审过程中会讲到实现的关键点，因此有些相关人员也会参与了解，比如测试、数据、安全等，可能在无形中增加了被审者的心理压力。毕竟架构设计代表着更高阶的技术能力，当面当众被指出问题要求修改，惯于“一人我撸代码”的研发人员容易自尊心受伤，面子上挂不住。 有强烈的技术个人自由主义倾向的同学，并不适合团队作战。只注重研发实现，技术新潮，不关注线上性能、持续运维、故障应急的程序猿，再牛也不是好攻城狮。自己的设计被指出问题，提出改进建议，不喜反恼，则是心态不成熟的表现。 架构评审的目的是什么？ 把关，确保方案合格，各方面都考虑到了，避免缺陷和遗漏，不求方案多牛，至少不犯错。 保证架构设计合理和基本一致，符合整体原则。 维持对系统架构的全局认知，避免黑盒效应。 通过评审发掘创新亮点，推广最佳实践。以上四点重要性从高到低排列。可见，评审都是对事，而不是对人，参与评审的各方是平等的，各司其职，而项目是服务于公司业务的。 有人会自信满满拍着胸脯说自己的设计已经足够完美，不需要再费时间给别人讲，你敢保证别人的也跟你一样完美么？这次完美了，下次也会么？方案设计不仅仅是考虑功能实现，还有很多非功能需求，以及持续运维所需要的工作，需要工程实践经验，进行平衡和取舍。架构设计往往没有想象中那么简单纯粹，甚至一多半的精力要关注非核心的方面。随便举几个例子： 互联网金融公司的系统没有对账机制——你还敢投钱在里面么？ 有的人号称玩转高并发多线程，扣减积分/余额程序就是先查询，再判断够不够，够的话就减掉后更新。——不知道被人白刷掉多少呢，刷多了应该能发现，拜托，对账都没有，你怎么发现？ 对异常情况考虑不全，数据流断了，数据就丢了，逻辑要是再复杂点儿，时间再久一点，再想修复？愁死你。 核心业务应用，方案设计很费心思，但没考虑过性能指标，也没想过怎么监控告警——这都是没吃过亏，捅过篓子的。 有人对着自己的完美方案讲着讲着，不等别人指出，就发现了数据逻辑没有完整闭环的问题。 有人会说经验都是趟坑积累出来的，否则没法成长，你问问老板愿意拿业务系统当练手的试验田么？于是有了架构评审，更多有丰富经验的人花较少的时间成本，快速的过一遍方案设计，三个臭皮匠赛过诸葛亮，更何况有资格做架构评审的，都是见识过各种情况的。但不代表评审的人就高人一等更权威，再牛的人，讨论技术方案，也要以理服人。有些做评审的，认为浪费自己时间，因为总是那些常见问题，还要耐心听完，自己似乎没有得到什么提高，请注意，能避免犯错，系统不至于三天两头到处冒烟，这就是莫大的光荣。有些被评审的，在评审时感觉低人一头，仿佛被人审判，进一步会想“凭什么你来评审我，你算老几啊，这业务你没我懂啊！”对不起，这真不是业务百科知识大赛。身边的人牛就不爽，觉得没啥了不起，碰到业界大神又惊呼真平易近人！其实大神本来就平易近人，不会觉得自己高高在上，心智成熟，有自知之明。大牛之所以成为大牛，也许就因为人家不飘飘然，脚踏实地，勤于做事，虚怀若谷，空杯心态。 系统是满足需求，实现业务功能的，大家都是为了能查漏补缺才坐到一起。良好的心态才能合作，才能共赢。功劳是大家的，出了问题，共担责任，不能置身事外。最后一句，既然都来了，放下那些有的没的，好好琢磨方案才是正道！ ￼ 3月由中生代技术&amp;iTechPlus发起的年度大会降临魔都，20+话题，6大主题，干货专家悉数到场，学习是一辈子的事，坚持学习，成为优秀人才！","link":"/2019/08/02/%E6%9E%B6%E6%9E%84%E8%AF%84%E5%AE%A1%E7%9A%84%E6%84%8F%E4%B9%89/"},{"title":"标准的微服务架构","text":"标准的微服务架构","link":"/2019/08/02/%E6%A0%87%E5%87%86%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"},{"title":"稍微有点难度的10道java面试题，你会几道？","text":"稍微有点难度的10道java面试题，你会几道？1、jvm对频繁调用的方法做了哪些优化？ - java虚拟机最开始是通过解释器进行解释执行的，当虚拟机发现某个方法或者代码块的运行特别频繁时，就会把这些代码认定为”热点代码”，为了提高热点代码的执行效率，在运行时，虚拟机会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器(JIT)。 2、常见的攻击手段有哪些？如何防范？ - XSS、CSRF、SQL注入、DOS/DDOS等具体细节见历史文章。 3、restful api有哪些设计原则？ - 需要考虑的设计原则有：域名、版本、路径、动词、状态码、返回结果等等之后具体会形成文章。 4、hessian是做什么用的？它的传输单位是什么？ - Hessian是一个轻量级的remoting onhttp工具，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。 5、http中的post、get有什么区别？base64过后的字符串可以通过get传输吗？ - 区别： 1、两种动作不一样，get是获取资源，post是提交资源 2、get参数在URL中不安全，post是放在http body中的相对安全 3、get传输字节数受限于URL长度，post无限制 4、后台获取数据的方式get只能是QueryString,post可从InputStream中获取 base64编码后有+=特殊符号的会转码不能经get传输，如果是改进的base64会替换掉特殊符号可以用get传输。 6、常用的算法都有哪些分类，分别有哪些算法及应用场景？ - 一般有散列算法、对称算法、非对称算法，具体细节见历史文章。 7、死锁是什么？写一个死锁的例子？如何避免死锁？ - 死锁就是多线程相互等待对方释放锁造成的假死状态，具体见历史文章。 8、学用的序列化方案都有哪些，说说它们的优缺点？ - 序列化有对象序列化，JSON序列化，XML序列化等，像java自带序列化、kryo、protostuff、GSON、jackson、fastjson等之后形成文章。 9、什么是过滤器、拦截器、监听器，它们的顺序是怎样的？ - 监听器是容器启动和销毁时触发的动作，过滤器是进入servlet请求之前触发的工作，拦截器是像springmvc框架实现的内部的请求拦截器。 顺序：监听器&gt;过滤器&gt;拦截器 10、servlet3.0有哪些新规范？ - 增加注解不需要web.xml配置、异步处理、可插性支持，性能增强等。","link":"/2019/08/02/%E7%A8%8D%E5%BE%AE%E6%9C%89%E7%82%B9%E9%9A%BE%E5%BA%A6%E7%9A%8410%E9%81%93java%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%87%A0%E9%81%93%EF%BC%9F/"},{"title":"电商网站","text":"电商网站 商品详情页的多级缓存架构 nginx本地缓存+redis分布式缓存+tomcat jvm多级缓存 时效性高 价格 库存 时效性低 商品基本信息 （名称、颜色、版本、规格参数等等）","link":"/2019/08/02/%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99/"},{"title":"直播系统架构","text":"直播系统架构","link":"/2019/08/02/%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"},{"title":"自动化运维","text":"自动化运维1、支持混合云CMDB 基于云平台API做管理 2、监控+应用性能分析 Zabbix 服务器，磁盘、网络、中间件、数据库 3、UI批量运维工具 4、日志集中分析工具 ELK 5、持续化集成发布工具 Jekins 6、安全漏洞扫描","link":"/2019/08/02/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"},{"title":"虹虹梦蝶：强大的祖国 你到底在哪里？","text":"虹虹梦蝶：强大的祖国 你到底在哪里？有友发来信息，要我为她的亲戚重病无奈之际的“轻松筹”发朋友圈，我是一个冷血冷酷无情无义的人，踌躇些许后，狠心拒绝了。如果我这次帮她发了，让其他人得知后，要我发朋友圈的接踵而至，那我怎么办？不用去数字统计，估计每个人的朋友圈或三天两头或十天半月就见有人转发“轻松筹”的帖子，请求好心人的怜悯，伸出援手以渡难关。但是可怜不了许多！ 暑假末期的时候，这位友人去看《战狼2》看得热血沸腾，还在朋友圈写下一段对电影对祖国情深如许的文字，爱国之情溢于言表，就像很多小粉红一样，总是动不动就说自己的祖国强大。这个国家不是时时处处对里对外宣称自己强大吗？既然你的国民生病了，应该找大言炎炎的吴京，应该找背后强大的祖国，而不是找弱小的如我者来转发帖子。华夏大地上生病的人越来越多，看不起病的人也越来越多，因没钱医治而自绝于人世的越来越多，强大的祖国，你在哪里？你眼睛瞎了吗？ 看不起病的人需要你，上不起学的需要你，买不起房子的需要你，死不起的人需要你， 一桩桩悲惨悲痛的事件发生了，一个个有泪无处流、有苦不敢说的人们越来越多了，可是，强大的祖国，你到底在哪里？ 在新闻联播上，领导人很忙，人民很幸福，能不能从电视上走出来，让这些遍野的哀鸿感受祖国的强大？ 在主流媒体的各种标题上：美帝被吓傻了，美国穷到无钱开饭了，美国哀叹赶不上中国了，日本被吓尿了，俄罗斯对中国甘拜下风了，非洲国家正式向中国道歉了，资本主义国家的人民一天不如一天了。美帝日本们根本看不到强国的强大标题，无耻的御用文人和无良媒体，能不能不要这样瞎编乱造？ 在每一次往外大撒钱的挥钱如纸中，各国人民都接受优质的教育，实现免费医疗，都在研究怎么让自己吃得更好，过上自由平等的生活，而强大的祖国，能不能先解决我们的吃上饭的问题？能不能让我们看得起病，不要让我们闻病色变，如进屠宰场进一次被宰一次？ 强大的祖国，你到底在哪里？最近发生那么多虐童性侵事件，如果发生在美国，罪犯会被阉割；如果发生在德国，要么蹲监狱，要么被阉割；如果发生在韩国，立法实施化学阉割；如果发生在大清，绞决；可是发生在我们强大的祖国，要么不闻不问不报道，要么隐瞒、删帖、禁言、抓人，强大的祖国，你强在哪里？ 强大的祖国，你到底在哪里？最近屡见因生病无钱医治的悲惨事件，网易一则新闻，“白血病女孩‘为了不带累父母，自拔氧气去世”。再一则“哥哥将鸡蛋留给重病弟弟吃，结果全放坏了”。再再一则“上海一位单亲妈妈在寒风中跪在儿子面前，3岁的孩子患病无钱续医，无助的妈妈在街头哭泣”。仅仅在一天之内的悲惨事件，引发万千网友的关注，疾呼实现全民免费医疗，痛骂某个不负责任的大锅，我们强大的祖国，你到底在哪里？死哪里去了？这些无助可怜的人需要你，你怎么就不见了？ 北方的隆冬季节来了，供暖系统设备跟不上，几个人烧煤取暖竟然被刑拘！饿了要吃，冷了要取暖，这是生物的本能，何错之有？凭什么将人刑拘？强大的祖国，你国的人民连取暖都不容许，证明你国的人活得连猪狗动物都不如，冬天来了猫怕冷了都会钻到有暖意的所在而不会被刑拘，蛇也会冬眠而不会被驱逐，鸡犬之类的也会去晒太阳而不会有无妄之灾，而竟不容许一个大活人在大冷天烧煤取暖！强大的祖国，你到底强在哪里？ 由此可见，所谓强大的祖国，是有人刻意编造的谎言，目的是让人活在虚幻中，感受虚假的幸福；是自我拔高自我表扬自欺欺人；是让傻子上当，不吵不闹，安心做奴隶。 连一罐安全的奶粉都买不到，连一种无毒的食品都吃不上，连一家安全的、正常的幼儿园都难找，连假疫苗的问题都解决不了，连丢失的孩子学生都找不到，还好意思说强大？ 连短途坐车都要实名，连买个炊具都要实名，连上网都要实名，连官方的微博都不敢放开评论 ，防民如防贼一般，还好意思说强大？ 连别人写两篇文字都怕，连别人发个微博也怕，连别人建了几十个人的闲聊群也怕，歌曲也怕，数字也怕，番樯也怕，不绝对的忠诚也怕，崇拜过头了也怕，歌颂不到点子上也怕，还好意思说强大？ 连这篇小短文都要急欲删除而后快，还好意思说强大？","link":"/2019/08/02/%E8%99%B9%E8%99%B9%E6%A2%A6%E8%9D%B6%EF%BC%9A%E5%BC%BA%E5%A4%A7%E7%9A%84%E7%A5%96%E5%9B%BD%20%E4%BD%A0%E5%88%B0%E5%BA%95%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F/"},{"title":"设计优雅API的一些经验要点总结","text":"设计优雅API的一些经验要点总结 如果尚未公开 Web API，则应立刻考虑公开。 设计优美的 Web API。 不用过分拘泥于 REST 一词。 最大限度地减少 API 版本的更新频率，注意向下兼容性。 在 URI 中嵌入 API 版本的主版本编号。 停止提供 API 服务时不能立刻终止，至少需要继续公开 6 个月。 最大程度地利用 HTTP 协议规范，最小程度地使用私有规范。 使用合适的状态码。 返回恰当的、尽可能通用的媒体类型。 返回便于客户端执行恰当的缓存的信息。 使用 JSON 或者和目的一致的数据格式。 不要进行不必要的封装。 响应数据尽可能使用扁平化结构。 各个数据的名称应简洁易懂，并恰当地使用单复数。 错误格式应统一，使客户端能够机械地理解错误的详细信息 设计容易记忆、功能一目了然的端点。 使用合适的 HTTP 方法。 选择合适的英语单词，注意单词的单复数形式。 使用 OAuth 2.0 进行认证。","link":"/2019/08/02/%E8%AE%BE%E8%AE%A1%E4%BC%98%E9%9B%85API%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93/"},{"title":"迟来的资料","text":"迟来的资料链接: https://pan.baidu.com/s/1rKSwvL-e_2vbrCS1uEh8Jg 密码: 5vh4 链接: https://pan.baidu.com/s/1chpPD5X-A4t7V_oOYjSUbg 密码: fveu 链接: https://pan.baidu.com/s/1p53tkFyi3im2vfpp2BEYIw 密码: 7bgn","link":"/2019/08/02/%E8%BF%9F%E6%9D%A5%E7%9A%84%E8%B5%84%E6%96%99/"},{"title":"适合创业团队的必备工具栈","text":"适合创业团队的必备工具栈 Ariel Diaz，Blissfully 的创始人兼 CEO，连续创业者。Blissfully 致力于为企业提供最优的 SaaS 解决方案，以及 IT 外包服务。本文由魏佳翻译。 创业公司是为了解决具体问题而建立的。所以我们应当把全部精力完全放在“如何去解决这个具体问题”上。 选择合适的软件或工具也是如此，如今各种优秀工具层出不穷，但重要的是如何快速得选择一些会让你事半功倍的软件或工具。 通过过去十年中创立多家公司的过程，我对于如何挑选“正确的”工具积累了很多的经验，本文是我对于这些工具的分享。 关键因素任何人在着手考虑软件或工具的选型时应当首先明确的第一个问题是：你到底希望解决或改进什么？这里面需要做出很多取舍和权衡，比如成本与功能，安全与速度，易用性以及集成能力。 成本 - 早期不要增加支出的负担。 速度 - 快速得配置和用起来，这样才能更专注业务本身的发展。 易用 - 没人希望在软件或工具本身的设置、部署或管理上花费时间和精力。 灵活 - 不用担心被绑定在某种工具上。 整合 - 各种工具之间应能集成起来。 生产力 - 最重要的，应能显著提高效率及生产力。 以下的内容就是围绕上述 6 点。 适合初创期的基础工具栈在组织刚建立初期，一切事情都需要快速且低成本得跑起来。 Google 套件：基本套餐每月每用户 $5（美元，下同）。这包括了电子邮件，文件共享，办公套件，简单的身份认证等功能。这基本覆盖了创业公司早期阶段的基本问题，如果您需要更强大丰富的功能，它也提供其他套餐。 Quickbooks Online：大约每月 $40。Quickbooks Online 为财务或会计角色提供了非常的棒的管理公司营收、开支等账务相关功能，而且价格低廉，非常易于使用。它与 Gusto 和其他许多工具都能无缝集成，同时它拥有非常活跃的开发者生态。 相比更专业全面的商业软件或解决方案，Quickbooks 是更灵活，更低成本的最佳选择。 Gusto：每 6 用户 $39。当需要向员工或外部承包商支付工资或酬劳时，就需要工资单。Gusto 就是这样的平台和工具，不仅如此，Gusto 上可以管理各种员工薪酬和福利，还能将完整的工资单数据同步到 Quickbook 中去，能自动缴纳州和联邦税费等。Gusto 还提供一整套基本且常用的公司信函模版，比如录用信，商业合同，律师函等。 Hubspot CRM：为了寻找完美的 CRM 系统，你可能需要花费非常多的时间。Salesforce 非常棒，同时差不多是行业标准了，但它是非常昂贵，最少需要签约 1 年。这就是为什么我们推荐 Hubspot CRM。首先它是免费的，易于使用，同时可以通过 Zaiper 去集成其他系统以实现自动化。 团队协作工具栈尽管 G Suite 中提供了团队协作的相关产品，但在这一领域，还有其他很多优秀的产品（比如以下推荐的三个产品），它们的免费套餐就提供了更加强大的功能，同时可以非常快速容易得上手。 Slack：基本是目前团队通讯平台的标杆产品。 免费套餐就能满足初创期团队的使用需求，同时具备非常强大的插件扩展及第三方集成的能力。 Zoom ：如果团队有视频或屏幕共享的需求，可以试试 Zoom。几乎没有任何限制的免费套餐，高素质的音／视频质量，广泛的跨平台支持等等。 Trello：提供可视化的、灵活的方式来组织管理项目和任务 ，既可以用来管理市场营销计划，也可以管理软件项目开发。对于初创团队来说，免费套餐就足够强大去组织和管理一个复杂的工作流程。 适合软件初创公司的工具栈如果你们团队正在打造软件产品，那就需要一套工具来帮助进行构建，测试，迭代等。下面这些工具在满足上文的六个属性之外，还具备其他强大的功能。 产品+工程方面 设计： Sketch + InvisionApp，Sketch 近些年快速成为业界标准的设计工具，它具备非常强大的矢量/位图混合模型，同时相对实惠的价格（$100 的单独许可，加上可选的每年 $69 的版本升级）。它还能和 InVision 等工具集成，帮助你更方便的协作和分享设计原型。 统计分析： ：Mixpanel + Google Analytics + Segment，通常产品发布前，就需要建立和数据收集统计和分析的基础设施。即使还没有多少数据需要来“分析”，建立基准也是有必要的。Google Analytics 是衡量网站流量和记录用户行为／事件的事实标准，但是除非设计并自定义了大量行为／事件，否则 Google Analytics 除了做简单得记录、统计和展示，并不能提供其他“有价值的洞察数据”。为了更深入地分析产品数据，Mixpanel 是个非常棒的选择，它内置了大量开箱即用的标准的工具。此外，Segment 能提供一种 single multiplexers，怎么理解呢，就是你可以编写一次用于 tracking 的代码，然后它能非常容易得自动与其他分析工具集成。 编码： GitHub，无须多言，代码管理事实标准。 托管： AWS，提供大量开箱即用的 PaaS 产品，再加上相对实惠的价格。 支付： Stripe，易于集成，易于管理，同时功能强大。 产品支持方面 产品／用户支持：Intercom，通常产品早期你并不需要一个全面的反馈及派单（feedback&amp;ticketing）系统来应对客户反馈及产品缺陷。Intercom 可以非常轻松地集成到网站或移动应用中，从而快速作出响应。 运营支撑方面 EShares：通常创业公司会向员工发行期权。但自己管理这件事十分繁琐和棘手，甚至可能引起法律层面的纠纷或麻烦。试试 EShares 吧，轻松管理期权授予和整个期权池规模，也能管理融资或财务相关的文书，先不要担心它的价格，长期来看是很合算和值得的。 Bill.com：如它的名字一样，它能帮你解决支票／发票等各种票据的所有事宜。把 PDF 形式的发票邮件转发给它，它会自动解析保存，并生成可快速付款的支付链接，一切就是这么简单。基本套餐 $39，帮你节省处理各种票据的时间，十分值得。 Zapier：Zapier 支持超过 750 种产品或平台的集成和自动化。它能帮你节约大量的时间，同时省去了直接与各种各样的系统和平台打交道，之后你也可以快速的切换。 适合成熟的创业公司：审计与合规SOC2 审计对于 SaaS 公司越来越普遍。相比自己动手来做一个，不如采用一些现成的解决方案，尽可能的节约时间，帮助你更专注于产品和业务，更迅速的迭代。 应用安全和单点登录：Okta ，首先 Okta 不是简单的密码管理器，它是一个身份和认证／鉴权管理器。将公司内各种应用、工具、平台的安全认证集中到一起，除此之外，还能记录和管理登录频率，登录位置等各种报告，所以它对于安全审计非常有用。Okta 是目前这类产品的领导者，对流行和成熟的各类产品可以一键集成。 MDM ：G Suite MDM，假设你已经在使用 G Suite，那么直接使用内置的 MDM 方便且免费。对于各类移动设备的访问控制都变得十分容易，通过简单的安装和注册，所有员工在手机上访问公司电子邮件和数据都可以得到管理和控制。如果设备丢失，MDM 也可帮助你最大程度地保护公司敏感数据的泄漏。 计算机资产与策略管理 ：JAMF，JAMF 提供 2 层产品，最基本的套餐只需要每设备每月 $2。你可以对所有的 MacBook 等资产进行集中管理和跟踪，包括密码保护，硬盘加密等关键安全策略。需要注意的是，JAMF 只是针对 Mac 产品系列，一般来说对于科技创业公司，Mac 产品更强大，更易于维护，所以最好的办法是尽早将计算机资产统一为 Mac 产品。 HRIS ：BambooHR，人力资源信息系统（HRIS）以前通常被认为是大型企业才需要的，但越来越多的轻量级、体验友好，同时便宜实惠的 HRIS 产品可以帮助中小企业更好得管理人员。可以跟踪员工入职，文书审批，政策通知和其他人力资源流程。BambooHR 是非常好的选择，价格相对便宜，易于与其他系统集成，内置大量标准功能，包括应聘者跟踪，入职清单，文件签名等。 文档：Quip ，安全性和合规性的关键之一是将内部流程文档化。因此，需要易于创建，编辑，共享和索引。Quip 是这类产品的优秀代表，比使用 Google 文档（过于简单）或 Google Sites / Wikis（体验不够简单直观）更好。 Blissfully 能帮助你什么如果你想跟踪已在使用的各种 SaaS 工具的使用状况，优化支出，提高安全性；或是了解其他初创公司使用了哪些 SaaS 产品，来 Blissfully 看看吧。 参考链接 G Suite https://gsuite.google.com/ Quickbooks https://quickbooks.intuit.com/ Gusto https://gusto.com/ HubSpot CRM www.hubspot.com/CRM Slack https://slack.com/ Zoom https://zoom.us/ Trello https://trello.com/ Sketch https://www.sketchapp.com/ InVision https://www.invisionapp.com/ Mixpanel https://mixpanel.com/ Segment https://segment.com/ Stripe https://stripe.com/ Intercom https://www.intercom.com EShare https://eshare.co.uk/ Bill.com https://www.bill.com/ Zapier https://zapier.com/ Okta https://www.okta.com/ MDM https://en.wikipedia.org/wiki/Mobile_device_management JAMF https://www.jamf.com/ BambooHR https://www.bamboohr.com/ Quip https://quip.com/ 适合创业团队的必备工具栈","link":"/2019/08/02/%E9%80%82%E5%90%88%E5%88%9B%E4%B8%9A%E5%9B%A2%E9%98%9F%E7%9A%84%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%E6%A0%88/"},{"title":"阿里巴巴1582.73亿背后的持续交付如何玩","text":"阿里巴巴1582.73亿背后的持续交付如何玩摘要： 北京时间2017年5月18日晚，阿里巴巴集团公布2017财年第四季度财报及2017财年全年业绩。财年第四季度，阿里巴巴集团收入同比增长60％，达到385.79亿元人民币；全年阿里巴巴集团收入为 1582.73 亿元人民币，同比增长56％。中国零售平台年度活跃买家增至4.54亿，移动端月度活跃用户高达5.07亿 在2017在线技术峰会——首届阿里巴巴研发效能嘉年华上，来自阿里研发效能事业部技术专家崔力强分享了《阿里巴巴1582.73亿背后的持续交付如何玩》。他详细介绍了阿里巴巴的企业级持续交付，从研发参与者的各个角色解析阿里持续交付的流程和环节，并对RDC的理念进行了解析。以下内容根据直播视频整理而成。 直播视频：https://yq.aliyun.com/edu/lesson/547 PDF下载：https://yq.aliyun.com/attachment/download/?id=1840 持续交付的目标新的业务需要新的应用来承载，所以我们希望能够快速上线新的应用。有了代码之后，希望其构建过程是标准的，不需要针对每个环境、应用再去调构建过程。 当应用上线之后，需要有新的功能来迭代，功能被提出来之后希望能够快速高效的完成，并且可以在各个环境中进行验证，最后可以一键发布到线上。 阿里巴巴的企业级持续交付最开始，阿里巴巴也是使用开源套件的，比如Jenkins，但是逐渐难以满足需求：不能满足如此大的规模，资源管理、持续交付在运维的过程中使用Jenkins很难串起来，使用开源套件难以和现有的系统有机结合。 所以，研发了自研平台，今年将这套体系推到阿里云上供阿里云的用户使用。RDC和内部平台的核心是一致的，不同的是内部平台有自己的机房，有自己的资源管理方式。但是上云之后，数据库、负载均衡等基础设施都会使用阿里云上的。 持续交付中有三种角色：开发人员，把需求实现，保证其可以交付上线；开发负责人，团队建设，保证团队在指定时间内完成高优先级的任务；运维人员，负责发布和运维。 开发人员：日常开发feature开发人员开发一个新的feature需要上图所示的工作。首先需要拉分支来开发新的功能，然后为分支配置持续集成，开发测试完成之后需要合入集成分支。此时需要从主干分支拉取release分支出来，把需要合并的一个或者多个分支合并进入。解决冲突的过程中需要对集成分支上部署的版本进行测试，需要为新的分支创建集成分支的配置。 测试完成后使用集成分支进行发布到预发环境、线上。最后，再将其合并回主干。 实际上，开发人员需要花时间做的只有开发测试和在集成分支上测试，上图中除了这两个步骤，其他步骤都是可以自动化完成的。这样流程的好处是能够灵活掌握开发节奏。 分支模式不是真正的数据集成，因为一定要等到所有的东西都集成到一个分支之后才知道是不是可行。 即使在一个fetch分支上测试好也不代表集成分支上也能工作。 主干模式是指随时想做任何变动，则调用某个方法的所有地方都需要做一个改变，主干模式做这件事情比较简单，结果可以立即看出，而分支模式则需要集成之后才知道结果。 RDC提供了自由模式（一种主干模式）、分支模式、Git flow模式（所有的用户都在develop分支上开发，进入之前需要code review来实现）。自由模式和develop模式有几个环节：版本制作、日常、预发、灰度。日常和预发之间有一个按钮用于在制作好之后预发布。 开发人员：可怕的发布首先，我们需要有充分的测试，包括单元测试、API测试、阶段检查。此外，发明了另外一种测试方法，截取线上的一部分流量进行存储，在预发环境进行回放，看结果是否一致。人工的代码review更多涉及到代码架构，所以希望每次的代码提交都能经过代码review过程。灵活的发布工具也很重要，规模小的时候怎么发布都可以，但是当规模比较大时灵活发布很重要。发布方式目前支持分批发布，分布策略可以根据分组、机房来分。发布一定要是可靠的，一定是可重复的，一个包发100次一定是同样的结果。如果发布之后发现线上有问题，则需要回滚代码，只需要把发了的部分进行回滚即可。回滚包括发布中回滚和发布后回滚。所有的过程一定要减少人为的介入，让这些都自动化的发生，所以希望有一个流程和卡点，如果不满足此刻要求就不能继续往下走。发布的问题总结来说：使用单元测试，功能测试，接口测试等多层保护；通过系统卡点的方式保证上述测试真的被执行，且真正有效；提供灵活，可靠的发布方案；提供灵活，可靠的回滚方案；使用和线上的环境进行测试（预发）。 开发人员：定位问题定位问题花费的时间往往比编码还要多，问题可能出现在测试环境，也可能出现在线上。线上版本和上次发布之间有哪些变化？这些都要考虑清楚才能进一步定位问题。平台有统一的流程将这些问题记录下来：创建分支，提交集成区，提交发布。在这样整个标准的变更流程中，会把很多信息记录下来。上图中的列表是一个发布的列表，包括发布内容、发布结果、操作人、版本详情等内容。所有信息都可以帮助追溯之前发生的事情，并且进行问题解决。 运维人员：线上变更充满危险最初的时候采用了脚本批量执行，后来使用了声明式的基线管理，但是还是难以避免线上的基线被人手工篡改，而且不能保证基线变更失败后如何处理。2016年开始，阿里使用Docker容器镜像，问题变得迎刃而解，因为每次部署的都是新的镜像，环境保证一模一样。Docker化基础设施是在阿里内部的，而RDC在阿里云上怎么办？我们会去对接阿里云上的基础设施、已有服务，使用其整个服务来对接前面RDC的研发。RDC发源于阿里内部，扎根于阿里云，后面所有的生态建设都会围绕阿里云已有的生态来建设。 上图中，企业入驻RDC企业级研发协同平台后就可以享受整个阿里云的基础设施。EDAS也是阿里云正在做的事情，ECS、SLB等资源也可以通过RDC进行整合。RDC是一个SaaS产品，不是私有云产品。由于没有部署到机房里，所以它可能访问不到VPC里面的机器，但是有时却有这样的需求。有时需要做预发、API测试，这些需要在公网里进行，但是公网却没有访问权限。目前的一个可行方案是，可以通过代理享受更多的服务。上图中蓝色部分是已经发布上线的。构建和发布目前是基于关联ECS并且自定义脚本的方式来发布。EDAS和容器正在对接。这样，开发过程的角色会有一定的转变。企业的现状是，有开发会做本地、测试环境的编码和日常测试，有专门的测试在QA环境进行功能验证，有运维去专门管理staging环境和正式环境。 DevOps是开发自运维，运维人员做好了很好的平台，开发可以进行测试，可以从发布流水线收到反馈，自己去编写测试用例，做新应用的发布上线，做日常功能的开发、线上变更、扩容缩容、线上故障处理。 总结RDC的理念是自动化一切可以自动化的事情，提供尽量多的模式，有安全、灵活的发布流程，使用工具流程来保证开发团队按照最佳实践工作，对开发过程的数据提供足够的可追溯性，依托阿里云基础设施，助力企业的Devops。 （来源：云栖社区 https://yq.aliyun.com/articles/118713）","link":"/2019/08/02/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B41582.73%E4%BA%BF%E8%83%8C%E5%90%8E%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E5%A6%82%E4%BD%95%E7%8E%A9/"},{"title":"领域建模DDD","text":"领域建模DDDDDD切入点1 - 理解概念概念总结 领域就是问题域，有边界，领域中有很多问题； 任何一个系统要解决的那个大问题都对应一个领域； 通过建立领域模型来解决领域中的核心问题，模型驱动的思想； 领域建模的目标针对我们在领域中所关心的问题，即只针对核心关注点，而不是整个领域中的所有问题； 领域模型在设计时应考虑一定的抽象性、通用性，以及复用价值； 通过领域模型驱动代码的实现，确保代码让领域模型落地，代码最终能解决问题； 领域模型是系统的核心，是领域内的业务的直接沉淀，具有非常大的业务价值； 技术架构设计或数据存储等是在领域模型的外围，帮助领域模型进行落地； DDD切入点2 - 理解领域、拆分领域、细化领域拆分领域按业务功能出发点拆分领域 **电商系统** * 会员中心：负责用户账号登录、用户信息的管理； * 商品中心：负责商品的展示、导航、维护； * 订单中心：负责订单的生成和生命周期管理； * 交易中心：负责交易相关的业务； * 库存中心：负责维护商品的库存； * 促销中心：负责各种促销活动的支持； 上面这些中心看起来很自然，因为大家对电子商务的这个领域都已经非常熟悉了，所以都没什么疑问，好像很自然的样子。所以，领域划分是不是就是没什么挑战了呢？显然不是。之所以我们觉得子域划分很简单，是因为我们对整个大领域非常了解了。如果我们遇到一个冷门的领域，就没办法这么容易的去划分子域了。这就需要我们先去努力理解领域内的知识。所以，我个人从来不相信什么子域划分的技巧什么的东西，因为我觉得这个工作没有任何诀窍可以使用。当我们不了解一个东西的时候，如何去拆解它？当我们对整个领域有一定的熟悉了，了解了领域内的相关业务的本质和关系，我们就自然而然的能划分出合理的子域了。不过并不是所有的系统都需要划分子域的，有些系统只是解决一个小问题，这个问题不复杂，可能只有一两个核心概念。所以，这种系统完全不需要再划分子域。但不是绝对的，当一个领域，我们的关注点越来越多，每个关注点我们关注的信息越来越多的时候，我们会不由自主的去进一步的划分子域。比如，也许我们一开始将商品和商品的库存都放在商品中心里，但是后来由于库存的维护越来越复杂，导致揉在一起对我们的系统维护带来一定的困难时，我们就会考虑将两者进行拆分，这个就是所谓的业务垂直分割。 细化领域1. 梳理领域概念：梳理出领域内我们关注的概念、概念的关系，并统一交流词汇，形成统一语言； 2. 梳理业务规则：梳理出领域内我们关注的各种业务规则，DDD中叫不变性（invariants），比如唯一性规则，余额不能小于零等； 3. 梳理业务场景：梳理出领域内的核心业务场景，比如电商平台中的加入购物车、提交订单、发起付款等核心业务场景； 4. 梳理业务流程：梳理出领域内的关键业务流程，比如订单处理流程，退款流程等；DDD切入点3 - 领域模型设计领域建模的方法1. 划分好边界上下文，通常每个子域（sub domain）对应一个边界上下文（bounded context），同一个边界上下文中的概念是明确的，没有任何歧义； 2. 在每个边界上下文中设计领域模型，具体的领域模型设计方法有很多种，如以场景为出发点的 [四色原型](http://www.cnblogs.com/netfocus/archive/2011/03/05/1971899.html) 分析法，或者我早期写的这篇 [文章](http://www.cnblogs.com/netfocus/archive/2011/09/18/2180656.html) ；这个步骤最核心的就是找出聚合根，并找出每个聚合根包含的信息；关于如何设计聚合，可以看一下我写的 [这篇文章](http://www.cnblogs.com/netfocus/p/3307971.html) ； 3. 画出领域模型图，圈出每个模型中的聚合边界； 4. 设计领域模型时，要考虑该领域模型是否满足业务规则，同时还要综合考虑技术实现等问题，比如并发问题；领域模型不是概念模型，概念模型不关注技术实现，领域模型关心；所以领域模型才能直接指导编码实现； 5. 思考领域模型是如何在业务场景中发挥作用的，以及是如何参与到业务流程的每个环节的； 6. 场景走查，确认领域模型是否能满足领域中的业务场景和业务流程； 7. 模型持续重构、完善、精炼；","link":"/2019/08/02/%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1DDD/"},{"title":"领域驱动设计战略","text":"领域驱动设计-战略 领域驱动设计过程 战略设计阶段 问题域 针对问题域，引入限界上下文（Bounded Context）和上下文映射（Context Map）对问题域进行合理的分解，识别出核心领域（Core Domain）与子领域（SubDomain），并确定领域的边界以及它们之间的关系，维持模型的完整性。 架构 通过分层架构来隔离关注点，尤其是将领域实现独立出来，能够更利于领域模型的单一性与稳定性； 引入六边形架构可以清晰地表达领域与技术基础设施的边界； CQRS 模式则分离了查询场景和命令场景，针对不同场景选择使用同步或异步操作，来提高架构的低延迟性与高并发能力。 战术设计阶段 领域驱动设计用以表示模型的主要要素包括： 值对象（Value Object） 实体（Entity） 领域服务（Domain Service） 领域事件（Domain Event） 资源库（Repository） 工厂（Factory） 聚合（Aggregate） 应用服务（Application Service） 领域驱动设计围绕着领域模型进行设计，通过分层架构（Layered Architecture）将领域独立出来。 表示领域模型的对象包括：实体、值对象和领域服务，领域逻辑都应该封装在这些对象中。 在领域驱动设计的演进中，又引入了领域事件来丰富领域模型。 聚合是一种边界，它可以封装一到多个实体与值对象，并维持该边界范围之内的业务完整性。 在聚合中，至少包含一个实体，且只有实体才能作为聚合根（Aggregate Root）。 工厂和资源库都是对领域对象生命周期的管理。 工厂负责领域对象的创建，往往用于封装复杂或者可能变化的创建逻辑； 资源库负责从存放资源的位置（数据库、内存或者其他 Web 资源）获取、添加、删除或者修改领域对象。领域模型中的资源库不应该暴露访问领域对象的技术实现细节。 演进的领域驱动设计过程","link":"/2019/08/02/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%88%98%E7%95%A5/"},{"title":"高并发架构 - Redis","text":"高并发架构 - Redis 支撑10万Qps的架构Redis replication -&gt; Redis主从架构 -&gt; 读写分离架构 -&gt; 支持水平扩展的读高并发架构 复制原理异步复制master生成一份rdb快照 并且将新数据备份到内存 rdb快照同步给slave slave持久化到磁盘，同步完之后发送内存中数据给slave 断点续传 backlog 压测redis自带benchmark工具","link":"/2019/08/02/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84%20-%20Redis/"},{"title":"高学历家长和低学历家长在教育孩子方面有哪些差别？","text":"高学历家长和低学历家长在教育孩子方面有哪些差别？提供些数据支持。Pew Research Center 在2015年对近2000名美国学龄儿童家长进了调查。调查发现：高学历父母对子女教育的参与度更高。他们注意培养子女的兴趣爱好（如：芭蕾、足球等），投入大量时间教孩子阅读，并更关心孩子的心理健康。同时，他们采取更温和的教育方式，较少体罚孩子。 特别需要注意的是，高学历家长往往同时收入水平较高，其中白人家庭、双亲家庭比例更大。所以这些数据同时也反映了家庭资源和教育观念的差异，不要过分解读。 以下是具体调查结果。 体罚行为 在接受调查的高学历（研究生以上）家庭中，只有8%偶尔或有时体罚孩子，低学历（高中或以下），22%偶尔或有时体罚孩子。 课外活动 调查发现，在过去12个月里，高收入家庭（家庭年收入75000美元以上）中，84%孩子曾参加集体体育项目，64%参与志愿公益活动，62%曾接受音乐、舞蹈或艺术方面的培训。低收入（家庭年薪低于30000美元）家庭中，以上三项数据分别是59%， 37%，41%。 教育焦虑 白人家长最关注的孩子的焦虑、抑郁情绪（58% v.s 35%），而黑人家长最担心的是孩子的人身安全问题（校园暴力、枪支）（39% v.s 22%）。 对邻里环境的评价 高收入家庭（家庭年收入75000美元以上）中，78%被访家长认为他们的邻里环境非常适宜孩子成长，而低收入家庭（家庭年收入30000美元以下）中，该数据只有42%。 更新： 针对评论/私信中提到的问题一并回复如下 “为什么不控制父母收入这个变量呢？” 简单来讲，我们要考察x变量（父母教育程度）对y变量（教育子女方式）的影响， 而相对x变量，z变量（父母收入）是个内生变量，因而无法从根本上加以控制。 在这种情况下，我们解读“x对y的影响”时，应该明确这种影响包含x通过z对y的间接影响，即，x不是孤立于z存在的。 至于为什么控制内生变量是不可取的，感兴趣的读者可参考Angrist &amp; Pischke 的书 Mostly Harmless Econometrics中的相关分析，因涉及一些计量方法上的技术细节，这里不做赘述。 图片/数据来源： “Parenting in America: Outlook, worries, aspirations are strongly linked to financial situation” (Pew Research Center, 2015). 高学历家长和低学历家长在教育孩子方面有哪些差别？","link":"/2019/08/02/%E9%AB%98%E5%AD%A6%E5%8E%86%E5%AE%B6%E9%95%BF%E5%92%8C%E4%BD%8E%E5%AD%A6%E5%8E%86%E5%AE%B6%E9%95%BF%E5%9C%A8%E6%95%99%E8%82%B2%E5%AD%A9%E5%AD%90%E6%96%B9%E9%9D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B7%AE%E5%88%AB%EF%BC%9F/"},{"title":"高性能","text":"高性能 1、高性能的网络和硬件 CDN 带宽 服务器性能 硬件负载均衡 2、后台服务高性能设计 分布式缓存 服务分层 消息队列 服务拆分 分布式集群 代码、数据库优化","link":"/2019/08/02/%E9%AB%98%E6%80%A7%E8%83%BD/"},{"title":"高并发电商问题","text":"高并发电商问题1、亿级流量电商网站的商品详情页系统架构 面临难题：对于每天上亿流量，拥有上亿页面的大型电商网站来说，能够支撑高并发访问，同时能够秒级让最新模板生效的商品详情页系统的架构是如何设计的？ 解决方案：异步多级缓存架构+nginx本地化缓存+动态模板渲染的架构 2、redis企业级集群架构 面临难题：如何让redis集群支撑几十万QPS高并发+99.99%高可用+TB级海量数据+企业级数据备份与恢复？ 解决方案：redis的企业级备份恢复方案+复制架构+读写分离+哨兵架构+redis cluster集群部署 3、多级缓存架构设计 面临难题：如何将缓存架构设计的能够支撑高性能以及高并发到极致？同时还要给缓存架构最后的一个安全保护层？ 解决方案：nginx抗热点数据+redis抗大规模离线请求+ehcache抗redis崩溃的三级缓存架构 4、数据库+缓存双写一致性解决方案 面临难题：高并发场景下，如何解决数据库与缓存双写的时候数据不一致的情况？ 解决方案：异步队列串行化的数据库+缓存双写一致性解决方案 5、缓存维度化拆分解决方案 面临难题：如何解决大value缓存的全量更新效率低下问题？ 解决方案：商品缓存数据的维度化拆分解决方案 6、缓存命中率提升解决方案 面临难题：如何将缓存命中率提升到极致？ 解决方案：双层nginx部署架构+lua脚本实现一致性hash流量分发策略 7、缓存并发重建冲突解决方案 面临难题：如何解决高并发场景下，缓存重建时的分布式并发重建的冲突问题？ 解决方案：基于zookeeper分布式锁的缓存并发重建冲突解决方案 8、缓存预热解决方案 面临难题：如何解决高并发场景下，缓存冷启动导致MySQL负载过高，甚至瞬间被打死的问题？ 解决方案：基于storm实时统计热数据的分布式快速缓存预热解决方案 9、热点缓存自动降级方案 面临难题：如何解决热点缓存导致单机器负载瞬间超高？ 解决方案：基于storm的实时热点发现+毫秒级的实时热点缓存负载均衡降级 10、高可用分布式系统架构设计 面临难题：如何解决分布式系统中的服务高可用问题？避免多层服务依赖因为少量故障导致系统崩溃？ 解决方案：基于hystrix的高可用缓存服务，资源隔离+限流+降级+熔断+超时控制 11、复杂的高可用分布式系统架构设计 面临难题：如何针对复杂的分布式系统将其中的服务设计为高可用架构？ 解决方案：基于hystrix的容错+多级降级+手动降级+生产环境参数优化经验+可视化运维与监控 12、缓存雪崩解决方案 面临难题：如何解决恐怖的缓存雪崩问题？避免给公司带来巨大的经济损失？ 解决方案：全网独家的事前+事中+事后三层次完美缓存雪崩解决方案 13、缓存穿透解决方案 面临难题：如何解决高并发场景下的缓存穿透问题？避免给MySQL带来过大的压力？ 解决方案：缓存穿透解决方案 14、缓存失效解决方案 面临难题：如何解决高并发场景下的缓存失效问题？避免给redis集群带来过大的压力？ 解决方案：基于随机过期时间的缓存失效解决方案 硬件规划 每日上亿流量，高峰QPS过1万 nginx部署，负载很重，16核32G，建议给3~5台以上，就非常充裕了，每台抗个几千QPS 缓存服务部署，4核8G，按照每台QPS支撑500，部署个10~20台 redis部署，每台给8核16G，根据数据量以及并发读写能力来看，部署5~10个master，每个master挂一个slave，主要是为了支撑更多数据量，1万并发读写肯定没问题了","link":"/2019/08/02/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%94%B5%E5%95%86%E9%97%AE%E9%A2%98/"},{"title":"高性能网络 | 你所不知道的TIME_WAIT和CLOSE_WAIT","text":"高性能网络 | 你所不知道的TIME_WAIT和CLOSE_WAIT 本文是我将最近两篇文章，重新整理成一篇，方便收藏。如果你已经阅读过前两篇，并且已经做了收藏，可以重新收藏本文即可。 你有收藏和整理文章的习惯吗？好好利用Evernote或者印象笔记，不要吝啬那点年费，你值得购买，并养成收藏和整理的习惯！ 本文源于大家在公众号里面的留言，既然很多人都搞不清楚TIME_WAIT和CLOSE_WAIT，那么小胖哥今天还是抽个时间，统一帮大家理理概念吧。 你遇到过TIME_WAIT的问题吗？ 我相信很多都遇到过这个问题。一旦有用户在喊：网络变慢了。第一件事情就是，netstat -a | grep TIME_WAIT | wc -l 一下。哎呀妈呀，几千个TIME_WAIT. 然后，做的第一件事情就是：打开Google或者Bing，输入关键词：too many time wait。一定能找到解决方案，而排在最前面或者被很多人到处转载的解决方案一定是： 打开 sysctl.conf 文件，修改以下几个参数： net.ipv4.tcp_tw_recycle = 1 net.ipv4.tcp_tw_reuse = 1 net.ipv4.tcp_timestamps = 1 你也会被告知，开启tw_recylce和tw_reuse一定需要timestamps的支持，而且这些配置一般不建议开启，但是对解决TIME_WAIT很多的问题，有很好的用处。 接下来，你就直接修改了这几个参数，reload一下，发现，咦，没几分钟，TIME_WAIT的数量真的降低了，也没发现哪个用户说有问题，然后就没有然后了。 做到这一步，相信50%或者更高比例的开发就已经止步了。问题好像解决了，但是，要彻底理解并解决这个问题，可能就没这么简单，或者说，还有很长的路要走！ 什么是TIME-WAIT和CLOSE-WAIT? 所谓，要解决问题，就要先理解问题。随便改两行代码，发现bug“没有了”，也不是bug真的没有了，只是隐藏在更深的地方，你没有发现，或者以你的知识水平，你无法发现而已。 大家知道，由于socket是全双工的工作模式，一个socket的关闭，是需要四次握手来完成的。 主动关闭连接的一方，调用close()； 协议层发送FIN包 被动关闭的一方收到FIN包后，协议层回复ACK ；然后 被动关闭的一方，进入CLOSE_WAIT状态， 主动关闭的一方等待对方关闭，则进入FIN_WAIT_2状态；此时，主动关闭的一方 等待 被动关闭一方的应用程序，调用close操作 被动关闭的一方在完成所有数据发送后，调用close()操作；此时， 协议层发送FIN包给主动关闭的一方，等待对方的ACK，被动关闭的一方进入LAST_ACK状态 ； 主动关闭的一方收到FIN包，协议层回复ACK ；此时， 主动关闭连接的一方，进入TIME_WAIT状态；而被动关闭的一方，进入CLOSED状态 等待2MSL时间，主动关闭的一方，结束TIME_WAIT，进入CLOSED状态 通过上面的一次socket关闭操作，你可以得出以下几点： 主动关闭连接的一方 - 也就是主动调用socket的close操作的一方，最终会进入TIME_WAIT状态 被动关闭连接的一方，有一个中间状态，即CLOSE_WAIT，因为协议层在等待上层的应用程序，主动调用close操作后才主动关闭这条连接 TIME_WAIT会默认等待2MSL时间后，才最终进入CLOSED状态； 在一个连接没有进入CLOSED状态之前，这个连接是不能被重用的！ 所以，这里凭你的直觉，TIME_WAIT并不可怕（not really，后面讲），CLOSE_WAIT才可怕，因为CLOSE_WAIT很多，表示说要么是你的应用程序写的有问题，没有合适的关闭socket；要么是说，你的服务器CPU处理不过来（CPU太忙）或者你的应用程序一直睡眠到其它地方(锁，或者文件I/O等等)，你的应用程序获得不到合适的调度时间，造成你的程序没法真正的执行close操作。 这里又出现两个问题： 上文提到的连接重用，那连接到底是个什么概念？ 协议层为什么要设计一个TIME_WAIT状态？这个状态为什么默认等待2MSL时间才会进入CLOSED 先解释清楚这两个问题，我们再来看，开头提到的几个网络配置究竟有什么用，以及TIME_WAIT的后遗症问题。 Socket连接到底是个什么概念？ 大家经常提socket，那么，到底什么是一个socket？其实，socket就是一个 五元组，包括： 源IP 源端口 目的IP 目的端口 类型：TCP or UDP 这个五元组，即标识了一条可用的连接。注意，有很多人把一个socket定义成四元组，也就是 源IP:源端口 + 目的IP:目的端口，这个定义是不正确的。 例如，如果你的本地出口IP是180.172.35.150，那么你的浏览器在连接某一个Web服务器，例如百度的时候，这条socket连接的四元组可能就是： [180.172.35.150:45678, tcp, 180.97.33.108:80] 源IP为你的出口IP地址 180.172.35.150，源端口为随机端口 45678，目的IP为百度的某一个负载均衡服务器IP 180.97.33.108，端口为HTTP标准的80端口。 如果这个时候，你再开一个浏览器，访问百度，将会产生一条新的连接： [180.172.35.150:43678, tcp, 180.97.33.108:80] 这条新的连接的源端口为一个新的随机端口 43678。 如此来看，如果你的本机需要压测百度，那么，你最多可以创建多少个连接呢？我在文章《云思路 | 轻松构建千万级投票系统》里也稍微提过这个问题，没有阅读过本文的，可以发送“投票系统”阅读。 第二个问题，TIME_WAIT有什么用？ 如果我们来做个类比的话，TIME_WAIT的出现，对应的是你的程序里的异常处理，它的出现，就是为了解决网络的丢包和网络不稳定所带来的其他问题： 第一，防止前一个连接【五元组，我们继续以 180.172.35.150:45678, tcp, 180.97.33.108:80 为例】上延迟的数据包或者丢失重传的数据包，被后面复用的连接【前一个连接关闭后，此时你再次访问百度，新的连接可能还是由180.172.35.150:45678, tcp, 180.97.33.108:80 这个五元组来表示，也就是源端口凑巧还是45678】错误的接收（异常：数据丢了，或者传输太慢了），参见下图： SEQ=3的数据包丢失，重传第一次，没有得到ACK确认 如果没有TIME_WAIT，或者TIME_WAIT时间非常端，那么关闭的连接【180.172.35.150:45678, tcp, 180.97.33.108:80 的状态变为了CLOSED，源端口可被再次利用】，马上被重用【对180.97.33.108:80新建的连接，复用了之前的随机端口45678】，并连续发送SEQ=1,2 的数据包 此时，前面的连接上的SEQ=3的数据包再次重传，同时，seq的序号刚好也是3（这个很重要，不然，SEQ的序号对不上，就会RST掉），此时，前面一个连接上的数据被后面的一个连接错误的接收 第二，确保连接方能在时间范围内，关闭自己的连接。其实，也是因为丢包造成的，参见下图： 主动关闭方关闭了连接，发送了FIN； 被动关闭方回复ACK同时也执行关闭动作，发送FIN包；此时，被动关闭的一方进入LAST_ACK状态 主动关闭的一方回去了ACK，主动关闭一方进入TIME_WAIT状态； 但是最后的ACK丢失，被动关闭的一方还继续停留在LAST_ACK状态 此时，如果没有TIME_WAIT的存在，或者说，停留在TIME_WAIT上的时间很短，则主动关闭的一方很快就进入了CLOSED状态，也即是说，如果此时新建一个连接，源随机端口如果被复用，在connect发送SYN包后，由于被动方仍认为这条连接【五元组】还在等待ACK，但是却收到了SYN，则被动方会回复RST 造成主动创建连接的一方，由于收到了RST，则连接无法成功 所以，你看到了，TIME_WAIT的存在是很重要的，如果强制忽略TIME_WAIT，还是有很高的机率，造成数据粗乱，或者短暂性的连接失败。 那么，为什么说，TIME_WAIT状态会是持续2MSL（2倍的max segment lifetime）呢？这个时间可以通过修改内核参数调整吗？第一，这个2MSL，是RFC 793里定义的，参见RFC的截图标红的部分： 这个定义，更多的是一种保障（IP数据包里的TTL，即数据最多存活的跳数，真正反应的才是数据在网络上的存活时间），确保最后丢失了ACK，被动关闭的一方再次重发FIN并等待回复的ACK，一来一去两个来回。内核里，写死了这个MSL的时间为：30秒（有读者提醒，RFC里建议的MSL其实是2分钟，但是很多实现都是30秒），所以TIME_WAIT的即为1分钟： 所以，再次回想一下前面的问题，如果一条连接，即使在四次握手关闭了，由于TIME_WAIT的存在，这个连接，在1分钟之内，也无法再次被复用，那么，如果你用一台机器做压测的客户端，你一分钟能发送多少并发连接请求？如果这台是一个负载均衡服务器，一台负载均衡服务器，一分钟可以有多少个连接同时访问后端的服务器呢？ TIME_WAIT很多，可怕吗？ 如果你通过 ss -tan state time-wait | wc -l 发现，系统中有很多TIME_WAIT，很多人都会紧张。多少算多呢？几百几千？如果是这个量级，其实真的没必要紧张。第一，这个量级，因为TIME_WAIT所占用的内存很少很少；因为记录和寻找可用的local port所消耗的CPU也基本可以忽略。 会占用内存吗？当然 ！ 任何你可以看到的数据，内核里都需要有相关的数据结构来保存这个数据啊。一条Socket处于TIME_WAIT状态，它也是一条“存在”的socket，内核里也需要有保持它的数据： 内核里有保存所有连接的一个hash table，这个hash table里面既包含TIME_WAIT状态的连接，也包含其他状态的连接。主要用于有新的数据到来的时候，从这个hash table里快速找到这条连接。不同的内核对这个hash table的大小设置不同，你可以通过dmesg命令去找到你的内核设置的大小： 还有一个hash table用来保存所有的bound ports，主要用于可以快速的找到一个可用的端口或者随机端口： 由于内核需要保存这些数据，必然，会占用一定的内存。 会消耗CPU吗？ 当然！ 每次找到一个随机端口，还是需要遍历一遍bound ports的吧，这必然需要一些CPU时间。 TIME_WAIT很多，既占内存又消耗CPU，这也是为什么很多人，看到TIME_WAIT很多，就蠢蠢欲动的想去干掉他们。其实，如果你再进一步去研究，1万条TIME_WAIT的连接，也就多消耗1M左右的内存，对现代的很多服务器，已经不算什么了。至于CPU，能减少它当然更好，但是不至于因为1万多个hash item就担忧。如果，你真的想去调优，还是需要搞清楚别人的调优建议，以及调优参数背后的意义！ TIME_WAIT调优，你必须理解的几个调优参数 在具体的图例之前，我们还是先解析一下相关的几个参数存在的意义。 net.ipv4.tcp_timestamps RFC 1323 在 TCP Reliability一节里，引入了timestamp的TCP option，两个4字节的时间戳字段，其中第一个4字节字段用来保存发送该数据包的时间，第二个4字节字段用来保存最近一次接收对方发送到数据的时间。有了这两个时间字段，也就有了后续优化的余地。 tcp_tw_reuse 和 tcp_tw_recycle就依赖这些时间字段。net.ipv4.tcp_tw_reuse 字面意思，reuse TIME_WAIT状态的连接。 时刻记住一条socket连接，就是那个五元组，出现TIME_WAIT状态的连接，一定出现在主动关闭连接的一方。所以，当主动关闭连接的一方，再次向对方发起连接请求的时候（例如，客户端关闭连接，客户端再次连接服务端，此时可以复用了；负载均衡服务器，主动关闭后端的连接，当有新的HTTP请求，负载均衡服务器再次连接后端服务器，此时也可以复用），可以复用TIME_WAIT状态的连接。 通过字面解释，以及例子说明，你看到了，tcp_tw_reuse应用的场景：某一方，需要不断的通过“短连接”连接其他服务器，总是自己先关闭连接(TIME_WAIT在自己这方)，关闭后又不断的重新连接对方。 那么，当连接被复用了之后，延迟或者重发的数据包到达，新的连接怎么判断，到达的数据是属于复用后的连接，还是复用前的连接呢？那就需要依赖前面提到的两个时间字段了。复用连接后，这条连接的时间被更新为当前的时间，当延迟的数据达到，延迟数据的时间是小于新连接的时间，所以，内核可以通过时间判断出，延迟的数据可以安全的丢弃掉了。 这个配置，依赖于连接双方，同时对timestamps的支持。同时，这个配置，仅仅影响outbound连接，即做为客户端的角色，连接服务端[connect(dest_ip, dest_port)]时复用TIME_WAIT的socket。 net.ipv4.tcp_tw_recycle 字面意思，销毁掉 TIME_WAIT。 当开启了这个配置后，内核会快速的回收处于TIME_WAIT状态的socket连接。多快？不再是2MSL，而是一个RTO（retransmission timeout，数据包重传的timeout时间）的时间，这个时间根据RTT动态计算出来，但是远小于2MSL。 有了这个配置，还是需要保障 丢失重传或者延迟的数据包，不会被新的连接(注意，这里不再是复用了，而是之前处于TIME_WAIT状态的连接已经被destroy掉了，新的连接，刚好是和某一个被destroy掉的连接使用了相同的五元组而已)所错误的接收。在启用该配置，当一个socket连接进入TIME_WAIT状态后，内核里会记录包括该socket连接对应的五元组中的对方IP等在内的一些统计数据，当然也包括从该对方IP所接收到的最近的一次数据包时间。当有新的数据包到达，只要时间晚于内核记录的这个时间，数据包都会被统统的丢掉。 这个配置，依赖于连接双方对timestamps的支持。同时，这个配置，主要影响到了inbound的连接（对outbound的连接也有影响，但是不是复用），即做为服务端角色，客户端连进来，服务端主动关闭了连接，TIME_WAIT状态的socket处于服务端，服务端快速的回收该状态的连接。 由此，如果客户端处于NAT的网络(多个客户端，同一个IP出口的网络环境)，如果配置了tw_recycle，就可能在一个RTO的时间内，只能有一个客户端和自己连接成功(不同的客户端发包的时间不一致，造成服务端直接把数据包丢弃掉)。 我尽量尝试用文字解释清楚，但是，来点案例和图示，应该有助于我们彻底理解。 我们来看这样一个网络情况： 客户端IP地址为：180.172.35.150，我们可以认为是浏览器 负载均衡有两个IP，外网IP地址为 115.29.253.156，内网地址为10.162.74.10；外网地址监听80端口 负载均衡背后有两台Web服务器，一台IP地址为 10.162.74.43，监听80端口；另一台为 10.162.74.44，监听 80 端口 Web服务器会连接数据服务器，IP地址为 10.162.74.45，监听 3306 端口 这种简单的架构下，我们来看看，在不同的情况下，我们今天谈论的tw_reuse/tw_recycle对网络连接的影响。 先做个假定： 客户端通过HTTP/1.1连接负载均衡，也就是说，HTTP协议投Connection为keep-alive，所以我们假定，客户端 对 负载均衡服务器 的socket连接，客户端会断开连接，所以，TIME_WAIT出现在客户端 Web服务器和MySQL服务器的连接，我们假定，Web服务器上的程序在连接结束的时候，调用close操作关闭socket资源连接，所以，TIME_WAIT出现在 Web 服务器端。 那么，在这种假定下： Web服务器上，肯定可以配置开启的配置：tcp_tw_reuse；如果Web服务器有很多连向DB服务器的连接，可以保证socket连接的复用。 那么，负载均衡服务器和Web服务器，谁先关闭连接，则决定了我们怎么配置tcp_tw_reuse/tcp_tw_recycle了 方案一：负载均衡服务器 首先关闭连接 在这种情况下，因为负载均衡服务器对Web服务器的连接，TIME_WAIT大都出现在负载均衡服务器上，所以，在负载均衡服务器上的配置： net.ipv4.tcp_tw_reuse = 1 //尽量复用连接 net.ipv4.tcp_tw_recycle = 0 //不能保证客户端不在NAT的网络啊 在Web服务器上的配置为： net.ipv4.tcp_tw_reuse = 1 //这个配置主要影响的是Web服务器到DB服务器的连接复用 net.ipv4.tcp_tw_recycle： 设置成1和0都没有任何意义。想一想，在负载均衡和它的连接中，它是服务端，但是TIME_WAIT出现在负载均衡服务器上；它和DB的连接，它是客户端，recycle对它并没有什么影响，关键是reuse 方案二：Web服务器首先关闭来自负载均衡服务器的连接 在这种情况下，Web服务器变成TIME_WAIT的重灾区。负载均衡对Web服务器的连接，由Web服务器首先关闭连接，TIME_WAIT出现在Web服务器上；Web服务器对DB服务器的连接，由Web服务器关闭连接，TIME_WAIT也出现在它身上，此时，负载均衡服务器上的配置： net.ipv4.tcp_tw_reuse：0 或者 1 都行，都没有实际意义 net.ipv4.tcp_tw_recycle=0 //一定是关闭recycle 在Web服务器上的配置： net.ipv4.tcp_tw_reuse = 1 //这个配置主要影响的是Web服务器到DB服务器的连接复用 net.ipv4.tcp_tw_recycle=1 //由于在负载均衡和Web服务器之间并没有NAT的网络，可以考虑开启recycle，加速由于负载均衡和Web服务器之间的连接造成的大量TIME_WAIT 回答几个大家提到的几个问题 请问我们所说连接池可以复用连接，是不是意味着，需要等到上个连接time wait结束后才能再次使用? 所谓连接池复用，复用的一定是活跃的连接，所谓活跃，第一表明连接池里的连接都是ESTABLISHED的，第二，连接池做为上层应用，会有定时的心跳去保持连接的活跃性。既然连接都是活跃的，那就不存在有TIME_WAIT的概念了，在上篇里也有提到，TIME_WAIT是在主动关闭连接的一方，在关闭连接后才进入的状态。既然已经关闭了，那么这条连接肯定已经不在连接池里面了，即被连接池释放了。 想请问下，作为负载均衡的机器随机端口使用完的情况下大量time_wait，不调整你文字里说的那三个参数，有其他的更好的方案吗？ 第一，随机端口使用完，你可以通过调整/etc/sysctl.conf下的net.ipv4.ip_local_port_range配置，至少修改成 net.ipv4.ip_local_port_range=1024 65535，保证你的负载均衡服务器至少可以使用6万个随机端口，也即可以有6万的反向代理到后端的连接，可以支持每秒1000的并发（想一想，因为TIME_WAIT状态会持续1分钟后消失，所以一分钟最多有6万，每秒1000）；如果这么多端口都使用完了，也证明你应该加服务器了，或者，你的负载均衡服务器需要配置多个IP地址，或者，你的后端服务器需要监听更多的端口和配置更多的IP（想一下socket的五元组） 第二，大量的TIME_WAIT，多大量？如果是几千个，其实不用担心，因为这个内存和CPU的消耗有一些，但是是可以忽略的。 第三，如果真的量很大，上万上万的那种，可以考虑，让后端的服务器主动关闭连接，如果后端服务器没有外网的连接只有负载均衡服务器的连接（主要是没有NAT网络的连接），可以在后端服务器上配置tw_recycle，然后同时，在负载均衡服务器上，配置tw_reuse。 如果想深入的学习一下网络方面的知识，有什么推荐的？ 学习网络比学一门编程语言“难”很多。所谓难，其实，是因为需要花很多的时间投入。我自己不算精通，只能说入门和理解。基本书可以推荐：《TCP/IP 协议详解》，必读；《TCP/IP高效编程：改善网络程序的44个技巧》，必读；《Unix环境高级编程》，必读；《Unix网络编程：卷一》，我只读过卷一；另外，还需要熟悉一下网络工具，tcpdump以及wireshark，我的notes里有一个一站式学习Wireshark：https://github.com/dafang/notebook/issues/114，也值得一读。有了这些积累，可能就是一些实践以及碎片化的学习和积累了。 写在最后 这篇文章我断断续续写了两天，内容找了多个地方去验证，包括看到Vincent Bernat的一篇文章以及Vincent在多个地方和别人的讨论。期间，我也花了一些时间和Vincent探讨了几个我没在tcp源码里翻找到的有疑问的地方。 我力求比散布在网上的文章做到准确并尽量整理的清晰一些。但是，也难免会 有疏漏或者有错误的地方，高手看到可以随时指正，并和我讨论，大家一起研究！感谢您阅读。 用一点赞赏，来鼓励作者继续撰写干货 高性能网络 | 你所不知道的TIME_WAIT和CLOSE_WAIT","link":"/2019/08/02/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%20%7C%20%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84TIME_WAIT%E5%92%8CCLOSE_WAIT/"},{"title":"2017派卧底去阿里、京东、美团、滴滴带回来的面试题及答案","text":"2017派卧底去阿里、京东、美团、滴滴带回来的面试题及答案最近有很多朋友去目前主流的大型互联网公司面试（阿里巴巴、京东、美团、滴滴），面试回来之后会发给我一些面试题。有些朋友轻松过关，拿到offer，但是有一些是来询问我答案的。 我特意整理了一下，有很多问题不是靠几句话能讲清楚，所以干脆找朋友录制了一些视频，用来回来这些面试题。很多问题其实答案很简单，但是背后的思考和逻辑不简单，要做到知其然还要知其所以然。 先来看下用手机记录的面试材料： 一，阿里巴巴面试题 二，京东面试题 三，美团面试题 四，滴滴面试题 五，本次卧底面试得到的结论 通过面试题来看，可以看出目前互联网公司面试考点为： 1.性能调优、算法数据机构 2.高并发下数据安全、接口冪等性、原子性等 3.分布式下协同、已经锁的处理 4.数据库的分库分表、项目之间的垂直拆分 出现频率高的技术点有： 1.HashMap 2.JVM 3.Dubbo 4.Mybatis 5.Zookeeper 6.http tcp/ip","link":"/2019/08/02/2017%E6%B4%BE%E5%8D%A7%E5%BA%95%E5%8E%BB%E9%98%BF%E9%87%8C%E3%80%81%E4%BA%AC%E4%B8%9C%E3%80%81%E7%BE%8E%E5%9B%A2%E3%80%81%E6%BB%B4%E6%BB%B4%E5%B8%A6%E5%9B%9E%E6%9D%A5%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"title":"Java 开发必备面试题详解（技术+人事）","text":"Java 开发必备面试题详解（技术+人事）大家好，我是宁楠，之前出了一个达人课《Spring MVC 实战手册》，在跟读者的交流过程中，不断有朋友谈到关于面试的问题，可见大家对这部分的需求还是比较大的。所以我就将平时积累的 Java 面试题进行详细地筛选，并在某些地方加入解题思路和对知识点的理解，整理成文章分享给大家。共计 211 道题，涉及到 Java 面试的高频考点，以及相关人事问题，希望对大家的求职面试有所帮助。 数据结构和算法1. 判断身份证：要么是 15 位，要么是 18 位，最后一位可以为字母，并写程序提出其中的年月日。 我们可以用正则表达式来定义复杂的字符串格式，如 \\d{17}[0-9a-zA-Z]|\\d{14}[0-9a-zA-Z] 可以用来判断是否为合法的 15 位或 18 位身份证号码。 因为 15 位和 18 位的身份证号码都是从 7 位到第 12 位为身份证为日期类型。这样我们可以设计出更精确的正则模式，使身份证号的日期合法，这样我们的正则模式可以进一步将日期部分的正则修改为 [12][0-9]{3}[01][0-9][123][0-9] ，当然可以更精确的设置日期。 在 JDK 的 java.util.Regex 包中有实现正则的类，Pattern 和 Matcher。以下是实现代码： 123456789101112131415161718192021222324252627282930313233343536import java.util.regex.Matcher;import java.util.regex.P attern;public class RegexTest { /** * @param args */ public static void main(String[] args) { // 测试是否为合法的身份证号码 String[] strs = { &quot;130681198712092019&quot;, &quot;13068119871209201x&quot;, &quot;13068119871209201&quot;, &quot;123456789012345&quot;, &quot;12345678901234x&quot;, &quot;1234567890123&quot; }; Pattern p1 = Pattern.compile(&quot;(\\\\d{17}[0-9a-zA-Z]|\\\\d{14}[0-9a-zA-Z])&quot;); for (int i = 0; i &lt; strs.length; i++) { Matcher matcher = p1.matcher(strs[i]); System.out.println(strs[i] + &quot;:&quot; + matcher.matches()); } Pattern p2 = Pattern.compile(&quot;\\\\d{6}(\\\\d{8}).*&quot;); // 用于提取出生日字符串 Pattern p3 = Pattern.compile(&quot;(\\\\d{4})(\\\\d{2})(\\\\d{2})&quot;);// 用于将生日字符串进行分解为年月日 for (int i = 0; i &lt; strs.length; i++) { Matcher matcher = p2.matcher(strs[i]); boolean b = matcher.find(); if (b) { String s = matcher.group(1); Matcher matcher2 = p3.matcher(s); if (matcher2.find()) { System.out .println(&quot;生日为&quot; + matcher2.group(1) + &quot;年&quot; + matcher2.group(2) + &quot;月&quot; + matcher2.group(3) + &quot;日&quot;); } } } }} 2. 说明生活中遇到的二叉树，用 Java 实现二叉树。 这是组合设计模式。 我有很多个（假设 10 万个）数据要保存起来，以后还需要从保存的这些数据中检索是否存在某个数据。假如存在数组中，那么，碰巧要找的数字位于 99999 那个地方，查找的速度将很慢，因为要从第 1 个依次往后取，取出来后进行比较。平衡二叉树（构建平衡二叉树需要先排序，我们这里就不作考虑了）可以很好地解决这个问题，但二叉树的遍历（前序、中序、后序）效率要比数组低很多，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class Node { public int value; public Node left; public Node right; public void store(int value) { if(value&lt;this.value) { if(left == null) { left = new Node(); left.value=value; } else { left.store(value); } } else if(value&gt;this.value) { if(right == null) { right = new Node(); right.value=value; } else { right.store(value); } } } public boolean find(int value) { System.out.println(&quot;happen &quot; + this.value); if(value == this.value) { return true; } else if(value&gt;this.value) { if(right == null) return false; return right.find(value); }else { if(left == null) return false; return left.find(value); } } public void preList() { System.out.print(this.value + &quot;,&quot;); if(left!=null) left.preList(); if(right!=null) right.preList(); } public void middleList() { if(left!=null) left.preList(); System.out.print(this.value + &quot;,&quot;); if(right!=null) right.preList(); } public void afterList() { if(left!=null) left.preList(); if(right!=null) right.preList(); System.out.print(this.value + &quot;,&quot;); } public static void main(String [] args) { int [] data = new int[20]; for(int i=0;i&lt;data.length;i++) { data[i] = (int)(Math.random()*100) + 1; System.out.print(data[i] + &quot;,&quot;); } System.out.println(); Node root = new Node(); root.value = data[0]; for(int i=1;i&lt;data.length;i++) { root.store(data[i]); } root.find(data[19]); root.preList(); System.out.println(); root.middleList(); System.out.println(); root.afterList(); }} 3. 第 1 个人 10 岁，第 2 个比第 1 个人大 2 岁，依次递推，请用递归方式计算出第 8 个人多大？ 12345678910111213141516import java.util.Date;public class A1 { public static void main(String [] args){ System.out.println(computeAge(8)); } public static int computeAge(int n){ if(n==1) return 10; return computeAge(n-1) + 2; }}public static void toBinary(int n,StringBuffer result){ if(n/2 != 0) toBinary(n/2,result); result.append(n%2); } 4. 有一对兔子，从出生后第 3 个月起每个月都生一对兔子，小兔子长到第四个月后每个月又生一对兔子，假如兔子都不死，问第月的兔子总数为多少？ 程序分析： 兔子的规律为数列 1,1,2,3,5,8,13,21… 123456789101112131415161718192021222324252627282930public class exp1 { public static void main(String args[]) { int i = 0; for (i = 1; i &lt;= 20; i++) System.out.println(f(i)); } public static int f(int x) { if (x == 1 || x == 2) return 1; else return f(x - 1) + f(x - 2); }}public class exp1 { public static void main(String args[]) { int i = 0; math mymath = new math(); for (i = 1; i &lt;= 20; i++) System.out.println(mymath.f(i)); } } class math { public int f(int x) { if (x == 1 || x == 2) return 1; else return f(x - 1) + f(x - 2); }} 5. 打印出所有的“水仙花数”。所谓“水仙花数”是指一个三位数，其各位数字立方和等于该数本身。例 如：153 是一个“水仙花数”，因为 153 = 1 的三次方＋5 的三次方＋3 的三次方。在 2000 以内的数字。 程序分析：利用 for 循环控制 100~999 个数，每个数分解出个位、十位、百位。 123456789101112131415161718192021222324252627282930313233public class exp2 { public static void main(String args[]) { int i = 0; math mymath = new math(); for (i = 100; i &lt;= 999; i++) if (mymath.shuixianhua(i) == true) System.out.println(i); }} class math { public int f(int x) { if (x == 1 || x == 2) return 1; else return f(x - 1) + f(x - 2); } public boolean iszhishu(int x) { for (int i = 2; i &lt;= x / 2; i++) if (x % 2 == 0) return false; return true; } public boolean shuixianhua(int x) { int i = 0, j = 0, k = 0; i = x / 100; j = (x % 100) / 10; k = x % 10; if (x == i * i * i + j * j * j + k * k * k) return true; else return false; }} 6. 输入两个正整数 m 和 n，求其最大公约数和最小公倍数。 程序分析：利用辗除法。 最大公约数： 1234567891011121314151617181920212223242526272829303132333435363738394041public class CommonDivisor { public static void main(String args[]) { commonDivisor(24, 32); } static int commonDivisor(int M, int N) { if (N &lt; 0 || M &lt; 0) { System.out.println(&quot;ERROR!&quot;); return -1; } if (N == 0) { System.out.println(&quot;the biggest common divisor is :&quot; + M); return M; } return commonDivisor(N, M % N); }}最小公倍数和最大公约数：import java.util.Scanner; public class CandC { // 下面的方法是求出最大公约数 public static int gcd(int m, int n) { while (true) { if ((m = m % n) == 0) return n; if ((n = n % m) == 0) return m; } } public static void main(String args[]) throws Exception { // 取得输入值 Scanner chin = new Scanner(System.in); int a = chin.nextInt(), b = chin.nextInt(); int a = 23; int b = 32; int c = gcd(a, b); System.out.println(&quot;最小公倍数：&quot; + a * b / c + &quot;\\n最大公约数：&quot; + c); }} 7. 输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。 程序分析：利用 while 语句，条件为输入的字符不为 ‘\\n ‘。 123456789101112131415161718192021222324252627import java.util.Scanner; public class ex7 { public static void main(String args[]) { System.out.println(&quot;请输入字符串：&quot;); Scanner scan = new Scanner(System.in); String str = scan.next(); String E1 = &quot;[\\u4e00-\\u9fa5]&quot;; String E2 = &quot;[a-zA-Z]&quot;; int countH = 0; int countE = 0; char[] arrChar = str.toCharArray(); String[] arrStr = new String[arrChar.length]; for (int i = 0; i &lt; arrChar.length; i++) { arrStr[i] = String.valueOf(arrChar[i]); } for (String i : arrStr) { if (i.matches(E1)) { countH++; }if (i.matches(E2)) { countE++; } } System.out.println(&quot;汉字的个数&quot; + countH); System.out.println(&quot;字母的个数&quot; + countE); }} 8. 求 s=a+aa+aaa+aaaa+aa…a 的值，其中 a 是一个数字。例如 2+22+222+2222+22222（此时共有 5 个数相加），几个数相加有键盘控制。 程序分析：关键是计算出每一项的值。 1234567891011121314151617181920212223242526272829303132333435363738import java.io.*;public class Sumloop { public static void main(String[] args) throws IOException { int s = 0; String output = &quot;&quot;; BufferedReader stadin = new BufferedReader(new InputStreamReader( System.in)); System.out.println(&quot;请输入a的值&quot;); String input = stadin.readLine(); for (int i = 1; i &lt;= Integer.parseInt(input); i++) { output += input; int a = Integer.parseInt(output); s += a; } System.out.println(s); }}import java.io.*; public class Sumloop { public static void main(String[] args) throws IOException { int s = 0; int n; int t = 0; BufferedReader stadin = new BufferedReader(new InputStreamReader( System.in)); String input = stadin.readLine(); n = Integer.parseInt(input); for (int i = 1; i &lt;= n; i++) { t = t * 10 + n; s = s + t; System.out.println(t); } System.out.println(s); }} 9. 一个数如果恰好等于它的因子之和，这个数就称为“完数”。例如 6 = 1＋2＋3。编程找出 1000 以内的所有完数。 1234567891011121314public class Wanshu { public static void main(String[] args) { int s; for (int i = 1; i &lt;= 1000; i++) { s = 0; for (int j = 1; j &lt; i; j++) if (i % j == 0) s = s + j; if (s == i) System.out.print(i + &quot; &quot;); } System.out.println(); }} 10. 有 1、2、3、4 个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？ 程序分析：可填在百位、十位、个位的数字都是 1、2、3、4。组成所有的排列后再去掉不满足条件的排列。 12345678910111213141516171819public class Wanshu { public static void main(String[] args) { int i = 0; int j = 0; int k = 0; int t = 0; for (i = 1; i &lt;= 4; i++) for (j = 1; j &lt;= 4; j++) for (k = 1; k &lt;= 4; k++) if (i != j &amp;&amp; j != k &amp;&amp; i != k) { t += 1; System.out.println(i * 100 + j * 10 + k); } System.out.println(t); }} 11. 一个整数，它加上 100 后是一个完全平方数，加上 168 又是一个完全平方数，请问该数是多少？ 程序分析：在 10 万以内判断，先将该数加上 100 后再开方，再将该数加上 268 后再开方，如果开方后的结果满足如下条件，即是结果。请看具体分析： 123456789public class test { public static void main(String[] args) { long k = 0; for (k = 1; k &lt;= 100000l; k++) if (Math.floor(Math.sqrt(k + 100)) == Math.sqrt(k + 100) &amp;&amp; Math.floor(Math.sqrt(k + 168)) == Math.sqrt(k + 168)) System.out.println(k); }} 12. 猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个。第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第 10 天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。 程序分析：采取逆向思维的方法，从后往前推断。 123456789101112public class Monkey { static int total(int day) { if (day == 10) { return 1; } else { return (total(day + 1) + 1) * 2; } } public static void main(String[] args) { System.out.println(total(1)); }} 13. 有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13……求出这个数列的前 20 项之和。 程序分析：请抓住分子与分母的变化规律。 1234567891011121314public class test20 { public static void main(String[] args) { float fm = 1f; float fz = 1f; float temp; float sum = 0f; for (int i = 0; i &lt; 20; i++) { temp = fm; fm = fz; fz = fz + temp; sum += fz / fm; } System.out.println(sum); }} 14. 有 5 个人坐在一起，问第五个人多少岁？他说比第 4 个人大 2 岁。问第 4 个人岁数，他说比第 3 个人 大 2 岁。问第三个人，又说比第 2 人大两岁。问第 2 个人，说比第一个人大两岁。最后问第一个人，他说是 10 岁。请问第五个人多大？ 程序分析：利用递归的方法，递归分为回推和递推两个阶段。要想知道第五个人岁数，需知道第四人的岁数，依次类推， 推到第一人（10 岁），再往回推。 123456789101112public class Ex23 { static int getAge(int n) { if (n == 1) { return 10; } return 2 + getAge(n - 1); } public static void main(String[] args) { System.out.println(&quot;第五个的年龄为:&quot; + getAge(5)); }} 15. 打印出杨辉三角形。 1234567891011121314151617181920public class Ex33 { public static void main(String args[]) { int i, j; int a[][]; a = new int[8][8]; for (i = 0; i &lt; 8; i++) { a[i][i] = 1; a[i][0] = 1; } for (i = 2; i &lt; 8; i++) { for (j = 1; j &lt;= i - 1; j++) { a[i][j] = a[i - 1][j - 1] + a[i - 1][j]; } } for (i = 0; i &lt; 8; i++) { for (j = 0; j &lt; i; j++) { System.out.printf(&quot; &quot; + a[i][j]); } System.out.println(); } }} JVM Java 类加载过程？ Java 类加载需要经历一下 7 个过程： 1. 加载 加载是类加载的第一个过程，在这个阶段，将完成一下三件事情： 通过一个类的全限定名获取该类的二进制流。 将该二进制流中的静态存储结构转化为方法去运行时数据结构。 在内存中生成该类的 Class 对象，作为该类的数据访问入口。 2. 验证 验证的目的是为了确保 Class 文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证: 文件格式验证：验证字节流是否符合 Class 文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型. 元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。 字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。 符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。 3. 准备 准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。 1public static int value=123;//在准备阶段value初始值为0 。在初始化阶段才会变为123 。 4. 解析 该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。 5. 初始化 初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。 6. 使用 7. 卸载 描述一下 JVM 加载 Class 文件的原理机制? Java 语言是一种具有动态性的解释型语言，类（Class）只有被加载到 JVM 后才能运行。当运行指定程序时，JVM 会将编译生成的 .class 文件按照需求和一定的规则加载到内存中，并组织成为一个完整的 Java 应用程序。这个加载过程是由类加载器完成，具体来说，就是由 ClassLoader 和它的子类来实现的。类加载器本身也是一个类，其实质是把类文件从硬盘读取到内存中。 类的加载方式分为隐式加载和显示加载。隐式加载指的是程序在使用 new 等方式创建对象时，会隐式地调用类的加载器把对应的类加载到 JVM 中。显示加载指的是通过直接调用 class.forName() 方法来把所需的类加载到 JVM 中。 任何一个工程项目都是由许多类组成的，当程序启动时，只把需要的类加载到 JVM 中，其他类只有被使用到的时候才会被加载，采用这种方法一方面可以加快加载速度，另一方面可以节约程序运行时对内存的开销。此外，在 Java 语言中，每个类或接口都对应一个 .class 文件，这些文件可以被看成是一个个可以被动态加载的单元，因此当只有部分类被修改时，只需要重新编译变化的类即可，而不需要重新编译所有文件，因此加快了编译速度。 在 Java 语言中，类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类（例如基类）完全加载到 JVM 中，至于其他类，则在需要的时候才加载。 类加载的主要步骤： 装载。根据查找路径找到相应的 class 文件，然后导入。 链接。链接又可分为 3 个小步： 检查，检查待加载的 class 文件的正确性。 准备，给类中的静态变量分配存储空间。 解析，将符号引用转换为直接引用（这一步可选） 初始化。对静态变量和静态代码块执行初始化工作。 18. Java 内存分配。 寄存器： 我们无法控制。 静态域 ：static定义的静态成员。 常量池： 编译时被确定并保存在 .class 文件中的（final）常量值和一些文本修饰的符号引用（类和接口的全限定名，字段的名称和描述符，方法和名称和描述符）。 非 RAM 存储： 硬盘等永久存储空间。 堆内存 ：new 创建的对象和数组，由 Java 虚拟机自动垃圾回收器管理,存取速度慢。 栈内存： 基本类型的变量和对象的引用变量（堆内存空间的访问地址），速度快，可以共享，但是大小与生存期必须确定，缺乏灵活性。 Java 堆的结构是什么样子的？什么是堆中的永久代（Perm Gen space）? JVM 的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在 JVM 启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。 堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些 对象回收掉之前，他们会一直占据堆内存空间。 20. GC 是什么? 为什么要有 GC？ GC 是垃圾收集的意思（GabageCollection），内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。 21. 简述 Java 垃圾回收机制。 在 Java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。 22. 如何判断一个对象是否存活？（或者 GC 对象的判定方法） 判断一个对象是否存活有两种方法： 1. 引用计数法 所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收. 引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B，对象 B 又引用者对象 A，那么此时 A、B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。 2. 可达性算法（引用链法） 该算法的思想是：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。 在 Java 中可以作为 GC Roots 的对象有以下几种： 虚拟机栈中引用的对象 方法区类静态属性引用的对象 方法区常量池引用的对象 本地方法栈JNI引用的对象 虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达 GC Root 时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记. 如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法或者已被虚拟机调用过，那么就认为是没必要的。 如果该对象有必要执行 finalize() 方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize() 线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果 finalize() 执行缓慢或者发生了死锁，那么就会造成 F-Queue 队列一直等待，造成了内存回收系统的崩溃。GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除” 即将回收” 集合，等待回收。 23. 垃圾回收的优点和原理。并考虑 2 种回收机制。 Java 语言中一个显著的特点就是引入了垃圾回收机制，使 C++ 程序员最头疼的内存管理的问题迎刃而解，它使得 Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java 中的对象不再有“作用域”的概念，只有对象的引用才有”作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。 回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。 24. 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？ 对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。通常，GC 采用有向图的方式记录和管理堆（heap）中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当 GC 确定一些对象为“不可达”时，GC 就有责任回收这些内存空间。可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言规范并不保证 GC 一定会执行。 25. Java 中会存在内存泄漏吗，请简单描述。 所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。Java 中有垃圾回收机制，它可以保证一对象不再被引用的时候，即对象变成了孤儿的时候，对象将自动被垃圾回收器从内存中清除掉。由于 Java 使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么 GC 也是可以回收它们的，例如下面的代码可以看到这种情况的内存回收： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.IOException;public class GarbageTest { /** * @param args * @throws IOException */ public static void main(String[] args) throws IOException { // TODO Auto-generated method stub try { gcTest(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } System.out.println(&quot;has exited gcTest!&quot;); System.in.read(); System.in.read(); System.out.println(&quot;out begin gc!&quot;); for(int i=0;i&lt;100;i++) { System.gc(); System.in.read(); System.in.read(); } } private static void gcTest() throws IOException { System.in.read(); System.in.read(); Person p1 = new Person(); System.in.read(); System.in.read(); Person p2 = new Person(); p1.setMate(p2); p2.setMate(p1); System.out.println(&quot;before exit gctest!&quot;); System.in.read(); System.in.read(); System.gc(); System.out.println(&quot;exit gctest!&quot;); } private static class Person { byte[] data = new byte[20000000]; Person mate = null; public void setMate(Person other) { mate = other; } }} Java 中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是 Java 中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是 java 中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中 (例如放在一个全局 map 对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。 检查 Java 中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。 如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。 下面内容来自于网上（主要特点就是清空堆栈中的某个元素，并不是彻底把它从数组中拿掉，而是把存储的总数减少，本人写得可以比这个好，在拿掉某个元素时，顺便也让它从数组中消失，将那个元素所在的位置的值设置为 null 即可）： 我实在想不到比那个堆栈更经典的例子了，以致于我还要引用别人的例子，下面的例子不是我想到的，是书上看到的，当然如果没有在书上看到，可能过一段时间我自己也想的到，可是那时我说是我自己想到的也没有人相信的。 123456789101112131415161718192021public class Stack { private Object[] elements=new Object[10]; private int size = 0; public void push(Object e){ ensureCapacity(); elements[size++] = e; } public Object pop(){ if( size == 0) throw new EmptyStackException(); return elements[--size]; } private void ensureCapacity(){ if(elements.length == size){ Object[] oldElements = elements; elements = new Object[2 * elements.length+1]; System.arraycopy(oldElements,0, elements, 0, size); } }} 上面的原理应该很简单，假如堆栈加了 10 个元素，然后全部弹出来，虽然堆栈是空的，没有我们要的东西，但是这是个对象是无法回收的，这个才符合了内存泄露的两个条件：无用，无法回收。但是就是存在这样的东西也不一定会导致什么样的后果，如果这个堆栈用的比较少，也就浪费了几个K内存而已，反正我们的内存都上 G 了，哪里会有什么影响，再说这个东西很快就会被回收的，有什么关系。下面看两个例子。 12345678public class Bad{ public static Stack s=Stack(); static{ s.push(new Object()); s.pop(); //这里有一个对象发生内存泄露 s.push(new Object()); //上面的对象可以被回收了，等于是自愈了 }} 因为是 static，就一直存在到程序退出，但是我们也可以看到它有自愈功能，就是说如果你的 Stack 最多有 100 个对象，那么最多也就只有 100 个对象无法被回收其实这个应该很容易理解，Stack 内部持有 100 个引用，最坏的情况就是他们都是无用的，因为我们一旦放新的进取，以前的引用自然消失！ 内存泄露的另外一种情况：当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前对象，造成内存泄露。 26. 深拷贝和浅拷贝。 简单来讲就是复制、克隆。 1Person p=new Person(“张三”); 浅拷贝就是对对象中的数据成员进行简单赋值，如果存在动态成员或者指针就会报错。 深拷贝就是对对象中存在的动态成员或指针重新开辟内存空间。 27. System.gc() 和 Runtime.gc() 会做什么事情？ 这两个方法用来提示 JVM 要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于 JVM 的。 28. finalize() 方法什么时候被调用？析构函数 (finalization) 的目的是什么？ 垃圾回收器（garbage colector）决定回收某对象时，就会运行该对象的 finalize() 方法 但是在 Java 中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说 filalize() 可能永远不被执行，显然指望它做收尾工作是靠不住的。 那么 finalize() 究竟是做什么的呢？ 它最主要的用途是回收特殊渠道申请的内存。Java 程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种 JNI（Java Native Interface）调用 non-­Java 程序（C 或 C++）， finalize() 的工作就是回收这部分的内存。 29. 如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存？ 不会，在下一个垃圾回收周期中，这个对象将是可被回收的。 30. 什么是分布式垃圾回收（DGC）？它是如何工作的？ DGC 叫做分布式垃圾回收。RMI 使用 DGC 来做自动垃圾回收。因为 RMI 包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC 使用引用计数算法来给远程对象提供自动内存管理。 31. 串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？ 吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。 而串行收集器对大多数的小应用（在现代处理器上需要大概 100M 左右的内存）就足够了。 32. 在 Java 中，对象什么时候可以被垃圾回收？ 当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。 33. 简述 Java 内存分配与回收策率以及 Minor GC 和 Major GC。 对象优先在堆的 Eden 区分配 大对象直接进入老年代 长期存活的对象将直接进入老年代 当 Eden 区没有足够的空间进行分配时，虚拟机会执行一次 Minor GC。Minor GC 通常发生在新生代的 Eden 区，在这个区的对象生存期短，往往发生 Gc 的频率较高，回收速度比较快；Full GC/Major GC 发生在老年代，一般情况下，触发老年代 GC 的时候不会触发 Minor GC，但是通过配置，可以在 Full GC 之前进行一次 Minor GC 这样可以加快老年代的回收速度。 34. JVM 的永久代中会发生垃圾回收么？ 垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收（Full GC）。 注：Java 8 中已经移除了永久代，新加了一个叫做元数据区的 native 内存区。 35. Java 中垃圾收集的方法有哪些？ 标记 - 清除：这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题： 效率不高，标记和清除的效率都很低； 会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次 GC 动作。 复制算法：为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。 于是将该算法进行了改进，内存区域不再是按照 1:1 去划分，而是将内存划分为 8:1:1 三部分，较大那份内存交 Eden 区，其余是两块较小的内存区叫 Survior 区。每次都会优先使用 Eden 区，若 Eden 区满，就将对象复制到第二块内存区上，然后清除 Eden 区，如果此时存活的对象太多，以至于 Survivor 不够时，会将这些对象通过分配担保机制复制到老年代中。（java 堆又分为新生代和老年代） 标记 - 整理：该算法主要是为了解决标记 - 清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。 分代收集：现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保。 36. 什么是类加载器，类加载器有哪些？ 实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。 主要有一下四种类加载器： 启动类加载器（Bootstrap ClassLoader）用来加载 Java 核心类库，无法被 Java 程序直接引用。 扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader() 来获取它。 用户自定义类加载器，通过继承 java.lang.ClassLoader 类的方式实现。 37. 类加载器双亲委派模型机制？* 当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。 Java 核心基础38. 一个 “.java” 源文件中是否可以包括多个类（不是内部类）？有什么限制？ 可以有多个类，但只能有一个 public 的类，并且 public 的类名必须与文件名相一致。 39. 说说 &amp; 和 &amp;&amp; 的区别。 &amp; 和 &amp;&amp; 都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为 true 时，整个运算结果才为 true，否则，只要有一方为 false，则结果为 false。 &amp;&amp; 还具有短路的功能，即如果第一个表达式为 false，则不再计算第二个表达式，例如，对于 if(str != null &amp;&amp; !str.equals(“”)) 表达式，当 str 为 null 时，后面的表达式不会执行，所以不会出现 NullPointerException 如果将 &amp;&amp; 改为 &amp;，则会抛出 NullPointerException 异常。If(x==33 &amp; ++y&gt;0) y 会增长，If(x==33 &amp;&amp; ++y&gt;0) 不会增长。 &amp; 还可以用作位运算符，当 &amp; 操作符两边的表达式不是 boolean 类型时，&amp; 表示按位与操作，我们通常使用 0x0f 来与一个整数进行 &amp; 运算，来获取该整数的最低 4 个 bit 位，例如，0x31 &amp; 0x0f 的结果为 0x01。 备注：这道题先说两者的共同点，再说出 &amp;&amp; 和 &amp; 的特殊之处，并列举一些经典的例子来表明自己理解透彻深入、实际经验丰富。 40. 值传递和引用传递。 值传递是针对基本数据类型而言，传递的是值得副本，对副本的改变不会影响到原变量。 引用传递就是将一个堆内存空间的使用权交给多个栈内存空间，每一个栈内存空间都可以对堆内存空间进行修改。 41. 在 Java 中如何跳出当前的多重嵌套循环？ 在 Java 中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的 break 语句，即可跳出外层循环。例如： 12345678for(int i=0;i&lt;10;i++){ for(int j=0;j&lt;10;j++) { System.out.println(“i=” + i + “,j=” + j); if(j == 5) break ok; }} 另外，我个人通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如，要在二维数组中查找到某个数字。 1234567891011121314int arr[][] = {{1,2,3},{4,5,6,7},{9}};boolean found = false;for(int i=0;i&lt;arr.length &amp;&amp; !found;i++) { for(int j=0;j&lt;arr[i].length;j++) { System.out.println(“i=” + i + “,j=” + j); if(arr[i][j] == 5) { found = true; break; } } } 42. 访问修饰符 public,private,protected, 以及不写（默认）时的区别？ 修饰符 当前类 同 包 子 类 其他包 public √ √ √ √ protected √ √ √ × Default √ √ × × private √ × × × 43. switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上? 在 switch（expr1）中，expr1 只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是 int 基本类型或 Integer 包装类型，由于，byte,short,char 都可以隐含转换为 int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long 和 String 类型都不符合 switch 的语法规定，并且不能被隐式转换成 int 类型，所以，它们不能作用于 swtich 语句中。 44. char 型变量中能不能存贮一个中文汉字? 为什么? char 型变量是用来存储 Unicode 编码的字符的，unicode 编码字符集中包含了汉字，所以，char 型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在 unicode 编码字符集中，那么，这个 char 型变量中就不能存储这个特殊汉字。补充说明：unicode 编码占用两个字节，所以，char 类型的变量也是占用两个字节。 备注：后面一部分回答虽然不是在正面回答题目，但是，为了展现自己的学识和表现自己对问题理解的透彻深入，可以回答一些相关的知识，做到知无不言，言无不尽。 45. 用最有效率的方法算出 2 乘以 8 等於几? 2 &lt;&lt; 3 因为将一个数左移 n 位，就相当于乘以了 2 的 n 次方，那么，一个数乘以 8 只要将其左移 3 位即可，而位运算 cpu 直接支持的，效率最高，所以，2 乘以 8 等於几的最效率的方法是 2 &lt;&lt; 3。 46. 使用 final 关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？ 使用 final 关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句： 1final StringBuffer a=new StringBuffer(&quot;immutable&quot;); 执行如下语句将报告编译期错误： 1a=new StringBuffer(&quot;&quot;); 但是，执行如下语句则可以通过编译： 1a.append(&quot; broken!&quot;); 有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象： 123public void method(final StringBuffer param){} 实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象： 1param.append(&quot;a&quot;); 47. “==” 和 equals 方法究竟有什么区别？ （单独把一个东西说清楚，然后再说清楚另一个，这样，它们的区别自然就出来了，混在一起说，则很难说清楚） == 操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用 == 操作符。 如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块内存（堆内存），变量也占用一块内存，例如 Objet obj = new Object(); 变量 obj 是一个内存，new Object() 是另一个内存，此时，变量 obj 所对应的内存中存储的数值就是对象占用的那块内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要看这两个变量所对应的内存中的数值是否相等，这时候就需要用 == 操作符进行比较。 equals 方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。例如，对于下面的代码： 123String a=new String(&quot;foo&quot;);String b=new String(&quot;foo&quot;); 两条 new 语句创建了两个对象，然后用 a,b 这两个变量分别指向了其中一个对象，这是两个不同的对象，它们的首地址是不同的，即 a 和 b 中存储的数值是不相同的，所以，表达式 a==b 将返回 false，而这两个对象中的内容是相同的，所以，表达式 a.equals(b) 将返回 true。 在实际开发中，我们经常要比较传递进行来的字符串内容是否等，例如，String input = …;input.equals(“quit”)，许多人稍不注意就使用 == 进行比较了，这是错误的，随便从网上找几个项目实战的教学视频看看，里面就有大量这样的错误。记住，字符串的比较基本上都是使用 equals 方法。 如果一个类没有自己定义 equals 方法，那么它将继承 Object 类的 equals 方法，Object 类的 equals 方法的实现代码如下： 12345boolean equals(Object o){return this==o;} 这说明，如果一个类没有自己定义 equals 方法，它默认的 equals 方法（从 Object 类继承的）就是使用 == 操作符，也是在比较两个变量指向的对象是否是同一对象，这时候使用 equals 和使用 == 会得到同样的结果，如果比较的是两个独立的对象则总返回 false。如果你编写的类希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖 equals 方法，由你自己写代码来决定在什么情况即可认为两个对象的内容是相同的。 48. 静态变量和实例变量的区别？ 在语法定义上的区别：静态变量前要加 static 关键字，而实例变量前则不加。 在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个 实例变量 。静态变量不属于某个实例对象，而是属于类，所以也称为 类变量 ，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。 例如，对于下面的程序，无论创建多少个实例对象，永远都只分配了一个 staticVar 变量，并且每创建一个实例对象，这个 staticVar 就会加 1；但是，每创建一个实例对象，就会分配一个 instanceVar，即可能分配多个 instanceVar，并且每个 instanceVar 的值都只自加了 1 次。 12345678910public class VariantTest{ public static int staticVar = 0; public int instanceVar = 0; public VariantTest() { staticVar++; instanceVar++; System.out.println(“staticVar=” + staticVar + ”,instanceVar=” + instanceVar); }} 备注：这个解答除了说清楚两者的区别外，最后还用一个具体的应用例子来说明两者的差异，体现了自己有很好的解说问题和设计案例的能力，思维敏捷，超过一般程序员，有写作能力！ 49. 是否可以从一个 static 方法内部发出对非 static 方法的调用？ 不可以。因为非 static 方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而 static 方法调用时不需要创建对象，可以直接调用。也就是说，当一个 static 方法被调用时，可能还没有创建任何实例对象，如果从一个 static 方法中发出对非 static 方法的调用，那个非 static 方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，不可以一个 static 方法内部发出对非 static 方法的调用。 50. Math.round(11.5) 等于多少? Math.round(-11.5) 等于多少? Math 类中提供了三个与取整有关的方法：ceil、floor、round，这些方法的作用与它们的英文名称的含义相对应，例如，ceil 的英文意义是天花板，该方法就表示向上取整，所以，Math.ceil(11.3)的结果为 12,Math.ceil(-11.3)的结果是 - 11；floor 的英文意义是地板，该方法就表示向下取整，所以，Math.floor(11.6)的结果为 11,Math.floor(-11.6)的结果是 - 12；最难掌握的是 round 方法，它表示 “四舍五入”，算法为 Math.floor(x+0.5)，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为 12，Math.round(-11.5)的结果为 - 11。 51. Overload 和 Override 的区别。Overload 的方法是否可以改变返回值的类型? Overload 是重载的意思，Override 是覆盖的意思，也就是重写。 重载 Overload 表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。 重写 Override 表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是 private 类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。 至于 Overloaded 的方法是否可以改变返回值的类型这个问题，要看你倒底想问什么呢？这个题目很模糊。如果几个 Overloaded 的方法的参数列表不一样，它们的返回者类型当然也可以不一样。但我估计你想问的问题是：如果两个方法的参数列表完全一样，是否可以让它们的返回值不同来实现重载 Overload。这是不行的，我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用 map.remove(key) 方法时，虽然 remove 方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java 就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。 override 可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意以下的几点： 覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果； 覆盖的方法的返回值必须和被覆盖的方法的返回一致； 覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类； 被覆盖的方法不能为 private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。 overload 对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的方法，通过定义不同的输入参数来区分这些方法，然后再调用时，VM 就会根据不同的参数样式，来选择合适的方法执行。在使用重载要注意以下的几点： 在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是 fun(int,float)，但是不能为 fun(int,int)）； 不能通过访问权限、返回类型、抛出的异常进行重载； 方法的异常类型和数目不会对重载造成影响； 对于继承来说，如果某一方法在父类中是访问权限是 priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。 52. ClassLoader 如何加载 class。 JVM 里有多个类加载，每个类加载可以负责加载特定位置的类，例如，bootstrap 类加载负责加载 jre/lib/rt.jar 中的类， 我们平时用的 jdk 中的类都位于 rt.jar 中。extclassloader 负责加载 jar/lib/ext/*.jar 中的类，appclassloader 负责 classpath 指定的目录或 jar 中的类。除了 bootstrap 之外，其他的类加载器本身也都是 java 类，它们的父类是 ClassLoader。 53. 序列化接口的 id 有什么用？ 对象经常要通过 IO 进行传送，让你写程序传递对象，你会怎么做？把对象的状态数据用某种格式写入到硬盘，Person-&gt;“zxx,male,28,30000”àPerson，既然大家都要这么干，并且没有个统一的干法，于是，sun 公司就提出一种统一的解决方案，它会把对象变成某个格式进行输入和输出，这种格式对程序员来说是透明（transparent）的，但是，我们的某个类要想能被 sun 的这种方案处理，必须实现 Serializable 接口。 12ObjectOutputStream.writeObject(obj);Object obj = ObjectInputStream.readObject(); 假设两年前我保存了某个类的一个对象，这两年来，我修改该类，删除了某个属性和增加了另外一个属性，两年后，我又去读取那个保存的对象，或有什么结果？未知！sun 的 jdk 就会蒙了。为此，一个解决办法就是在类中增加版本后，每一次类的属性修改，都应该把版本号升级一下，这样，在读取时，比较存储对象时的版本号与当前类的版本号，如果不一致，则直接报版本号不同的错! 54. hashCode 方法的作用？ hashcode 这个方法是用来鉴定 2 个对象是否相等的。与 equals 方法功能类似，但是有区别。一般来讲，equals 这个方法是给用户调用的，如果你想判断 2 个对象是否相等，你可以重写 equals 方法，然后在代码中调用，就可以判断他们是否相等了。简单来讲，equals 方法主要是用来判断从表面上看或者从内容上看，2 个对象是不是相等。举个例子，有个学生类，属性只有姓名和性别，那么我们可以认为只要姓名和性别相等，那么就说这 2 个对象是相等的。 hashcode 方法一般用户不会去调用，比如在 hashmap 中，由于 key 是不可以重复的，他在判断 key 是不是重复的时候就判断了 hashcode 这个方法，而且也用到了 equals 方法。这里不可以重复是说 equals 和 hashcode 只要有一个不等就可以了！所以简单来讲，hashcode 相当于是一个对象的编码，就好像文件中的 md5，他和 equals 不同就在于他返回的是 int 型的，比较起来不直观。我们一般在覆盖 equals 的同时也要覆盖 hashcode，让他们的逻辑一致。举个例子，还是刚刚的例子，如果姓名和性别相等就算 2 个对象相等的话，那么 hashcode 的方法也要返回姓名的 hashcode 值加上性别的 hashcode 值，这样从逻辑上，他们就一致了。 55. 构造器 Constructor 是否可被 override? 构造器 Constructor 不能被继承，因此不能重写 Override，但可以被重载 Overload。 56. 接口是否可继承接口? 抽象类是否可实现 (implements) 接口? 抽象类是否可继承具体类(concrete class)? 抽象类中是否可以有静态的 main 方法？ 接口可以继承接口。抽象类可以实现 (implements) 接口，抽象类可继承具体类。抽象类中可以有静态的 main 方法。 备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想想，如果你是 java 语言的设计者，你是否会提供这样的支持，如果不提供的话，有什么理由吗？如果你没有道理不提供，那答案就是肯定的了。 只有记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有 abstract 方法。 57. Java 中实现多态的机制是什么？ 靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。 58. abstract class 和 interface 有什么区别? 含有 abstract 修饰符的 class 即为抽象类，abstract 类不能创建的实例对象。含有 abstract 方法的类必须定义为 abstract class，abstract class 类中的方法不必是抽象的。abstract class 类中定义抽象方法必须在具体 (Concrete) 子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为 abstract 类型。 接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为 public abstract 类型，接口中的成员变量类型默认为 public static final。 下面比较一下两者的语法区别： 抽象类可以有构造方法，接口中不能有构造方法。 抽象类中可以有普通成员变量，接口中没有普通成员变量 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。 抽象类中的抽象方法的访问类型可以是 public，protected 和（默认类型, 虽然 eclipse 下不报错，但应该也不行），但接口中的抽象方法只能是 public 类型的，并且默认即为 public abstract 类型。 抽象类中可以包含静态方法，接口中不能包含静态方法 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是 public static final 类型，并且默认即为 public static final 类型。 一个类可以实现多个接口，但只能继承一个抽象类。 下面接着再说说两者在应用上的区别：** 接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有 Servlet 类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的 Servlet 都继承这个抽象基类，在抽象基类的 service 方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码，伪代码如下： 123456789101112131415161718192021public abstract class BaseServlet extends HttpServlet{ public final void service(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException{ //记录访问日志 //进行权限判断 if(具有权限){ try { doService(request,response); }catch(Excetpion e){ //记录异常信息 } } } protected abstract void doService(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException; //注意访问权限定义成protected，显得既专业，又严谨，因为它是专门给子类用的}public class MyServlet1 extends BaseServlet{ protected void doService(HttpServletRequest request, HttpServletResponse response) throws IOExcetion,ServletException{ //本Servlet只处理的具体业务逻辑代码 }} 父类方法中间的某段代码不确定，留给子类干，就用模板方法设计模式。 备注：这道题的思路是先从总体解释抽象类和接口的基本概念，然后再比较两者的语法细节，最后再说两者的应用区别。比较两者语法细节区别的条理是：先从一个类中的构造方法、普通成员变量和方法（包括抽象方法），静态变量和方法，继承性等 6 个方面逐一去比较回答，接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功底。 59. abstract 的 method 是否可同时是 static, 是否可同时是 native，是否可同时是 synchronized? abstract 的 method 不可以是 static 的，因为抽象的方法是要被子类实现的，而 static 与子类扯不上关系。 native 方法表示该方法要用另外一种依赖平台的编程语言实现的，不存在着被子类实现的问题，所以，它也不能是抽象的，不能与 abstract 混用。例如，FileOutputSteam 类要硬件打交道，底层的实现用的是操作系统相关的 api 实现，例如，在 windows 用 c 语言实现的，所以，查看 jdk 的源代码，可以发现 FileOutputStream 的 open 方法的定义如下： 1private native void open(String name) throws FileNotFoundException; 如果我们要用 java 调用别人写的 c 语言函数，我们是无法直接调用的，我们需要按照 java 的要求写一个 c 语言的函数，又我们的这个 c 语言函数去调用别人的 c 语言函数。由于我们的 c 语言函数是按 java 的要求来写的，我们这个 c 语言函数就可以与 java 对接上，java 那边的对接方式就是定义出与我们这个 c 函数相对应的方法，java 中对应的方法不需要写具体的代码，但需要在前面声明 native。 关于 synchronized 与 abstract 合用的问题，我觉得也不行，因为在我几年的学习和开发中，从来没见到过这种情况，并且我觉得 synchronized 应该是作用在一个具体的方法上才有意义。而且，方法上的 synchronized 同步所使用的同步锁对象是 this，而抽象方法上无法确定 this 是什么。 60. 什么是内部类？Static Nested Class 和 Inner Class 的不同。 内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。我想可能是既然静态成员类似 c 语言的全局变量，而内部类通常是用于创建内部对象用的，所以，把 “全局变量” 放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中，代码如下： 12345678910111213141516171819public class Outer{ int out_x = 0; public void method(){ Inner1 inner1 = new Inner1(); //在方法体内部定义的内部类 class Inner2 { public void method() { out_x = 3; } } Inner2 inner2 = new Inner2(); } //在方法体外面定义的内部类 public class Inner1 { }} 在方法体外面定义的内部类的访问类型可以是 public,protecte, 默认的，private 等 4 种类型，这就好像类中定义的成员变量有 4 种访问类型一样，它们决定这个内部类的定义对其他类是否可见；对于这种情况，我们也可以在外面创建内部类的实例对象，创建内部类的实例对象时，一定要先创建外部类的实例对象，然后用这个外部类的实例对象去创建内部类的实例对象，代码如下： 12Outer outer = new Outer();Outer.Inner1 inner1 = outer.new Innner1(); 在方法内部定义的内部类前面不能有访问类型修饰符，就好像方法中定义的局部变量一样，但这种内部类的前面可以使用 final 或 abstract 修饰符。这种内部类对其他类是不可见的其他类无法引用这种内部类，但是这种内部类创建的实例对象可以传递给其他类访问。这种内部类必须是先定义，后使用，即内部类的定义代码必须出现在使用该类之前，这与方法中的局部变量必须先定义后使用的道理也是一样的。这种内部类可以访问方法体中的局部变量，但是，该局部变量前必须加 final 修饰符。 对于这些细节，只要在 eclipse 写代码试试，根据开发工具提示的各类错误信息就可以马上了解到。 在方法体内部还可以采用如下语法来创建一种匿名内部类，即定义某一接口或类的子类的同时，还创建了该子类的实例对象，无需为该子类定义名称： 12345678910public class Outer { public void start(){ new Thread(new Runnable() { @Override public void run() { } }).start(); }} 最后，在方法外部定义的内部类前面可以加上 static 关键字，从而成为 Static Nested Class，它不再具有内部类的特性，所有，从狭义上讲，它不是内部类。Static Nested Class 与普通类在运行时的行为和功能上没有什么区别，只是在编程引用时的语法上有一些差别，它可以定义成 public、protected、默认的、private 等多种类型，而普通类只能定义成 public 和默认的这两种类型。在外面引用 Static Nested Class 类的名称为 “外部类名. 内部类名”。在外面不需要创建外部类的实例对象，就可以直接创建 Static Nested Class，例如，假设 Inner 是定义在 Outer 类中的 Static Nested Class，那么可以使用如下语句创建 Inner 类： 1Outer.Inner inner = new Outer.Inner(); 由于 static Nested Class 不依赖于外部类的实例对象，所以，static Nested Class 能访问外部类的非 static 成员变量。当在外部类中访问 Static Nested Class 时，可以直接使用 Static Nested Class 的名字，而不需要加上外部类的名字了，在 Static Nested Class 中也可以直接引用外部类的 static 的成员变量，不需要加上外部类的名字。 在静态方法中定义的内部类也是 Static Nested Class，这时候不能在类前面加 static 关键字，静态方法中的 Static Nested Class 与普通方法中的内部类的应用方式很相似，它除了可以直接访问外部类中的 static 的成员变量，还可以访问静态方法中的局部变量，但是，该局部变量前必须加 final 修饰符。 备注：首先根据你的印象说出你对内部类的总体方面的特点：例如，在两个地方可以定义，可以访问外部类的成员变量，不能定义静态成员，这是大的特点。然后再说一些细节方面的知识，例如，几种定义方式的语法区别，静态内部类，以及匿名内部类。 61. String s = “Hello”;s = s + “world!”; 这两行代码执行后，原始的 String 对象中的内容到底变了没有？ 没有。因为 String 被设计成不可变 (immutable) 类，所以它的所有对象都是不可变对象。在这段代码中，s 原先指向一个 String 对象，内容是 “Hello”，然后我们对 s 进行了 + 操作，那么 s 所指向的那个对象是否发生了改变呢？答案是没有。这时，s 不指向原来那个对象了，而指向了另一个 String 对象，内容为 “Hello world!”，原来那个对象还存在于内存之中，只是 s 这个引用变量不再指向它了。 通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用 String 来代表字符串的话会引起很大的内存开销。因为 String 对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个 String 对象来表示。这时，应该考虑使用 StringBuffer 类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。 同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都 new 一个 String。例如我们要在构造器中对一个名叫 s 的 String 引用变量进行初始化，把它设置为初始值，应当这样做： 12345678public class Demo { private String s; ... public Demo { s = &quot;Initial Value&quot;; } ...} 后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为 String 对象不可改变，所以对于内容相同的字符串，只要一个 String 对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他们的 String 类型属性 s 都指向同一个对象。 上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java 认为它们代表同一个 String 对象。而用关键字 new 调用构造器，总是会创建一个新的对象，无论内容是否相同。 至于为什么要把 String 类设计成不可变类，是它的用途决定的。其实不只 String，很多 Java 标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。所以 Java 标准类库还提供了一个可变版本，即 StringBuffer。 62. String s = new String(“xyz”); 创建了几个 String Object? 二者之间有什么区别？ 两个对象，”xyz” 对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz” 不管出现多少遍，都是缓冲区中的那一个。New String 每写一遍，就创建一个新的对象，它一句那个常量”xyz” 对象的内容来创建出一个新 String 对象。如果以前就用过’xyz’，这句代表就不会创建”xyz” 自己了，直接从缓冲区拿。 63. StringBuffer 与 StringBuilder 的区别。 StringBuffer 和 StringBuilder 类都表示内容可以被修改的字符串， StringBuilder 是 线程不安全的，运行效率高 ，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用 StringBuilder。如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用 StringBuffer。 64. final,finally, finalize 的区别。 final 用于声明 属性，方法和类 ，分别表示属性不可变，方法不可覆盖，类不可继承。 内部类要访问局部变量，局部变量必须定义成 final 类型。 finally 是 异常处理语句结构 的一部分，表示总是执行。 finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM 不保证此方法总被调用。 65. Java 中的异常处理机制的简单原理和应用。 异常是指 java 程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很相似，现实生活中的事件可以包含事件发生的时间、地点、人物、情节等信息，可以用一个对象来表示，Java 使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。 Java 对异常进行了分类，不同类型的异常分别用不同的 Java 类表示，所有异常的根类为 java.lang.Throwable，Throwable 下面又派生了两个子类：Error 和 Exception，Error 表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程死锁等系统问题。Exception 表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）；普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。 Java 为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须 try..catch 处理或用 throws 声明继续抛给上层调用方法处理，所以普通异常也称为 checked 异常，而系统异常可以处理也可以不处理，所以，编译器不强制用 try..catch 处理或用 throws 声明，所以系统异常也称为 unchecked 异常。 提示答题者：就按照三个级别去思考：虚拟机必须宕机的错误，程序可以死掉也可以不死掉的错误，程序不应该死掉的错误。 多线程 / 高并发66. stop() 和 suspend() 方法为何不推荐使用？ 反对使用 stop()，是因为它不安全 。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。 suspend() 方法容易发生死锁 。调用 suspend() 的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被 “挂起” 的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用 suspend()，而应在自己的 Thread 类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用 wait() 命其进入等待状态。若标志指出线程应当恢复，则用一个 notify() 重新启动线程。 67. sleep() 和 wait() 有什么区别? sleep 就是正在执行的线程主动让出 cpu，cpu 去执行其他线程，在 sleep 指定的时间过后，cpu 才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep 方法并不会释放锁，即使当前线程使用 sleep 方法让出了 cpu，但其他被同步锁挡住了的线程也无法得到执行。wait 是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了 notify 方法（notify 并不释放锁，只是告诉调用过 wait 方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果 notify 方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在 notfiy 方法后增加一个等待和一些代码，看看效果），调用 wait 方法的线程就会解除 wait 状态和程序可以再次得到锁后继续向下运行。 68. 同步和异步有何异同，在什么情况下分别使用他们？ 如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 69. 当一个线程进入一个对象的一个 synchronized 方法后，其它线程是否可进入此对象的其它方法? 其他方法前是否加了 synchronized 关键字，如果没加，则能。 如果这个方法内部调用了 wait，则可以进入其他 synchronized 方法。 如果其他个方法都加了 synchronized 关键字，并且内部没有调用 wait，则不能。 如果其他方法是 static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是 this。 70. 简述 synchronized 和 java.util.concurrent.locks.Lock 的异同？ 主要相同点：Lock 能完成 synchronized 所实现的所有功能。 主要不同点：Lock 有比 synchronized 更精确的线程语义和更好的性能。synchronized 会自动释放锁，而 Lock 一定要求程序员手工释放，并且必须在 finally 从句中释放。Lock 还有更强大的功能，例如，它的 tryLock 方法可以非阻塞方式去拿锁。 举例说明（对下面的题用 lock 进行了改写） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class ThreadTest { /** * @param args */ private int j; private Lock lock = new ReentrantLock(); public static void main(String[] args) { // TODO Auto-generated method stub ThreadTest tt = new ThreadTest(); for(int i=0;i&lt;2;i++) { new Thread(tt.new Adder()).start(); new Thread(tt.new Subtractor()).start(); } } private class Subtractor implements Runnable { @Override public void run() { // TODO Auto-generated method stub while(true) { /*synchronized (ThreadTest.this) { System.out.println(&quot;j--=&quot; + j--); //这里抛异常了，锁能释放吗？ }*/ lock.lock(); try { System.out.println(&quot;j--=&quot; + j--); }finally { lock.unlock(); } } } } private class Adder implements Runnable { @Override public void run() { // TODO Auto-generated method stub while(true) { /*synchronized (ThreadTest.this) { System.out.println(&quot;j++=&quot; + j++); }*/ lock.lock(); try { System.out.println(&quot;j++=&quot; + j++); }finally { lock.unlock(); } } } }} 71. 概括的解释下线程的几种可用状态。 新建 new。 就绪 放在可运行线程池中，等待被线程调度选中，获取 cpu。 运行 获得了 cpu。 阻塞 等待阻塞 执行 wait() 。 同步阻塞 获取对象的同步琐时，同步锁被别的线程占用。 其他阻塞 执行了 sleep() 或 join() 方法)。 死亡。 72. 什么是 ThreadLocal? ThreadLocal 用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择 ThreadLocal 变量。 每个线程都会拥有他们自己的 Thread 变量，它们可以使用 get()\\set() 方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal 实例通常是希望它们同线程状态关联起来是 private static 属性。 73. run() 和 start() 区别。 run( )： 只是调用普通 run 方法 start( )： 启动了线程, 由 Jvm 调用 run 方法 启动一个线程是调用 start() 方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由 JVM 调度并执行。这并不意味着线程就会立即运行。run() 方法可以产生必须退出的标志来停止一个线程。 74. 请说出你所知道的线程同步的方法。 wait()： 使一个线程处于等待状态，并且释放所持有的对象的 lock。 sleep()： 使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉 InterruptedException 异常。 notify()： 唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且不是按优先级。 notityAll()： 唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。 75. 线程调度和线程控制。 线程调度（优先级）: 与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取 CPU 资源的概率较大，优先级低的并非没机会执行。 线程的优先级用 1-10 之间的整数表示，数值越大优先级越高，默认的优先级为 5。 在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。 线程控制 sleep( ) // 线程休眠 join( ) // 线程加入 yield( ) // 线程礼让 setDaemon( ) // 线程守护 中断线程 stop( ) interrupt( ) ==(首先选用)== 76. 什么是线程饿死，什么是活锁？* 当所有线程阻塞，或者由于需要的资源无效而不能处理，不存在非阻塞线程使资源可用。JavaAPI 中线程活锁可能发生在以下情形： 当所有线程在序中执行 Object.wait(0)，参数为 0 的 wait 方法。程序将发生活锁直到在相应的对象上有线程调用 Object.notify() 或者 Object.notifyAll()。 当所有线程卡在无限循环中。 77. 多线程中的忙循环是什么? 忙循环就是程序员用循环让一个线程等待，不像传统方法 wait(), sleep() 或 yield() 它们都放弃了 CPU 控制，而忙循环不会放弃 CPU，它就是在运行一个空循环。这么做的目的是为了保留 CPU 缓存。 在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。 78. volatile 变量是什么？volatile 变量和 atomic 变量有什么不同？ volatile 则是保证了所修饰的变量的可见。因为 volatile 只是在保证了同一个变量在多线程中的可见性，所以它更多是用于修饰作为开关状态的变量，即 Boolean 类型的变量。 volatile 多用于修饰类似开关类型的变量、Atomic 多用于类似计数器相关的变量、其它多线程并发操作用 synchronized 关键字修饰。 volatile 有两个功用 ： 这个变量不会在多个线程中存在复本，直接从内存读取。 这个关键字会禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。 79. volatile 类型变量提供什么保证？能使得一个非原子操作变成原子操作吗？ volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。 在 Java 中除了 long 和 double 之外的所有基本类型的读和赋值，都是原子性操作。而 64 位的 long 和 double 变量由于会被 JVM 当作两个分离的 32 位来进行操作，所以不具有原子性，会产生字撕裂问题。但是当你定义 long 或 double 变量时，如果使用 volatile 关键字，就会获到（简单的赋值与返回操作的）原子性。 集合框架80. ArrayList 和 Vector 的区别。 这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合，即存储在这两个集合中的元素的位置都是有顺序的，相当于一种动态的数组，我们以后可以按位置索引号取出某个元素，并且其中的数据是允许重复的，这是 HashSet 之类的集合的最大不同处，HashSet 之类的集合不可以按索引号去检索其中的元素，也不允许有重复的元素（本来题目问的与 hashset 没有任何关系，但为了说清楚 ArrayList 与 Vector 的功能，我们使用对比方式，更有利于说明问题）。接着才说 ArrayList 与 Vector 的区别，这主要包括两个方面。 同步性： Vector 是线程安全的，也就是说是它的方法之间是线程同步的，而 ArrayList 是线程序不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用 ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。 备注：对于 Vector&amp;ArrayList、Hashtable&amp;HashMap，要记住线程安全的问题，记住 Vector 与 Hashtable 是旧的，是 java 一诞生就提供了的，它们是线程安全的，ArrayList 与 HashMap 是 java2 时才提供的，它们是线程不安全的。所以，我们讲课时先讲老的。 数据增长： ArrayList 与 Vector 都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加 ArrayList 与 Vector 的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector 默认增长为原来两倍，而 ArrayList 的增长策略在文档中没有明确规定（从源代码看到的是增长为原来的 1.5 倍）。ArrayList 与 Vector 都可以设置初始的空间大小，Vector 还可以设置增长的空间大小，而 ArrayList 没有提供设置增长空间的方法。 总结：即 Vector 增长原来的一倍，ArrayList 增加原来的 0.5 倍。 81. 说说 ArrayList,Vector, LinkedList 的存储性能和特性。 ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 由于使用了 synchronized 方法（线程安全）。 通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快 。 ArrayList 在查找时速度快，LinkedList 在插入与删除时更具优势。 83. 快速失败 (fail-­fast) 和安全失败 (fail-­safe) 的区别是什么？ Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util 包下面的所有的集合类都是快速失败的，而 java.util.concurrent 包下面的所有的类都是安全失败的。快速失败的迭代器会抛出 ConcurrentModificationException 异常，而安全失败的迭代器永远不会抛出这样的异常。 84. hashmap 的数据结构。 在 java 编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，hashmap 也不例外。Hashmap 实际上是一个数组和链表的结合体（在数据结构中，一般称之为 “链表散列 “） enter image description here 85. HashMap 的工作原理是什么? Java 中的 HashMap 是以键值对 (key-­value) 的形式存储元素的。HashMap 需要一个 hash 函数，它使用 hashCode()和 equals()方法来向集合 / 从集合添加和检索元素。当调用 put() 方法的时候，HashMap 会计算 key 的 hash 值，然后把键值对存储在集合中合适的索引上。 如果 key 已经存在了，value 会被更新成新值。HashMap 的一些重要的特性是它的容量 (capacity)，负载因子 (load factor) 和扩容极限(threshold resizing)。 86. Hashmap 什么时候进行扩容呢？ 当 hashmap 中的元素个数超过数组大小 loadFactor 时，就会进行数组扩容，loadFactor 的默认值为 0.75，也就是说，默认情况下，数组大小为 16，那么当 hashmap 中元素个数超过 16 0.75=12 的时候，就把数组的大小扩展为 2 16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知 hashmap 中元素的个数，那么预设元素的个数能够有效的提高 hashmap 的性能。比如说，我们有 1000 个元素 new HashMap(1000), 但是理论上来讲 new HashMap(1024) 更合适，不过上面 annegu 已经说过，即使是 1000，hashmap 也自动会将其设置为 1024。 但是 new HashMap(1024) 还不是更合适的，因为 0.75*1000 &lt; 1000, 也就是说为了让 0.75 * size &gt; 1000, 我们必须这样 new HashMap(2048) 才最合适，既考虑了 &amp; 的问题，也避免了 resize 的问题。 87. List、Map、Set 三个接口，存取元素时，各有什么特点？ 这样的题属于随意发挥题：这样的题比较考水平，两个方面的水平：一是要真正明白这些内容，二是要有较强的总结和表述能力。如果你明白，但表述不清楚，在别人那里则等同于不明白。 首先，List 与 Set 具有相似性，它们都是单列元素的集合，所以，它们有一个功共同的父接口，叫 Collection。Set 里面不允许有重复的元素，所谓重复，即不能有两个相等（注意，不是仅仅是相同）的对象 ，即假设 Set 集合中有了一个 A 对象，现在我要向 Set 集合再存入一个 B 对象，但 B 对象与 A 对象 equals 相等，则 B 对象存储不进去，所以，Set 集合的 add 方法有一个 boolean 的返回值，当集合中没有某个元素，此时 add 方法可成功加入该元素时，则返回 true，当集合含有与某个元素 equals 相等的元素时，此时 add 方法无法加入该元素，返回结果为 false。Set 取元素时，没法说取第几个，只能以 Iterator 接口取得所有的元素，再逐一遍历各个元素。 List 表示有先后顺序的集合， 注意，不是那种按年龄、按大小、按价格之类的排序。当我们多次调用 add(Obj e) 方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来后到的顺序排序。有时候，也可以插队，即调用 add(int index,Obj e) 方法，就可以指定当前对象在集合中的存放位置。一个对象可以被反复存储进 List 中，每调用一次 add 方法，这个对象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被 add 多次时，即相当于集合中有多个索引指向了这个对象，如图 x 所示。List 除了可以以 Iterator 接口取得所有的元素，再逐一遍历各个元素之外，还可以调用 get(index i) 来明确说明取第几个。 Map 与 List 和 Set 不同，它是双列的集合，其中有 put 方法，定义如下：put(obj key,obj value)，每次存储时，要存储一对 key/value，不能存储重复的 key，这个重复的规则也是按 equals 比较相等。取则可以根据 key 获得相应的 value，即 get(Object key) 返回值为 key 所对应的 value。另外，也可以获得所有的 key 的结合，还可以获得所有的 value 的结合，还可以获得 key 和 value 组合成的 Map.Entry 对象的集合。 List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素, 内部排序。Map 保存 key-value 值，value 可多值。 HashSet 按照 hashcode 值的某种运算方式进行存储，而不是直接按 hashCode 值的大小进行存储。例如，”abc” —&gt; 78，”def” —&gt; 62，”xyz” —&gt; 65 在 hashSet 中的存储顺序不是 62,65,78，这些问题感谢以前一个叫崔健的学员提出，最后通过查看源代码给他解释清楚，看本次培训学员当中有多少能看懂源码。LinkedHashSet 按插入的顺序存储，那被存储对象的 hashcode 方法还有什么作用呢？学员想想! hashset 集合比较两个对象是否相等，首先看 hashcode 方法是否相等，然后看 equals 方法是否相等。new 两个 Student 插入到 HashSet 中，看 HashSet 的 size，实现 hashcode 和 equals 方法后再看 size。 同一个对象可以在 Vector 中加入多次。往集合里面加元素，相当于集合里用一根绳子连接到了目标对象。往 HashSet 中却加不了多次的。 88. Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用 == 还是 equals()? 它们有何区别? Set 里的元素是不能重复的，元素重复与否是使用 equals() 方法进行判断的。 equals() 和 == 方法决定引用值是否指向同一对象 equals() 在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。 89. 两个对象值相同 (x.equals(y) == true)，但却可有不同的 hash code，这句话对不对? 对。如果对象要保存在 HashSet 或 HashMap 中，它们的 equals 相等，那么，它们的 hashcode 值就必须相等。 如果不是要保存在 HashSet 或 HashMap，则与 hashcode 没有什么关系了，这时候 hashcode 不等是可以的，例如 arrayList 存储的对象就不用实现 hashcode，当然，我们没有理由不实现，通常都会去实现的。 90. heap 和 stack 有什么区别。 Java 的内存分为两类，一类是 栈内存 ，一类是 堆内存 。栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。 堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用 new 创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用 final 修饰后，放在堆中，而不是栈中。 91. Java 集合类框架的基本接口有哪些？ 集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它 自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。 Java 集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java 集合类里面 最基本的接口有： Collection： 代表一组对象，每一个对象都是它的子元素。 Set： 不包含重复元素的 Collection。 List： 有顺序的 collection，并且可以包含重复元素。 Map： 可以把键 (key) 映射到值 (value) 的对象，键不能重复。 92. HashSet 和 TreeSet 有什么区别？ HashSet 是由一个 hash 表来实现的，因此，它的元素是无序的。add()，remove()，contains() TreeSet 是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()， remove()，contains() 方法的时间复杂度是 O(logn)。 93. HashSet 的底层实现是什么? 通过看源码知道 HashSet 的实现是依赖于 HashMap 的，HashSet 的值都是存储在 HashMap 中的。在 HashSet 的构造法中会初始化一个 HashMap 对象，HashSet 不允许值重复，因此，HashSet 的值是作为 HashMap 的 key 存储在 HashMap 中的，当存储的值已经存在时返回 false。 94. LinkedHashMap 的实现原理? LinkedHashMap 也是基于 HashMap 实现的，不同的是它定义了一个 Entry header，这个 header 不是放在 Table 里，它是额外独立出来的。LinkedHashMap 通过继承 hashMap 中的 Entry, 并添加两个属性 Entry before,after, 和 header 结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。LinkedHashMap 定义了排序模式 accessOrder，该属性为 boolean 型变量，对于访问顺序，为 true；对于插入顺序，则为 false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。 95. 为什么集合类没有实现 Cloneable 和 Serializable 接口？ 克隆 (cloning) 或者是序列化 (serialization) 的语义和含义是跟具体的实现相关的。因此，应该 由集合类的具体实现来决定如何被克隆或者是序列化。 96. 什么是迭代器 (Iterator)？ Iterator 接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代 器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素, 但是不可以直接调用集合的 remove(Object Obj) 删除，可以通过迭代器的 remove() 方法删除。 97. Iterator 和 ListIterator 的区别是什么？ 下面列出了他们的区别： Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。 Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。 ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 98. 数组 (Array) 和列表 (ArrayList) 有什么区别？什么时候应该使用 Array 而不是 ArrayList？ Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。 Array 大小是固定的，ArrayList 的大小是动态变化的。 ArrayList 处理固定大小的基本数据类型的时候，这种方式相对比较慢。 99. Java 集合类框架的最佳实践有哪些？ 假如元素的大小是固 定的，而且能事先知道，我们就应该用 Array 而不是 ArrayList。 有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置 初始容量来避免重新计算 hash 值或者是扩容。 为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的 ClassCastException。 使用 JDK 提供的不变类 (immutable class) 作为 Map 的键可以避免为我们自己的类实现 hashCode()和 equals()方法。 编程的时候接口优于实现。 底层的集合实际上是空的情况下，返回长度是 0 的集合或者是数组，不要返回 null。 100. Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢？是用 == 还是 equals()？它们有何区别？* Set 里的元素是不能重复的，那么用 iterator() 方法来区分重复与否。equals() 是判读两个 Set 是否相等 equals() 和 == 方法决定引用值是否指向同一对象 equals() 在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值 101. Comparable 和 Comparator 接口是干什么的？列出它们的区别。 Java 提供了只包含一个 compareTo() 方法的 Comparable 接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。 Java 提供了包含 compare() 和 equals() 两个方法的 Comparator 接口。compare() 方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals() 方法需要一个对象作为参数，它用来决定输入参数是否和 comparator 相等。只有当输入参数也是一个 comparator 并且输入参数和当前 comparator 的排序结果是相同的时 候，这个方法才返回 true。 102. Collection 和 Collections 的区别。 collection 是集合类的上级接口, 继承与它的接口主要是 set 和 list。 collections 类是针对集合类的一个帮助类. 它提供一系列的静态方法对各种集合的搜索, 排序, 线程安全化等操作。 IO 流103. 字节流与字符流的区别。 要把一片二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为 IO 流，对应的抽象类为 OutputStream 和 InputStream ，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。 在应用中，经常要完全是字符的一段文本输出去或读进来，用字节流可以吗？计算机中的一切最终都是二进制的字节形式存在。对于 “中国” 这些字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。 底层设备永远只接受 字节数据 ，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向 IO 设别写入或读取字符串提供了一点点方便。 字符向字节转换时，要注意编码的问题，因为字符串转成字节数组， 其实是转成该字符的某种编码的字节形式，读取也是反之的道理。 讲解字节流与字符流关系的代码案例： 123456789101112131415161718192021222324252627282930313233343536import java.io.BufferedReader;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.FileReader;import java.io.FileWriter;import java.io.InputStreamReader;import java.io.PrintWriter;public class IOTest { public static void main(String[] args) throws Exception { String str = &quot;中国人&quot;; /*FileOutputStream fos = new FileOutputStream(&quot;1.txt&quot;); fos.write(str.getBytes(&quot;UTF-8&quot;)); fos.close();*/ /*FileWriter fw = new FileWriter(&quot;1.txt&quot;); fw.write(str); fw.close();*/ PrintWriter pw = new PrintWriter(&quot;1.txt&quot;,&quot;utf-8&quot;); pw.write(str); pw.close(); /*FileReader fr = new FileReader(&quot;1.txt&quot;); char[] buf = new char[1024]; int len = fr.read(buf); String myStr = new String(buf,0,len); System.out.println(myStr);*/ /*FileInputStream fr = new FileInputStream(&quot;1.txt&quot;); byte[] buf = new byte[1024]; int len = fr.read(buf); String myStr = new String(buf,0,len,&quot;UTF-8&quot;); System.out.println(myStr);*/ BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;1.txt&quot;),&quot;UTF-8&quot;)); String myStr = br.readLine(); br.close(); System.out.println(myStr); }} 104. 什么是 Java 序列化，如何实现 Java 序列化？或者请解释 Serializable 接口的作用。 我们有时候将一个 Java 对象变成字节流的形式传出去或者从一个字节流中恢复成一个 Java 对象，例如，要将 Java 对象存储到硬盘或者传送给网络上的其他计算机，这个过程我们可以自己写代码去把一个 Java 对象变成某个格式的字节流再传输，但是，jre 本身就提供了这种支持，我们可以调用 OutputStream 的 writeObject 方法来做，如果要让 Java 帮我们做，要被传输的对象必须实现 serializable 接口，这样，javac 编译时就会进行特殊处理，编译的类才可以被 writeObject 方法操作，这就是所谓的序列化。需要被序列化的类必须实现 Serializable 接口，该接口是一个 mini 接口，其中没有需要实现的方法，implements Serializable 只是为了标注该对象是可被序列化的。 例如，在 web 开发中，如果对象被保存在了 Session 中，tomcat 在重启时要把 Session 对象序列化到硬盘，这个对象就必须实现 Serializable 接口。如果对象要经过分布式系统进行网络传输或通过 rmi 等远程调用，这就需要在网络上传输对象，被传输的对象就必须实现 Serializable 接口。 数据库105. 请简洁描述 MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？ SQL 标准定义的四个隔离级别为： read uncommited ： 读到未提交数据 read committed： 脏读，不可重复读 repeatable read： 可重读 serializable ： 串行事物 106. 在 MySQL 中 ENUM 的用法是什么？ ENUM 是一个字符串对象，用于指定一组预定义的值，并可在创建表时使用。 SQL 语法如下： 1Create table size(name ENUM('Smail,'Medium','Large'); 107. CHAR 和 VARCHAR 的区别？ CHAR 和 VARCHAR 类型在存储和检索方面有所不同。 CHAR 列长度固定为创建表时声明的长度，长度值范围是 1 到 255。 当 CHAR 值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需删除尾随空格。 108. 列的字符串类型可以是什么？ 字符串类型是： SET BLOB ENUM CHAR TEXT VARCHAR 109. MySQL 中使用什么存储引擎？ 存储引擎称为表类型，数据使用各种技术存储在文件中。 技术涉及： Storage mechanism Locking levels Indexing Capabilities and functions. 110. TIMESTAMP 在 UPDATE CURRENT_TIMESTAMP 数据类型上做什么？ 创建表时 TIMESTAMP 列用 Zero 更新。只要表中的其他字段发生更改，UPDATE CURRENT_TIMESTAMP 修饰符就将时间戳字段更新为当前时间。 111. 主键和候选键有什么区别？ 表格的每一行都由主键唯一标识, 一个表只有一个主键。 主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。 112. MySQL 数据库服务器性能分析的方法命令有哪些? Show status 一些值得监控的变量值： Bytes received 和 Bytes sent 和服务器之间来往的流量。 Com 服务器正在执行的命令。 Created 在查询执行期限间创建的临时表和文件。 Handler 存储引擎操作。 Select 不同类型的联接执行计划。 Sort_* 几种排序信息。 Show session status like ‘Select’; Show profiles SET profiling=1; Show profiles\\G Show profile; 113. LIKE 和 REGEXP 操作有什么区别？ LIKE 和 REGEXP 运算符用于表示 ^ 和％。 12SELECT * FROM &lt;tablename&gt; WHERE * REGEXP &quot;^b&quot;;SELECT * FROM &lt;tablename&gt; WHERE * LIKE &quot;%b&quot;; 114. BLOB 和 TEXT 有什么区别？ BLOB BLOB 是一个二进制对象，可以容纳可变数量的数据。有四种类型的 BLOB TINYBLOB BLOB MEDIUMBLOB 和 LONGBLOB 它们只能在所能容纳价值的最大长度上有所不同。 TEXT TEXT 是一个不区分大小写的 BLOB。四种 TEXT 类型 TINYTEXT TEXT MEDIUMTEXT 和 LONGTEXT 它们对应于四种 BLOB 类型，并具有相同的最大长度和存储要求。 BLOB 和 TEXT 类型之间的唯一区别在于对 BLOB 值进行排序和比较时区分大小写，对 TEXT 值不区分大小写。 115. 数据库的三范式？ 第一范式：数据库表的每一个字段都是不可分割的。 第二范式：数据库表中的非主属性只依赖于主键。 第三范式：不存在非主属性对关键字的传递函数依赖关系。 116. MySQL 表中允许有多少个 TRIGGERS？ 在 MySQL 表中允许有六个触发器，如下： BEFORE INSERT AFTER INSERT BEFORE UPDATE AFTER UPDATE BEFORE DELETE and AFTER DELETE 117. 什么是通用 SQL 函数？ 数学函数 Abs（num）求绝对值 floor（num）向下取整 ceil（num）向上取整 字符串函数 insert (s1,index,length,s2) 替换函数 S1 表示被替换的字符串 s2 表示将要替换的字符串 Index 表示被替换的位置, 从 1 开始 Lebgth 表示被替换的长度 upper（str），ucase（str）将字母改为大写 lower（str），lcase（str）将字母改为小写 left（str，length）返回 str 字符串的前 length 个字符 right（str，length）返回 str 字符串的后 length 个字符 substring（str，index，length）返回 str 字符串从 index 位开始长度为 length 个字符（index 从 1 开始） reverse（str）将 str 字符串倒序输出 日期函数 curdate（）、current_date( ) 获取当前日期 curtime（）、current_time( ) 获取当前日期 now（）获取当前日期和时间 datediff（d1、d2）d1 和 d2 之间的天数差 adddate（date，num）返回 date 日期开始，之后 num 天的日期 subdate（date，num）返回 date 日期开始，之前 num 天的日期 聚合函数 Count（字段）根据某个字段统计总记录数（当前数据库保存到多少条数据） sum（字段）计算某个字段的数值总和 avg（字段）计算某个字段的数值的平均值 Max（字段）、min（字段）求某个字段最大或最小值 118. MySQL 中有哪几种锁？* MyISAM 支持表锁，InnoDB 支持表锁和行锁，默认为行锁。 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。 119. MySQL 数据优化。 优化数据类型 避免使用 NULL，NULL 需要特殊处理, 大多数时候应该使用 NOT NULL，或者使用一个特殊的值，如 0，-1 作为默认值。 仅可能使用更小的字段，MySQL 从磁盘读取数据后是存储到内存中的，然后使用 cpu 周期和磁盘 I/O 读取它，这意味着越小的数据类型占用的空间越小. 小心字符集转换 客户端或应用程序使用的字符集可能和表本身的字符集不一样，这需要 MySQL 在运行过程中隐含地进行转换，此外，要确定字符集如 UTF-8 是否支持多字节字符，因此它们需要更多的存储空间。 _ 优化 count(my col) 和 count( ) * 优化子查询 遇到子查询时，MySQL 查询优化引擎并不是总是最有效的，这就是为什么经常将子查询转换为连接查询的原因了，优化器已经能够正确处理连接查询了，当然要注意的一点是，确保连接表 (第二个表) 的连接列是有索引的，在第一个表上 MySQL 通常会相对于第二个表的查询子集进行一次全表扫描，这是嵌套循环算法的一部分。 优化 UNION 在跨多个不同的数据库时使用 UNION 是一个有趣的优化方法，UNION 从两个互不关联的表中返回数据，这就意味着不会出现重复的行，同时也必须对数据进行排序，我们知道排序是非常耗费资源的，特别是对大表的排序。 UNION ALL 可以大大加快速度，如果你已经知道你的数据不会包括重复行，或者你不在乎是否会出现重复的行，在这两种情况下使用 UNION ALL 更适合。此外，还可以在应用程序逻辑中采用某些方法避免出现重复的行，这样 UNION ALL 和 UNION 返回的结果都是一样的，但 UNION ALL 不会进行排序。 120. MySQL 的关键字。 添加索引： 1alter table tableName add 索引（索引字段） 主键：primary key 唯一：unique 全局：fulltext 普通：index 多列： index index_name 页级: 引擎 BDB。次锁定相邻的一组记录。 表级: 引擎 MyISAM ， 理解为锁住整个表，可以同时读，写不行。 行级: 引擎 INNODB ， 单独的一行记录加锁，对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。 表级锁速度快，但冲突多，行级冲突少，但速度慢。 121. 存储引擎。 存储引擎说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。 MyISAM：这种引擎是 mysql 最早提供的。这种引擎又可以分为静态 MyISAM、动态 MyISAM 和压缩 MyISAM 三种： 静态 MyISAM：如果数据表中的各数据列的长度都是预先固定好的，服务器将自动选择这种表类型。因为数据表中每一条记录所占用的空间都是一样的，所以这种表存取和更新的效率非常高。当数据受损时，恢复工作也比较容易做。 动态 MyISAM：如果数据表中出现 varchar、text 或 BLOB 字段时，服务器将自动选择这种表类型。相对于静态 MyISAM，这种表存储空间比较小，但由于每条记录的长度不一，所以多次修改数据后，数据表中的数据就可能离散的存储在内存中，进而导致执行效率下降。同时，内存中也可能会出现很多碎片。因此，这种类型的表要经常用 optimize table 命令或优化工具来进行碎片整理。 压缩 MyISAM：以上说到的两种类型的表都可以用 myisamchk 工具压缩。这种类型的表进一步减小了占用的存储，但是这种表压缩之后不能再被修改。另外，因为是压缩数据，所以这种表在读取的时候要先时行解压缩。 但是，不管是何种 MyISAM 表，目前它都不支持事务，行级锁和外键约束的功能。 MyISAM Merge 引擎：这种类型是 MyISAM 类型的一种变种。合并表是将几个相同的 MyISAM 表合并为一个虚表。常应用于日志和数据仓库。 InnoDB：InnoDB 表类型可以看作是对 MyISAM 的进一步更新产品，它提供了事务、行级锁机制和外键约束的功能。 memory(heap)：这种类型的数据表只存在于内存中。它使用散列索引，所以数据的存取速度非常快。因为是存在于内存中，所以这种类型常应用于临时表中。 archive：这种类型只支持 select 和 insert 语句，而且不支持索引。 Desc[ribe] tablename：查看数据表的结构。 show engines：命令可以显示当前数据库支持的存储引擎情况。 122. 数据库备份。 必须要在未登录状态下 导出整个数据库 1mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名 导出一个表 1mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名 导出一个数据库结构 1mysqldump -u dbuser -p -d --add-drop-table dbname &gt;d:/dbname_db.sql -d 没有数据 –add-drop-table 在每个 create 语句之前增加一个 drop table 123. truncate delete drop 的区别。 drop(DDL 语句)： 是不可逆操作，会将表所占用空间全部释放掉； truncate(DDL 语句)： 只针对于删除表的操作，在删除过程中不会激活与表有关的删除触发器并且不会把删除记录放在日志中；当表被 truncate 后，这个表和索引会恢复到初始大小； delete(DML 语句)： 可以删除表也可以删除行，但是删除记录会被计入日志保存，而且表空间大小不会恢复到原来； 执行速度：drop&gt;truncate&gt;delete。 124. Redis 是什么？两句话做一下概括。 是一个完全开源免费的 key-value 内存数据库 2. 通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets。 Redis 使用最佳方式是全部数据 in-memory。 Redis 更多场景是作为 Memcached 的替代者来使用。 当需要除 key/value 之外的更多数据类型支持时，使用 Redis 更合适。 当存储的数据不能被剔除时，使用 Redis 更合适。 125. Redis（管道，哈希）。* Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。 Redis 支持数据的备份，即 master-slave 模式的数据备份。 Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 126. Redis 实现原理或机制。* Redis 是一个 key-value 存储系统。和 Memcached 类似，但是解决了断电后数据完全丢失的情况，而且她支持更多无化的 value 类型，除了和 string 外，还支持 lists（链表）、sets（集合）和 zsets（有序集合）几种数据类型。这些数据类型都支持 push/pop、add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。 Redis 是一种基于客户端 - 服务端模型以及请求 / 响应协议的 TCP 服务。这意味着通常情况下一个请求会遵循以下步骤： 客户端向服务端发送一个查询请求，并监听 Socket 返回，通常是以阻塞模式，等待服务端响应。服务端处理命令，并将结果返回给客户端。 在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。 Redis 管道技术最显著的优势是提高了 Redis 服务的性能。 分区是分割数据到多个 Redis 实例的处理过程，因此每个实例只保存 key 的一个子集。 通过利用多台计算机内存的和值，允许我们构造更大的数据库。 通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。 Redis 的一些特性在分区方面表现的不是很好： 涉及多个 key 的操作通常是不被支持的。举例来说，当两个 set 映射到不同的 Redis 实例上时，你就不能对这两个 set 执行交集操作。 涉及多个 key 的 Redis 事务不能使用。 当使用分区时，数据处理较为复杂，比如你需要处理多个 rdb/aof 文件，并且从多个实例和主机备份持久化文件。 增加或删除容量也比较复杂。Redis 集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做 presharding 的技术对此是有帮助的。 127. Redis 有两种类型分区。 最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的 Redis 实例。 比如，ID 从 0 到 10000 的用户会保存到实例 R0，ID 从 10001 到 20000 的用户会保存到 R1，以此类推。 这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各 种对象的映射表，通常对 Redis 来说并非是好的方法。 哈希分区：另外一种分区方法是 hash 分区。这对任何 key 都适用，也无需是 object_name: 这种形式，像下面描述的一样简单： 用一个 hash 函数将 key 转换为一个数字，比如使用 crc32 hash 函数。对 key foobar 执行 crc32(foobar) 会输出类似 93024922 的整数。 对这个整数取模，将其转化为 0-3 之间的数字，就可以将这个整数映射到 4 个 Redis 实例中的一个了。93024922 % 4 = 2，就是说 key foobar 应该被存到 R2 实例中。注意：取模操作是取除的余数，通常在多种编程语言中用 % 操作符实现。 实际上，上面的集群模式还存在两个问题： 扩容问题： 因为使用了一致性哈稀进行分片，那么不同的 key 分布到不同的 Redis-Server 上，当我们需要扩容时，需要增加机器到分片列表中，这时候会使得同样的 key 算出来落到跟原来不同的机器上，这样如果要取某一个值，会出现取不到的情况，对于这种情况，Redis 的作者提出了一种名为 Pre-Sharding 的方式： Pre-Sharding 方法是将每一个台物理机上，运行多个不同断口的 Redis 实例，假如有三个物理机，每个物理机运行三个 Redis 实际，那么我们的分片列表中实际有 9 个 Redis 实例，当我们需要扩容时，增加一台物理机，步骤如下： 在新的物理机上运行 Redis-Server； 该 Redis-Server 从属于 (slaveof) 分片列表中的某一 Redis-Server（假设叫 RedisA）； 等主从复制 (Replication) 完成后，将客户端分片列表中 RedisA 的 IP 和端口改为新物理机上 Redis-Server 的 IP 和端口； 停止 RedisA。 这样相当于将某一 Redis-Server 转移到了一台新机器上。Prd-Sharding 实际上是一种在线扩容的办法，但还是很依赖 Redis 本身的复制功能的，如果主库快照数据文件过大，这个复制的过程也会很久，同时会给主库带来压力。所以做这个拆分的过程最好选择为业务访问低峰时段进行。 单点故障问题： 还是用到 Redis 主从复制的功能，两台物理主机上分别都运行有 Redis-Server，其中一个 Redis-Server 是另一个的从库，采用双机热备技术，客户端通过虚拟 IP 访问主库的物理 IP，当主库宕机时，切换到从库的物理 IP。只是事后修复主库时，应该将之前的从库改为主库（使用命令 slaveof no one），主库变为其从库（使命令 slaveof IP PORT），这样才能保证修复期间新增数据的一致性。 128. 什么是 MongoDB。 非关系型数据库 (NoSql),Mongo DB 很好的实现了面向对象的思想 (OO 思想), 在 Mongo DB 中 每一条记录都是一个 Document 对象。Mongo DB 最大的优势在于所有的数据持久操作都无需开发人员手动编写 SQL 语句, 直接调用方法就可以轻松的实现 CRUD 操作. 129. MongoDB 特点。 高性能、易部署、易使用，存储数据非常方便。主要功能特性有： 面向集合存储，易存储对象类型的数据。 模式自由。 支持动态查询。 支持完全索引，包含内部对象。 支持查询。 支持复制和故障恢复。 使用高效的二进制数据存储，包括大型对象（如视频等）。 自动处理碎片，以支持云计算层次的扩展性 支持 Python，PHP，Ruby，Java，C，C#，Javascript，Perl 及 C++ 语言的驱动程序，社区中也提供了对 Erlang 及. NET 等平台的驱动程序。 文件存储格式为 BSON（一种 JSON 的扩展）。 可通过网络访问。 130. MongoDB 的功能。 面向集合的存储：适合存储对象及 JSON 形式的数据。 动态查询：Mongo 支持丰富的查询表达式。查询指令使用 JSON 形式的标记，可轻易查询文档中内嵌的对象及数组。 完整的索引支持：包括文档内嵌对象及数组。Mongo 的查询优化器会分析查询表达式，并生成一个高效的查询计划。 查询监视：Mongo 包含一个监视工具用于分析数据库操作的性能。 复制及自动故障转移：Mongo 数据库支持服务器之间的数据复制，支持主 - 从模式及服务器之间的相互复制。复制的主要目标是提供冗余及自动故障转移。 高效的传统存储方式：支持二进制数据及大型对象（如照片或图片） 自动分片以支持云级别的伸缩性：自动分片功能支持水平的数据库集群，可动态添加额外的机器。 131. MongoDB 的适用场景。 网站数据：Mongo 非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。 缓存：由于性能很高，Mongo 也适合作为信息基础设施的缓存层。在系统重启之后，由 Mongo 搭建的持久化缓存层可以避免下层的数据源 过载。 大尺寸，低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储。 高伸缩性的场景：Mongo 非常适合由数十或数百台服务器组成的数据库。Mongo 的路线图中已经包含对 MapReduce 引擎的内置支持。 用于对象及 JSON 数据的存储：Mongo 的 BSON 数据格式非常适合文档化格式的存储及查询。 132. Redis、memcache、MongoDB 对比。 mongodb 和 memcached 不是一个范畴内的东西。mongodb 是文档型的非关系型数据库，其优势在于查询功能比较强大，能存储海量数据。 和 memcached 更为接近的是 Redis。它们都是内存型数据库，数据保存在内存中，通过 tcp 直接存取，优势是速度快，并发高，缺点是数据类型有限，查询功能不强，一般用作缓存。 性能 Redis 和 memcache 差不多，要大于 mongodb。 操作的便利性 memcache 数据结构单一。 Redis 丰富一些，数据操作方面，Redis 更好一些，较少的网络 IO 次数。 mongodb 支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富。 内存空间的大小和数据量的大小 Redis 在 2.0 版本后增加了自己的 VM 特性，突破物理内存的限制；可以对 key value 设置过期时间（类似 memcache）。 memcache 可以修改最大可用内存, 采用 LRU 算法。 mongoDB 适合大数据量的存储，依赖操作系统 VM 做内存管理，吃内存也比较厉害，服务不要和别的服务在一起。 可用性（单点问题） Redis 对于单点问题，依赖客户端来实现分布式读写；主从复制时，每次从节点重新连接主节点都要依赖整个快照, 无增量复制，因性能和效率问题，所以单点问题比较复杂；不支持自动 sharding, 需要依赖程序设定一致 hash 机制。一种替代方案是，不用 Redis 本身的复制机制，采用自己做主动复制（多份存储），或者改成增量复制的方式（需要自己实现），一致性问题和性能的权衡。 Memcache 本身没有数据冗余机制，也没必要；对于故障预防，采用依赖成熟的 hash 或者环状的算法，解决单点故障引起的抖动问题。 mongoDB 支持 master-slave,replicaset（内部采用 paxos 选举算法，自动故障恢复）,auto sharding 机制，对客户端屏蔽了故障转移和切分机制。 可靠性（持久化） 对于数据持久化和数据恢复，Redis 支持（快照、AOF）：依赖快照进行持久化，aof 增强了可靠性的同时，对性能有所影响。 memcache 不支持，通常用在做缓存, 提升性能； MongoDB 从 1.8 版本开始采用 binlog 方式支持持久化的可靠性。 数据一致性（事务支持） Memcache 在并发场景下，用 cas 保证一致性。 Redis 事务支持比较弱，只能保证事务中的每个操作连续执行。 mongoDB 不支持事务。 数据分析 mongoDB 内置了数据分析的功能 (mapreduce), 其他不支持。 应用场景 Redis：数据量较小的更性能操作和运算上。 memcache：用于在动态系统中减少数据库负载，提升性能; 做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用 sharding）。 MongoDB: 主要解决海量数据的访问效率问题。 133. Redis 有什么用？只有了解了它有哪些特性，我们在用的时候才能扬长避短，为我们所用。 速度快： 使用标准 C 写，所有数据都在内存中完成，读写速度分别达到 10 万 / 20 万。 持久化： 对数据的更新采用 Copy-on-write 技术，可以异步地保存到磁盘上，主要有两种策略，一是根据时间，更新次数的快照（save 300 10 ）二是基于语句追加方式 (Append-only file，aof) 。 自动操作： 对不同数据类型的操作都是自动的，很安全。 快速的主 – 从复制，官方提供了一个数据，Slave 在 21 秒即完成了对 Amazon 网站 10G key set 的复制。 Sharding 技术： 很容易将数据分布到多个 Redis 实例中，数据库的扩展是个永恒的话题，在关系型数据库中，主要是以添加硬件、以分区为主要技术形式的纵向扩展解决了很多的应用场景，但随着 web2.0、移动互联网、云计算等应用的兴起，这种扩展模式已经不太适合了，所以近年来，像采用主从配置、数据库复制形式的，Sharding 这种技术把负载分布到多个特理节点上去的横向扩展方式用处越来越多。 134. 这里对 Redis 数据库做下小结。 提高了 DB 的可扩展性，只需要将新加的数据放到新加的服务器上就可以了 提高了 DB 的可用性，只影响到需要访问的 shard 服务器上的数据的用户 提高了 DB 的可维护性，对系统的升级和配置可以按 shard 一个个来搞，对服务产生的影响较小 小的数据库存的查询压力小，查询更快，性能更好Java WEB 135. Tomcat 的优化经验。 Tomcat 作为 Web 服务器，它的处理性能直接关系到用户体验，下面是几种常见的优化措施: 去掉对 web.xml 的监视，把 jsp 提前编辑成 Servlet。有富余物理内存的情况，加大 tomcat 使用的 jvm 的内存。 服务器资源 服务器所能提供 CPU、内存、硬盘的性能对处理能力有决定性影响。 对于高并发情况下会有大量的运算，那么 CPU 的速度会直接影响到处理速度。 内存在大量数据处理的情况下，将会有较大的内存容量需求，可以用 - Xmx -Xms -XX:MaxPermSize 等参数对内存不同功能块进行划分。我们之前就遇到过内存分配不足，导致虚拟机一直处于 full GC，从而导致处理能力严重下降。 硬盘主要问题就是读写性能，当大量文件进行读写时，磁盘极容易成为性能瓶颈。最好的办法还是利用下面提到的缓存。 利用缓存和压缩 对于静态页面最好是能够缓存起来，这样就不必每次从磁盘上读。这里我们采用了 Nginx 作为缓存服务器，将图片、css、js 文件都进行了缓存，有效的减少了后端 tomcat 的访问。 另外，为了能加快网络传输速度，开启 gzip 压缩也是必不可少的。但考虑到 tomcat 已经需要处理很多东西了，所以把这个压缩的工作就交给前端的 Nginx 来完成。 除了文本可以用 gzip 压缩，其实很多图片也可以用图像处理工具预先进行压缩，找到一个平衡点可以让画质损失很小而文件可以减小很多。曾经我就见过一个图片从 300 多 kb 压缩到几十 kb，自己几乎看不出来区别。 采用集群 单个服务器性能总是有限的，最好的办法自然是实现横向扩展，那么组建 tomcat 集群是有效提升性能的手段。我们还是采用了 Nginx 来作为请求分流的服务器，后端多个 tomcat 共享 session 来协同工作。可以参考之前写的《利用 nginx+tomcat+memcached 组建 web 服务器负载均衡》。 优化 tomcat 参数 这里以 tomcat7 的参数配置为例，需要修改 conf/server.xml 文件，主要是优化连接配置，关闭客户端 dns 查询。 12345678910&lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; maxThreads=&quot;500&quot; minSpareThreads=&quot;20&quot; acceptCount=&quot;100&quot; disableUploadTimeout=&quot;true&quot; enableLookups=&quot;false&quot; URIEncoding=&quot;UTF-8&quot; /&gt; 136. HTTP 请求的 GET 与 POST 方式的区别。 GET 请求，请求的数据会附加在 URL 之后，以 ? 分割 URL 和传输数据，多个参数用 &amp; 连接。URL 的编码格式采用的是 ASCII 编码，而不是 unicode，即是说所有的非 ASCII 字符都要编码之后再传输。 POST 请求：POST 请求会把请求的数据放置在 HTTP 请求包的包体中。 因此，GET 请求的数据会暴露在地址栏中，而 POST 请求则不会。 传输数据的大小 在 HTTP 规范中，没有对 URL 的长度和传输的数据大小进行限制。但是在实际开发过程中，对于 GET，特定的浏览器和服务器对 URL 的长度有限制。因此，在使用 GET 请求时，传输数据会受到 URL 长度的限制。 对于 POST，由于不是 URL 传值，理论上是不会受限制的，但是实际上各个服务器会规定对 POST 提交数据大小进行限制，Apache、IIS 都有各自的配置。 安全性 POST 的安全性比 GET 的高。这里的安全是指真正的安全，而不同于上面 GET 提到的安全方法中的安全，上面提到的安全仅仅是不修改服务器的数据。比如，在进行登录操作，通过 GET 请求，用户名和密码都会暴露再 URL 上，因为登录页面有可能被浏览器缓存以及其他人查看浏览器的历史记录的原因，此时的用户名和密码就很容易被他人拿到了。除此之外，GET 请求提交的数据还可能会造成 Cross-site request frogery 攻击。 HTTP 中的 GET，POST，SOAP 协议都是在 HTTP 上运行的。 137. 解释一下什么是 Servlet。* Servlet 是一种服务器端的 Java 应用程序，具有独立于平台和协议的特性, 可以生成动态的 Web 页面。 它担当客户请求（Web 浏览器或其他 HTTP 客户程序）与服务器响应（HTTP 服务器上的数据库或应用程序）的中间层。 Servlet 是位于 Web 服务器内部的服务器端的 Java 应用程序，与传统的从命令行启动的 Java 应用程序不同，Servlet 由 Web 服务器进行加载，该 Web 服务器必须包含支持 Servlet 的 Java 虚拟机。 138. 说一说 Servlet 的生命周期。 Servlet 有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由 javax.servlet.Servlet 接口的 init、service 和 destroy 方法表达。 Servlet 被服务器实例化后，容器运行其 init 方法，请求到达时运行其 service 方法，service 方法自动派遣运行与请求对应的 doXxx 方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其 destroy 方法。 web 容器加载 Servlet，生命周期开始。通过调用 Servlet 的 init() 方法进行 Servlet 的初始化。通过调用 service() 方法实现，根据请求的不同调用不同的 do***() 方法。结束服务，web 容器调用 Servlet 的 destroy() 方法。 139. Servlet API 中 forward() 与 redirect() 的区别？ 前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量使用 forward() 方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用 sendRedirect() 方法。 140. request.getAttribute() 和 request.getParameter() 有何区别? getParameter 是用来接受用 post 或 get 方法传递过来的参数的。 getAttribute 必须先 setAttribute。 request.getParameter() 取得是通过容器的实现来取得通过类似 post，get 等方式传入的数据，request.setAttribute() 和 getAttribute() 只是在 web 容器内部流转，仅仅是请求处理阶段。 request.getParameter() 方法传递的数据，会从 Web 客户端传到 Web 服务器端，代表 HTTP 请求数据。request.getParameter() 方法返回 String 类型的数据。 request.setAttribute() 和 getAttribute() 方法传递的数据只会存在于 Web 容器内部。还有一点就是，HttpServletRequest 类有 setAttribute() 方法，而没有 setParameter() 方法。 141. JSP 有哪些动作? 作用分别是什么? JSP 共有以下 6 种基本动作： jsp:include：在页面被请求的时候引入一个文件。 jsp:useBean：寻找或者实例化一个 JavaBean。 jsp:setProperty：设置 JavaBean 的属性。 jsp:getProperty：输出某个 JavaBean 的属性。 jsp:forward：把请求转到一个新的页面。 jsp:plugin：根据浏览器类型为 Java 插件生成 OBJECT 或 EMBED 标记。 142. JSP 的常用指令。 常用的指令有三个：page、include、taglib; page 指令 &lt;%@page language=”java” contentType=”text/html;charset=gb2312” session=”true” buffer=”64kb” autoFlush=”true” isThreadSafe=”true” info=”text” errorPage=”error.jsp” isErrorPage=”true” isELIgnored=” true” pageEncoding=”gb2312” import=”java.sql.*”%&gt; 说明: isErrorPage(是否能使用 Exception 对象)，isELIgnored(是否忽略表达式) include 指令 &lt;%@ include file=”filename”%&gt; taglib 指令 &lt;%@ taglib prefix=”c”uri=”http://……”%&gt; 143. JSP 和 Servlet 有哪些相同点和不同点，他们之间的联系是什么？ JSP 是 Servlet 技术的扩展，本质上是 Servlet 的简易方式，更强调应用的外表表达。JSP 编译后是 “类 servlet”。Servlet 和 JSP 最主要的不同点在于，Servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 HTML 里分离开来。而 JSP 的情况是 Java 和 HTML 可以组合成一个扩展名为. jsp 的文件。JSP 侧重于视图，Servlet 主要用于控制逻辑。 144. MVC 的各个部分都有那些技术来实现? 如何实现? MVC 是 Model－View－Controller 的简写。Model 代表的是应用的业务逻辑（通过 JavaBean，EJB 组件实现）， View 是应用的表示面（由 JSP 页面产生），Controller 是提供应用的处理过程控制（一般是一个 Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。 企业级框架145. 谈谈你对 Spring 的理解。 Spring 实现了 工厂模式的工厂类 （在这里有必要解释清楚什么是工厂模式），这个类名为 BeanFactory（实际上是一个接口），在程序中通常 BeanFactory 的子类 ApplicationContext。Spring 相当于一个大的工厂类，在其配置文件中通过 元素配置用于创建实例对象的类名和实例对象的属性。 Spring 提供了对** IOC** 良好支持，IOC 是一种编程思想，是一种架构艺术，利用这种思想可以很好地实现模块之间的解耦。IOC 也称为 DI（Depency Injection），什么叫依赖注入呢？譬如： 123456789101112class Programmer { Computer computer = null; public void code(){ //Computer computer = new IBMComputer(); //Computer computer = beanfacotry.getComputer(); computer.write(); } public void setComputer(Computer computer) { this.computer = computer; }} 另外两种方式都由依赖，第一个直接依赖于目标类，第二个把依赖转移到工厂上，第三个彻底与目标和工厂解耦了。在 spring 的配置文件中配置片段如下： 12345&lt;bean id=”computer” class=”cn.itcast.interview.Computer”&gt;&lt;/bean&gt;&lt;bean id=”programmer” class=”cn.itcast.interview.Programmer”&gt; &lt;property name=”computer” ref=”computer”&gt;&lt;/property&gt;&lt;/bean&gt; Spring 提供了对 AOP 技术的良好封装， AOP 称为 面向切面编程 ，就是系统中有很多各不相干的类的方法，在这些众多方法中要加入某种系统功能的代码，例如， 加入日志，加入权限判断，加入异常处理 ，这种应用称为 AOP。实现 AOP 功能采用的是代理技术，客户端程序不再调用目标，而调用代理类，代理类与目标类对外具有相同的方法声明，有两种方式可以实现相同的方法声明，一是实现相同的接口，二是作为目标的子类在，JDK 中采用 Proxy 类产生动态代理的方式为某个接口生成实现类，如果要为某个类生成子类，则可以用 CGLI B。在生成的代理类的方法中加入系统功能和调用目标类的相应方法，系统功能的代理以 Advice 对象进行提供，显然要创建出代理对象，至少需要目标类和 Advice 类。spring 提供了这种支持，只需要在 spring 配置文件中配置这两个元素即可实现代理和 aop 功能，例如: 1234&lt;bean id=”proxy” type=”org.spring.framework.aop.ProxyBeanFactory”&gt; &lt;property name=”target” ref=””&gt;&lt;/property&gt; &lt;property name=”advisor” ref=””&gt;&lt;/property&gt;&lt;/bean&gt; 146. 什么是 Spring 框架？Spring 框架有哪些主要模块？ Spring 框架是一个为 Java 应用程序的开发提供了 综合、广泛 的基础性支持的 Java 平台。Spring 帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring 框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成 Spring 框架，不必担心 Spring 是如何在后台进行工作的。 enter image description here Spring 框架至今已集成了 20 多个模块。这些模块主要被分如下图所示的核心容器、数据访问 / 集成、Web、AOP（面向切面编程）、工具、消息和测试模块。 147. 什么是控制反转 (IOC)？什么是依赖注入？ 控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。而绑定的过程是通过 “依赖注入” 实现的。 控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。 依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？ 在 Java 中依然注入有以下三种实现方式： 构造器注入 Setter 方法注入 接口注入 148. BeanFactory 和 ApplicationContext 有什么区别？ BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，以便在接收到客户端请求时将对应的 bean 实例化。 BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的配置中解放出来。BeanFactory 还包含了 bean 生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。 从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，根据请求分发 bean 的功能。但 application context 在此基础上还提供了其他的功能。 提供了支持国际化的文本消息 统一的资源文件读取方式 已在监听器中注册的 bean 的事件 以下是三种较常见的 ApplicationContext 实现方式： 1、ClassPathXmlApplicationContext ：从 classpath 的 XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。 1ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”); 2、FileSystemXmlApplicationContext ：由文件系统中的 XML 配置文件读取上下文。 1ApplicationContext context = new FileSystemXmlApplicationContext(“bean.xml”); 3、XmlWebApplicationContext ：由 Web 应用的 XML 文件读取上下文。 149. 谈谈你对 Hibernate 的理解。 Hibernate 是一个 ORM 框架，是对 JDBC 的封装。目的就是简化对数据库表访问的操作。 ORM 的意思是对象关系的映射，通过实体类与数据表建立映射，就可以通过持久层操作来代替 sql 语句操作数据库。 hibernate 的核心原理就是对象关系映射（ORM），就是通过 java 的反射机制来实现。 java 反射机制：在 java 运行状态中，对于任何一个类，都能够知道这个类的所有属性和方法，就是对于任意一个对象都能够调用他的任意属性和方法，这种动态获取信息以及动态调用的方法就是功能就是 java 的反射机制。 以上这些就是 hibernate 的核心原理。 使用 Hibernate 的基本流程是：配置 Configuration 对象、产生 SessionFactory、创建 session 对象，启动事务，完成 CRUD 操作，提交事务，关闭 session。 使用 Hibernate 时，先要配置 hibernate.cfg.xml 文件，其中配置数据库连接信息和方言等，还要为每个实体配置相应的 hbm.xml 文件，hibernate.cfg.xml 文件中需要登记每个 hbm.xml 文件。 在应用 Hibernate 时，重点要了解 Session 的缓存原理，级联，延迟加载和 hql 查询。 150. Hibernate 中的 update() 和 saveOrUpdate() 的区别，session 的 load() 和 get() 的区别。 saveorupdate() 如果传入的对象在数据库中有就做 update 操作，如果没有就做 save 操作。 save() 在数据库中生成一条记录，如果数据库中有，会报错说有重复的记录。 Hibernate 中 get 方法和 load 方法的根本区别如下。 如果你使用 load 方法，hibernate 认为该 id 对应的对象（数据库记录）在数据库中是一定存在的，所以它可以放心的使用，它可以放心的使用代理来延迟加载该对象。在用到对象中的其他属性数据时才查询数据库，但是万一数据库中不存在该记录，那没办法，只能抛异常 ObjectNotFoundException，所说的 load 方法抛异常是指在使用该对象的数据时，数据库中不存在该数据时抛异常，而不是在创建这个对象时。由于 session 中的缓存对于 hibernate 来说是个相当廉价的资源，所以在 load 时会先查一下 session 缓存看看该 id 对应的对象是否存在，不存在则创建代理。所以如果你知道该 id 在数据库中一定有对应记录存 在就可以使用 load 方法来实现延迟加载。 对于 get 方法，hibernate 会确认一下该 id 对应的数据是否存在，首先在 session 缓存中查找，然后在二级缓存中查找，还没有就查数据库，数据库中没有就返回 null。 虽然好多书中都这么说：“get() 永远只返回实体类”，但实际上这是不正确的，get 方法如果在 session 缓存中找到了该 id 对应的对象，如果刚好该对象前面是被代理过的，如被 load 方法使用过，或者被其他关联对象延迟加载过，那么返回的还是原先的代理对象，而不是实体类对象，如果该代理对象还没有加载实体数据（就是 id 以外的其他属性数据），那么它会查询二级缓存或者数据库来加载数据，但是返回的还是代理对象，只不过已经加载了实体数据。 前面已经讲了，get 方法首先查询 session 缓存，没有的话查询二级缓存，最后查询数据库；反而 load 方法创建时首先查询 session 缓存，没有就创建代理，实际使用数据时才查询二级缓存和数据库。 总之对于 get 和 load 的根本区别，一句话，Hibernate 对于 load 方法认为该数据在数据库中一定存在，可以放心的使用代理来延迟加载，如果在使用过程中发现了问题，就抛异常；而对于 get 方法，Hibernate 一定要获取到真实的数据，否则返回 null。 151. Hibernate 的 inverse 属性的作用？ inverse 属性，是在维护关联关系的时候起作用的。表示控制权是否转移。（在一方起作用） inverse , 控制反转。inverse = false 不反转，当前方有控制权；true 控制反转，当前方没有控制权。 维护关联关系中，是否设置 inverse 属性： 保存数据有影响。 如果设置控制反转，即 inverse=true，然后通过部门方维护关联关系。在保存部门的时候，同时保存员工，数据会保存，但关联关系不会维护。即外键字段为 NULL。 获取数据无 解除关联关系？有影响。 inverse = false，可以解除关联 inverse = true，当前方（部门）没有控制权，不能解除关联关系（不会生成 update 语句，也不会报错）。 删除数据对关联关系的影响？有影响。 inverse=false，有控制权。可以删除。先清空外键引用，再删除数据。 inverse=true，没有控制权。如果删除的记录有被外键引用，会报错，违反主外键引用约束！如果删除的记录没有被引用，可以直接删除。 152. 介绍一下 Hibernate 的二级缓存 按照以下思路来回答：（1）首先说清楚什么是缓存，（2）再说有了 Hibernate 的 Session 就是一级缓存，即有了一级缓存，为什么还要有二级缓存，（3）最后再说如何配置 Hibernate 的二级缓存。 （1）缓存就是把以前从数据库中查询出来和使用过的对象保存在内存中（一个数据结构中），这个数据结构通常是或类似 Hashmap，当以后要使用某个对象时，先查询缓存中是否有这个对象，如果有则使用缓存中的对象，如果没有则去查询数据库，并将查询出来的对象保存在缓存中，以便下次使用。下面是缓存的伪代码： 引出 Hibernate 的第二级缓存，用下面的伪代码分析了 Cache 的实现原理： 123456789101112131415161718192021222324252627282930313233343536Dao{ hashmap map = new map(); User getUser(integer id) { User user = map.get(id) if(user == null) { user = session.get(id); map.put(id,user); } return user; }}Dao{Cache cache = null setCache(Cache cache) { this.cache = cache } User getUser(int id) { if(cache!=null) { User user = cache.get(id); if(user ==null) { user = session.get(id); cache.put(id,user); } return user; } return session.get(id); }} （2）Hibernate 的 Session 就是一种缓存，我们通常将之称为 Hibernate 的一级缓存，当想使用 session 从数据库中查询出一个对象时，Session 也是先从自己内部查看是否存在这个对象，存在则直接返回，不存在才去访问数据库，并将查询的结果保存在自己内部。由于 Session 代表一次会话过程，一个 Session 与一个数据库连接相关连，所以 Session 最好不要长时间保持打开，通常仅用于一个事务当中，在事务结束时就应关闭。并且 Session 是线程不安全的，被多个线程共享时容易出现问题。通常只有那种全局意义上的缓存才是真正的缓存应用，才有较大的缓存价值，因此，Hibernate 的 Session 这一级缓存的缓存作用并不明显，应用价值不大。Hibernate 的二级缓存就是要为 Hibernate 配置一种全局缓存，让多个线程和多个事务都可以共享这个缓存。我们希望的是一个人使用过，其他人也可以使用，session 没有这种效果。 （3）二级 缓存是独立于 Hibernate 的软件部件，属于第三方的产品，多个厂商和组织都提供有缓存产品，例如，EHCache 和 OSCache 等等。在 Hibernate 中使用二级缓存，首先就要在 hibernate.cfg.xml 配置文件中配置使用哪个厂家的缓存产品，接着需要配置该缓存产品自己的配置文件，最后要配置 Hibernate 中的哪些实体对象要纳入到二级缓存的管理中。明白了二级缓存原理和有了这个思路后，很容易配置起 Hibernate 的二级缓存。扩展知识：一个 SessionFactory 可以关联一个二级缓存，也即一个二级缓存只能负责缓存一个数据库中的数据，当使用 Hibernate 的二级缓存后，注意不要有其他的应用或 SessionFactory 来更改当前数据库中的数据，这样缓存的数据就会与数据库中的实际数据不一致。 153. 简单的谈一下 Spring MVC 的工作流程。 enter image description here 流程 用户发送请求至前端控制器 DispatcherServlet。 DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。 处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器（如果有则生成）一并返回给 DispatcherServlet。 DispatcherServlet 调用 HandlerAdapter 处理器适配器。 HandlerAdapter 经过适配调用具体的处理器（Controller，也叫后端控制器）。 Controller 执行完成返回 ModelAndView。 HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。 DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。 ViewReslover 解析后返回具体 View。 DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。 DispatcherServlet 响应用户。 154. Spring MVC Framework 的特点。 它是基于组件技术的全部的应用对象，无论控制器和视图，还是业务对象之类的都是 Java 组件，并且和 Spring 提供的其他基础结构紧密集成。 不依赖于 Servlet API（目标虽是如此，但是在实现的时候确实是依赖于 Servlet 的）。 可以任意使用各种视图技术，而不仅仅局限于 JSP。 支持各种请求资源的映射策略。 它应是易于扩展的。 155. @ModelAttribute 如何使用？ 定义一个方法，该方法用来返回要填充到模型数据中的对象。 给该方法添加 @ModelAttribute 注解。 添加 @ModelAttribute 注解的方法，会在 Spring MVC 在调用任何一个业务方法之前被自动调用。 156. 说说你对自定义数据类型转换器的理解。 通过自定义数据类型转换器可以根据需求对 HTTP 请求中的参数进行解析，转换成需要的数据类型。具体操作是创建一个 Java 类，实现 org.springframework.core.convert.converter.Converter 接口，这样自定义的 Java 类就具备了转换数据的功能，然后在 convert 方法中完成转换的具体业务流程。 当服务器接收到一个请求之后，Spring MVC 首先将请求分发到数据类型转换器进行格式转换，然后再进入相应的业务方法。 157. 什么是 MyBatis 的接口绑定，有什么好处？ 接口映射就是在 IBatis 中任意定义接口, 然后把接口里面的方法和 SQL 语句绑定，我们直接调用接口方法就可以，这样比起原来了 SqlSession 提供的方法我们可以有更加灵活的选择和设置。 158. 接口绑定有几种实现方式, 分别是怎么实现的？ 接口绑定有两种实现方式，一种是通过注解绑定，就是在接口的方法上面加上 @Select@Update 等注解里面包含 Sql 语句来绑定，另外一种就是通过 xml 里面写 SQL 来绑定，在这种情况下，要指定 xml 映射文件里面的 namespace 必须为接口的全路径名。 159. MyBatis 实现一对一有几种方式，具体怎么操作的？ 有联合查询和嵌套查询，联合查询是几个表联合查询，只查询一次，通过在 resultMap 里面配置 association 节点配置一对一的类就可以完成； 嵌套查询是先查一个表，根据这个表里面的结果的外键 id，去再另外一个表里面查询数据，也是通过 association 配置，但另外一个表的查询通过 select 属性配置。 160. MyBatis 实现一对多有几种方式，怎么操作的？ 有联合查询和嵌套查询, 联合查询是几个表联合查询, 只查询一次, 通过在 resultMap 里面配置 collection 节点配置一对多的类就可以完成; 嵌套查询是先查一个表, 根据这个表里面的结果的外键 id，去再另外一个表里面查询数据, 也是通过配置 collection，但另外一个表的查询通过 select 节点配置。 161. MyBatis 里面的动态 Sql 是怎么设定的？用什么语法？ MyBatis 里面的动态 Sql 一般是通过 if 节点来实现, 通过 OGNL 语法来实现, 但是如果要写的完整, 必须配合 where,trim 节点, where 节点是判断包含节点有内容就插入 where, 否则不插入, trim 节点是用来判断如果动态语句是以 and 或 or 开始, 那么会自动把这个 and 或者 or 取掉。 162. JDO 是什么? JDO 是 Java 对象 持久化 的新的规范，为 java data object 的简称, 也是一个用于存取某种数据仓库中的对象的标准化 API。JDO 提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如 JDBC API 的使用）。这些繁琐的例行工作已经转移到 JDO 产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO 很灵活，因为它可以在任何数据底层上运行。JDBC 只是面向关系数据库（RDBMS）JDO 更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML 以及对象数据库（ODBMS）等等，使得应用可移植性更强。 应用程序的开发人员通过访问 JDO Instance , 达到访问 JDO Instance 所代表的数据对象, 包括: ERP，数据库系统等. 使数据的存储介质对于应用的开发人员完全透明。 JDO 最早是由 Sun 召集众多的** O/R Mappin**g 开发团队集中起来共同提出的，首先是通过会议确定了 JDO 需要包括的内容，然后正式提出一个 Java 规范请求（JSR-12），正式开始了 JDO 规范的制定。 163. Spring、Spring Boot 和 Spring Cloud 的关系。 Spring Boot 是在Spring生态基础上面发展而来，发明 Spring Boot是为了简化Spring的开发。所以说没有 Spring 作为基础，就不会有Spring Boot，Spring Boot 使用约定优于配置的理念，重新重构了 Spring 的使用，让 Spring 后续的发展更有生命力。 Spring Cloud 是一系列框架的有序集合，它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发。服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。为了解决微服务架构中服务治理而提供的具备一系列功能的开发框架，并且 Spring Cloud 是完全基于 Spring Boot 而开发，Spring Cloud 利用 Spring Boot 特性整合了开源行业中优秀的组件，整体对外提供了一套在微服务架构中服务治理的解决方案。 164. 什么是数据校验？ 应用程序必须通过某种手段来确保输入进来的数据从语义上来讲是正确的。在 Java 应用程序中，必须要对输入进来的数据从语义上分析是有效的，也就是数据校验。 输入验证是最重要的 Web 开发任务之一，在 Spring MVC 中有两种方式可以验证输入：一种是 Spring 自带的验证框架，另外一种是利用 JSR 实现。 JSR 是一个规范文档，指定了一整套 API，通过标注给对象属性添加约束。Hibernate Validator 就是 JSR 规范的具体实现，Hibernate Validator 提供了 JSR 规范中所有内置约束注解的实现，以及一些附加的约束注解，除此之外用户还可以自定义约束注解。 Spring Boot 的参数校验依赖于 hibernate-validator 来进行。使用 Hibernate Validator 校验数据，需要定义一个接收的数据模型，使用注解的形式描述字段校验的规则。 165. Thymeleaf 特点。 Thymeleaf 是一个可以完全替代 JSP的模版。与其他的模板引擎相比较，它有如下三个特点。 Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 HTML 原型，然后在 HTML 标签里增加额外的属性来达到模板 + 数据的展示方式。浏览器解释 HTML 时会忽略未定义的标签属性，所以 Thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 Thymeleaf 开箱即用的特性。它支持标准方言和 Spring 方言，可以直接套用模板实现 JSTL、 OGNL 表达式效果，避免每天套模板、改 JSTL、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 Thymeleaf 提供 Spring 标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速地实现表单绑定、属性编辑器、国际化等功能。 166. 什么是 Druid？ Druid 是阿里巴巴开源平台上的一个项目，整个项目由数据库连接池、插件框架和 SQL 解析器组成，该项目主要是为了扩展 JDBC 的一些限制，可以让程序员实现一些特殊的需求，比如向密钥服务请求凭证、统计 SQL 信息、SQL 性能收集、SQL 注入检查、SQL 翻译等，程序员可以通过定制来实现自己需要的功能。 Druid 首先是一个数据库连接池，但它不仅仅是一个数据库连接池，还包含了一个 ProxyDriver，一系列内置的 JDBC 组件库，一个 SQL Parser。在 Java 的世界中 Druid 是监控做的最好的数据库连接池。 167. Druid 有什么作用？ 替换其他 Java 连接池，Druid 提供了一个高效、功能强大、可扩展性好的数据库连接池。 可以监控数据库访问性能，Druid 内置提供了一个功能强大的 StatFilter 插件，能够详细统计 SQL 的执行性能，这对于线上分析数据库访问性能有很大帮助。 数据库密码加密。直接把数据库密码写在配置文件中，这是不好的行为，容易导致安全问题，DruidDruiver 和 DruidDataSource 都支持 PasswordCallback。 SQL 执行日志，Druid 提供了不同的 LogFilter，能够支持 Common-Logging、Log4j 和 JdkLog，可以按需要选择相应的 LogFilter，监控应用的数据库访问情况。 扩展 JDBC，如果你要对 JDBC 层有编程的需求，可以通过 Druid 提供的 Filter 机制，很方便编写 JDBC 层的扩展插件。 168. 什么是 Spring Data JPA？ JPA（Java Persistence API）是 Sun 官方提出的 Java 持久化规范。它为 Java 开发人员提供了一种对象 / 关联映射工具来管理 Java 应用中的关系数据。它的出现主要是为了简化现有的持久化开发工作和整合 ORM 技术，结束现在 Hibernate、TopLink、JDO 等 ORM 框架各自为营的局面。JPA 是在充分吸收了现有的 Hibernate、TopLink、JDO 等 ORM 框架的基础上发展而来的，具有易于使用、伸缩性强等优点。 Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套 JPA 应用框架，可以让开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增、删、改、查等在内的常用功能，且易于扩展，学习并使用 Spring Data JPA 可以极大提高开发效率。Spring Data JPA 其实就是 Spring 基于 Hibernate 之上构建的 JPA 使用解决方案，方便在 Spring Boot 项目中使用 JPA 技术。 Linux LINUX 下线程、GDI 类的解释。 LINUX 实现的就是基于核心轻量级进程的”一对一”线程模型，一个线程实体对应一个核心轻量级进程，而线程之间的管理在核外函数库中实现。 GDI 类为图像设备编程接口类库。 170. 绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？ 绝对路径： 如/etc/init.d 当前目录和上层目录： ./ ../ 主目录： ~/ 切换目录： cd 171. 怎么查看当前进程？怎么执行退出？怎么查看当前路径？* 查看当前进程： ps 执行退出： exit 查看当前路径： pwd 172. 怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户 id？查看指定帮助用什么命令？* 清屏： clear 退出当前命令： ctrl+c 彻底退出 执行睡眠 ： ctrl+z 挂起当前进程 fg 恢复后台 查看当前用户 id： ”id“：查看显示目前登陆账户的 uid 和 gid 及所属分组及用户名 查看指定帮助： 如 man adduser 这个很全 而且有例子； adduser –help 这个告诉你一些常用参数； info adduesr； 173. Ls 命令执行什么功能？ 可以带哪些参数，有什么区别？* ls 执行的功能： 列出指定目录中的目录，以及文件。 哪些参数以及区别： a 所有文件 l 详细信息，包括大小字节数，可读可写可执行的权限等。 174. 建立软链接（快捷方式），以及硬链接的命令。* 软链接： ln -s slink source 硬链接： ln link source 175. 目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？* 123456789101112创建目录： mkdir创建文件：典型的如 touch，vi 也可以创建文件，其实只要向一个不存在的文件输出，都会创建文件复制文件： cp 7. 文件权限修改用什么命令？格式是怎么样的？文件权限修改： chmod格式如下：$ chmod u+x file 给 file 的属主增加执行权限$ chmod 751 file 给 file 的属主分配读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限$ chmod u=rwx,g=rx,o=x file 上例的另一种形式$ chmod =r file 为所有用户分配读权限$ chmod 444 file 同上例$ chmod a-wx,a+r file 同上例$ chmod -R u+r directory 递归地给 directory 目录下所有文件和子目录的属主分配读的权限 176. 查看文件内容有哪些命令可以使用？ vi 文件名 ＃编辑方式查看，可修改 cat 文件名 ＃显示全部文件内容 more 文件名 ＃分页显示文件内容 less 文件名 ＃与 more 相似，更好的是可以往前翻页 tail 文件名 ＃仅查看尾部，还可以指定行数 head 文件名 ＃仅查看头部,还可以指定行数 177. Linux 下命令有哪几种可使用的通配符？分别代表什么含义？* “?”可替代单个字符。 “*”可替代任意多个字符。 方括号“[charset]”可替代 charset 集中的任何单个字符，如 [a-z]、[abABC] 178. Grep 命令有什么用？ 如何忽略大小写？ 如何查找不含该串的行？* 是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 1grep [stringSTRING] filename grep [^string] filename 179. Linux 中进程有哪几种状态？在 ps 显示出来的信息中，分别用什么符号表示的？ 不可中断状态：进程处于睡眠状态，但是此刻进程是不可中断的。不可中断， 指进程不响应异步信号。 暂停状态/跟踪状态：向进程发送一个 SIGSTOP 信号，它就会因响应该信号 而进入 TASK STOPPED 状态;当进程正在被跟踪时，它处于 TASK TRACED 这个特殊的状态。 “正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。 就绪状态：在 run_queue 队列里的状态。 运行状态：在 run_queue 队列里的状态。 可中断睡眠状态：处于这个状态的进程因为等待某某事件的发生（比如等待 socket 连接、等待信号量），而被挂起。 zombie 状态（僵尸）：父亲没有通过 wait 系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。 退出状态。 D 不可中断 Uninterruptible（usually IO） R正在运行，或在队列中的进程 S处于休眠状态 T停止或被追踪 Z 僵尸进程 W 进入内存交换（从内核 2.6 开始无效） X死掉的进程 180. 把后台任务调到前台执行使用什么命令?把停下的后台任务在后台执行起来用什么命令？* fg。例如： 12345# jobs[1]+ Running /root/bin/rsync.sh &amp;# fg 1 bg 类似 181. 查看当前谁在使用该主机用什么命令? 查找自己所在的终端信息用什么命令? w：用户名称；用户的机器名称或 tty 号；远程主机地址；用户登录系统的时间；空闲时间（作用不大）;附加到 tty（终端）的进程所用的时间（JCPU 时间）；当前进程所用时间（PCPU时间）；用户当前正在使用的命令。 who：用户名、tty 号、时间日期、主机地址。 whoami,id -un：命令用于显示登入的用户名。 last：命令可用于显示特定用户登录系统的历史记录（last jason）；用户名称；tty 设备号；历史登录时间日期；登出时间日期；总工作时间。 查找自己所在终端信息：who am i。 182. 通过什么命令指定命令提示符？* \\u 显示当前用户账号 \\h 显示当前主机名 \\W 只显示当前路径最后一个目录 \\w 显示当前绝对路径（当前用户目录会以 ~代替） $PWD 显示当前全路径 \\$ 显示命令行 ’$’ 或者 ’#’ 符号 # ：下达的第几个命令 \\d：代表日期，格式为 weekday month date，例如：”Mon Aug 1” \\t：显示时间为 24 小时格式，如：HH：MM：SS \\T ：显示时间为 12 小时格式 \\A ：显示时间为 24 小时格式：HH：MM \\v ：BASH 的版本信息，如 export PS1=’[\\u@\\h \\w\\#]\\$‘ 183. du 和 df 的定义，以及区别？ du 显示目录或文件的大小。* df 显示每个&lt;文件&gt;所在的文件系统的信息，默认是显示所有文件系统。 （文件系统分配其中的一些磁盘块用来记录它自身的一些数据，如 i 节点，磁盘分布图，间接块，超级块等。 这些数据对大多数用户级的程序来说是不可见的，通常称为 Meta Data。） du 命令是用户级的程序，它不考虑 Meta Data，而 df 命令则查看文件系统的磁盘分配 图并考虑 Meta Data。 df 命令获得真正的文件系统数据，而 du 命令只查看文件系统的部分情况。 184. AWK 详解。 12345awk '{pattern + action}' {filenames} \\#cat /etc/passwd |awk -F ':' '{print $1&quot;\\t&quot;$7}' //-F 的意思是以':'分隔 root /bin/bash daemon /bin/sh 搜索/etc/passwd 有 root 关键字的所有行\\#awk -F: '/root/' /etc/passwd root:x:0:0:root:/root:/bin/bash 软件工程与设计模式185. UML 方面。 标准建模语言 UML。用例图、静态图（包括类图、对象图和包图)、行为图、交互图（顺序图、合作图）、实现图。 186. J2EE 常用的设计模式？说明工厂模式。 总共 23 种，分为三大类：创建型、结构型、行为型。我只记得其中常用的 6、7 种，分别是：创建型（工厂、工厂方法、抽象工厂、单例），结构型（包装、适配器、组合、代理），行为（观察者，模版，策略），然后再针对你熟悉的模式谈谈你的理解即可。 Java 中的 23 种设计模式： Factory（工厂模式） Builder（建造模式） Factory Method（工厂方法模式） Prototype（原始模型模式） Singleton（单例模式） Facade（门面模式） Adapter（适配器模式） Bridge（桥梁模式） Composite（合成模式） Decorator（装饰模式） Flyweight（享元模式） Proxy（代理模式） Command（命令模式） Interpreter（解释器模式） Visitor（访问者模式） Iterator（迭代子模式） Mediator（调停者模式） Memento（备忘录模式） Observer（观察者模式） State（状态模式） Strategy（策略模式） Template Method（模板方法模式） Chain Of Responsibleity（责任链模式） 工厂模式：工厂模式是一种经常被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。 187. 开发中都用到了那些设计模式?用在什么场合？ 每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。主要用到了 MVC 的设计模式。用来开发 JSP/Servlet 或者 J2EE 的相关应用。简单工厂模式等。 Web Service188. Web Service 名词解释，JSWDL 开发包的介绍，JAXP、JAXM 的解释，SOAP、UDDI、WSDL 解释。 Web ServiceWeb Service 是基于网络的、分布式的模块化组件，它执行特定的任务，遵守具体的技术规范，这些规范使得Web Service能与其他兼容的组件进行互操作。 JAXP（Java API for XML Parsing）定义了在 Java 中使用 DOM、SAX、XSLT 的通用的接口。这样在你的程序中你只要使用这些通用的接口，当你需要改变具体的实现时候也不需要修改代码。 JAXM（Java API for XML Messaging） 是为 SOAP 通信提供访问方法和传输机制的 API。 WSDL 是一种 XML 格式，用于将网络服务描述为一组端点，这些端点对包含面向文档信息或面向过程信息的消息进行操作。这种格式首先对操作和消息进行抽象描述，然后将其绑定到具体的网络协议和消息格式上以定义端点。相关的具体端点即组合成为抽象端点（服务）。 SOAP 即简单对象访问协议（Simple Object Access Protocol），它是用于交换 XML 编码信息的轻量级协议。 UDDI 的目的是为电子商务建立标准；UDDI 是一套基于 Web 的、分布式的、为 Web Service 提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的 Web Service 注册，以使别的企业能够发现的访问协议的实现标准。 189. CORBA 是什么？用途是什么？ CORBA 标准是公共对象请求代理结构（Common Object Request Broker Architecture），由对象管理组织（Object Management Group，缩写为 OMG）标准化。它的组成是接口定义语言（IDL），语言绑定（binding 也译为联编）和允许应用程序间互操作的协议。 其目的为：用不同的程序设计语言书写在不同的进程中运行，为不同的操作系统开发。 190、JSWDL 开发包的介绍。 JAXP （Java API for XML Parsing）：定义了在 Java 中使⽤ DOM、SAX、XSLT 的通⽤的接⼝。 JAXM （Java API for XML Messaging）：是为 SOAP 通信提供访问方法和传输机制的 API。 SOAP ：简单对象访问协议（Simple Object Access Protocol），它是用于交换 XML 编码信息的轻量级协议。 UDDI ：基于 Web 的、分布式的、为 Web Service 提供的、信息注册中心的实现标准规范 。 WSDL ：是一种 XML 格式，⽤于将⽹络服务描述为一组端点，这些端点对包含面向文档信息或⾯向过程信息的消息进⾏操作。答题技巧 回答问题的思路：先正面叙述一些 基本的核心知识 ，然后描述一些 特殊的东西 ，最后再来一些 锦上添花的东西 。要注意有些不是锦上添花，而是画蛇添足的东西，不要随便写上。把答题像写书一样写。我要回答一个新技术的问题大概思路和步骤是：我们想干什么，怎么干，干的过程中遇到了什么问题，现在用什么方式来解决。其实我们讲课也是这样一个思路。 例如，讲 AJAX 时，我们希望不改变原来的整个网页，而只是改变网页中的局部内容，如用户名校验、级联下拉列表、下拉树状菜单。用传统方式，就是浏览器自己直接向服务器发请求，服务器返回新页面会盖掉老页面，这样就不流畅了。 答题时，先答是什么，再答有什么作用和要注意什么（这部分最重要，展现自己的心得）。 答案的段落分别，层次分明，条理清晰都非常重要，从这些表面的东西也可以看出一个人的习惯、办事风格、条理等。 要讲你做出答案的思路过程，或者说你记住答案的思想都写下来。把答题想着是辩论赛。答题就是给别人讲道理、摆事实。答题不局限于什么格式和形式，就是要将自己的学识展现出来！ 别因为人家题目本来就模棱两可，你就心里胆怯和没底气了，不敢回答了。你要大胆地指出对方题目很模糊和你的观点，不要把面试官想得有多高，其实他和你就是差不多的，你想想，如果他把你招进去了，你们以后就是同事了，可不是差不多的吗？ 关于就业薪水，如果你是应届生，那不能要高工资，好比大饼的故事，没有文凭还想拿高工资，就去中关村缺什么补什么吧！少数人基础确实很好，在校期间确实又做过一些项目，那仍然是可以要到相对高的工资的。 公司招聘程序员更看重的要用到的编码技术、而不是那些业务不太相关的所谓项目经历。 公司想招什么样的； 公司面试会问什么； 简历怎么写； 怎样达到简历上的标准（培训中心教项目的目的）。 对于一些公司接到了一些项目，想招聘一些初中级的程序员过来帮助写代码，完成这个项目，你更看重的是他的专业技术功底，还是以前做过几个项目的经历呢？我们先排除掉那些编码技术功底好，又正好做过相似项目的情况，实际上，这种鱼和熊掌兼得的情况并不常见。 其实公司很清楚，只要招聘进来的人技术真的很明白，那他什么项目都可以做出来，公司招人不是让你去重复做你以前的项目，而是做一个新项目，业务方面，你只要进了项目团队，自然就能掌握。所以，大多数招聘单位在招聘那些编码级别的程序员时也没指望能招聘到做过类似项目的人，也不会刻意去找做过类似项目的人，用人单位也不是想把你招进，然后把你以前做过的项目重做一遍。 所以，用人单位更看重招进来的人对要用到的编码技术的功底到底怎样，技术扎实不扎实，项目则只要跟着开发团队走，自然就没问题。除非是一些非常专业的行业，要招聘特别高级的开发人员和系统分析师，招聘单位才特别注重他的项目经验和行业经验，要去找到行业高手，公司才关心项目和与你聊项目的细节，这样的人通常都不是通过常规招聘渠道去招聘进来的，而是通过各种手段挖过来的，这情况不再我今天要讨论的范围中。 技术学得明白不明白，人家几个问题就把你的深浅问出来了，只要问一些具体的技术点，就很容易看出你是真懂还是假懂，很容看出你的技术深度和实力，所以，技术是来不得半点虚假的，必须扎扎实实。 由于项目的种类繁多，涉及到现实生活中的各行各业，什么五花八门的业务都有，例如，酒店房间预定管理，公司车辆调度管理，学校课程教室管理，超市进销存管理，知识内容管理，等等……成千上万等等，但是，不管是什么项目，采用的无非都是我们学习的那些目前流行和常用的技术。 技术好、经验丰富，则项目做出来的效率高些，程序更稳定和更容易维护些；技术差点，碰碰磕磕最后也能把项目做出来，无非是做的周期长点、返工的次数多点，程序代码写得差些，用的技术笨拙点。如果一个人不是完完全全做过某个项目，他是不太关心该项目的业务的，对其中的一些具体细节更是一窍不知（如果我招你来做图书管理，你项目经历说你做过汽车调度，那我能问你汽车调度具体怎么回事吗？不会，所以，你很容易蒙混过去的）。 而一个程序员的整个职业生涯中能实实在在和完完整整做出来的项目没几个，更别说在多个不同行业的项目了，有的程序员更是一辈子都只是在做某一个行业的项目，结果他就成了这个行业的专家（专门干一件事的家伙）。所以，技术面试官通常没正好亲身经历过你简历写的那些项目，他不可能去问你写的那些项目的具体细节，而是只能泛泛地问你这个项目是多少人做的，做了多长时间，开发的过程，你在做项目的过程中有什么心得和收获，用的什么技术等面上的问题，所以，简历上的项目经历可以含有很多水分，很容易作假，技术面试官也无法在项目上甄别你的真伪。 简历该怎么写： 精通那些技术，有一些什么项目经历 讲的项目应该真实可靠才有价值，否则，表面上是项目，实际上还是知识点的整合，对巩固技术点和增强学习的趣味性，但无法获得实际的项目经验。（项目主要是增加你经验的可信度，获得更多面试机会，真正能不能找到工作，找到好工作，主要看你键盘上的功夫了），好的面试官几下就能面出你是否真有工作经验，他们问技术以外的公司的人和事，并且问开始、过程、结果，看你怎么编。 建议大家尽量开自己的 blog，坚持每天写技术 blog。在简历上写上自己的 blog 地址，可以多转载一些技术文章。 人事问题191. 请讲一下这样一个经历：尽管其他人反对，但是你还是坚持自己的观点，并把事情继续做下去。 【思路】从自己积极方面回答，比如家人和老师都希望我报考会计专业，而我对会计就是不感兴趣，毅然选择了计算机专业。我现在毕业，专业技能很强，而且有自己成熟的作品，计算机是我的事业，将继续做下去。 192. 你的一位领导脾气比较急，批评下属时常常不留情面，大家的工作情绪经常受到影响。作为职员，你该怎么办？ 【思路】首先对领导的批评应该认真接受，不能因为领导严厉的批评而产生逆反心理，以致影响工作； 其次可以私下找机会和领导沟通，向领导反映下属因此产生的意见和情绪，婉转地说明这种情绪可能会影响工作的正常开展，至于是否接受建议、改变方法，由领导自己决定。 193. 与上级意见不一是，你将怎么办？ 正确回答：首先呢，作为一个员工我的是不会和上级产生争执的，如果真有意见不一致的时候，我想我会服从领导安排的。 【思路】 一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。” 如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。” 194. 你是应届毕业生，缺乏经验，如何能胜任这项工作？ 正确回答：作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。 【思路】 如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘单位并不真正在乎“经验”，关键看应聘者怎样回答。 对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。 195. 你为什么觉得自己能够在这个职位上取得成就？ 正确回答： 从我的经历来看，这是我的职业生涯中最适合我的一份工作。几年来，我一直在研究这个领域并且关注贵公司，一直希望能有这样的面试机会。我拥有必备的技能（简单讲述一个故事来加以说明），我非常适合这一职位，也确实能做好这份工作。 【思路】这是一个相当宽泛的问题，它给求职者提供了一个机会，可以让求职者表明自己的热情和挑战欲。对这个问题的回答将为面试人在判断求职者是否对这个职位有足够的动力和自信心方面提供关键信息。 196. 你希望 5 年后达到什么成就？ A. 做一天和尚敲一天钟，尽人事听天命、顺其自然。 B. 依我的机灵及才干，晋升到部门经理是我的中期目标。 C. 自己独当一面开公司。 D. “全力以赴”是我的座右铭，希望能随着经验的增加，被赋予更多的职责及挑战。 解答：最理想的回答是 D。 197. 5 年之内你想处于什么位置？ 正确回答：我希望有机会在工厂或国内办事处工作。我也希望通过管理一个小团体发展我的管理技能。 【思路】不要给出具体的时限或工作头衔。谈你喜欢的东西，你天生的技能，实际的问题和在你所选的领域或行业里你希望有什么机会，你希望从那些经验中学点什么。不要谈论你在那些与你所应聘的工作无关的领域或行业里的目标。这是听起来很明显的道理，但是很多求职者会犯这个错误。不经意间你就表现出了对当前的领域或行业缺乏真正的兴趣。不用说，一失言马上就会把你从进一步的考虑中淘汰掉。 198. 如果你有无限的时间和经济来源，你会怎样使用它们呢？ 正确回答：我希望能参加几次不针对金融专家的有关金融管理的行政研讨会。我还希望能让我的部门放长假，把每一个人都派去参加外界的一些活动。最后，我很可能去旅游并考察一下外国竞争者，同时一路享受当地的美食，您呢？ 【思路】虽然娱乐的事情谈起来很有诱惑力，但一定要紧扣工作或与行业相关的事务，或者紧扣与你应聘的这份工作的技能相关的努力上。例如，你正在应聘教书工作，你可能对义务教授成年人读书识字的项目感兴趣。这就证明了你对自己的工作领域的激情，即对教育重要性的一种信仰，即使是作为一种兴趣而毫无报酬都无所谓。 199. 假如现在是你在我们公司做首次年度总结，我该告诉你一些什么呢？ 正确回答：您要感谢我把工作完成得很好，并说明您渴望能够继续看到我工作的好成绩。更重要的是，我希望您能告诉我，您很欣赏我为一些重要项目加班加点工作的行为，还有我富有创造性的思维是如何有助于对存在的问题提出改革方案的。 【思路】很明显，在回答该问题时，你想给人留下积极的印象。“但愿您能更准时地出现”绝对不是一个好答案。记住，重点谈一两点你个人的优势。 200. 为什么你想在这里工作？ 正确回答：我几年前就错过了你们公司的一次招标，之后我意识到电脑产品变得越来越相近了，且零售价格的竞争愈趋激烈，以致服务成为了一家公司在竞争中脱颖而出的最好的方法。贵公司在所有的竞争者中享有最好的服务记录，而我相信从长远看，它将主宰这个行业。你的准备和调查研究工作应在这里明显表现出来。 【思路】给出一到两个你对该公司感兴趣的原因，并表明什么最激发你的兴趣。什么是你可以叙述来表明你个人对该公司的认识的最有说服力的事情呢？它的产品还是它的员工？答案包括公司的信誉、对该工作本身的描述，或者是跻身于该企业的欲望。 201. 你对加班的看法。 正确回答：首先我想确认下，是何种性质的加班？ 如果是我个人的工作量是在规定的时间内没有完成的话，这种情况是不会发生的，我是个注重工作效率的人。其次如果是公司业务量临时增加的话，我会接受加班。 【思路】首先，明确的告诉对方，如果是因为自己在规定的时间内没有完成工作任务的话 ，需要加班的情况是几乎不可能出现的，“我是个注重工作效率的人”其次，如果是因为公司业务情况或者其他的一些紧急工作的话是可以适应加班的。 202. 你能给公司带来什么？ 【思路】一般外企很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后说：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。外企喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。”等等。 203. 你认为你在学校属于好学生吗？ 【思路】企业的招聘者很精明，问这个问题可以试探出很多问题：如果求职者学习成绩好，就会说：“是的，我的成绩很好，所有的成绩都很优异。当然，判断一个学生是不是好学生有很多标准，在学校期间我认为成绩是重要的，其他方面包括思想道德、实践经验、团队精神、沟通能力也都是很重要的，我在这些方面也做得很好，应该说我是一个全面发展的学生。”如果求职者成绩不尽理想，便会说：“我认为是不是一个好学生的标准是多元化的，我的学习成绩还可以，在其他方面我的表现也很突出，比如我去很多地方实习过，我很喜欢在快节奏和压力下工作，我在学生会组织过××活动，锻炼了我的团队合作精神和组织能力。” 有经验的招聘者一听就会明白，企业喜欢诚实的求职者。 204. 有人说“成功是对人有益的”，也有人说“失败是对人有益的”，你怎么看？ 【思路】成功是对努力的一种回报，一种肯定，能使人们认识到自身的价值，对自身是一种动力，能激发人们继续创新、学习的勇气！当然，成功是对人有益的。 “失败是对人有益的”，俗话说“失败乃成功之母”，它给予人们更多的是经验与坚韧顽强的精神和永不认输的斗志，所以说“失败是对人有益的”。 这类题的应对方法：辩证地看、联系地看，肯定一方但不否定另一方，两者是有机的统一。 205. 如果我们单位录用了你，但工作一段时间却发现你根本不适合这个职位你怎么办？ 【思路】一段时间发现工作不适合我，有两种情况： 如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距； 你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。 206. 你最大的长处和弱点分别是什么？这些长处和弱点对你在企业的业绩会有什么样的影响？ 【思路】这个问题的最大陷阱在于，第一个问题实际上是两个问题，而且还要加上一个后续问题。这两个问题的陷阱并不在于你是否能认真地看待自己的长处，也不在于你是否能正确认识自己的弱点。记住，你的回答不仅是向面试人说明你的优势和劣势，也能在总体上表现你的价值观和对自身价值的看法。 长处来说，我相信我最大的优点是我有一个高度理性的头脑，能够从混乱中整理出头绪来。我最大的弱点是，对那些没有秩序感的人，可能缺乏足够的耐心。我相信我的组织才能可以帮助企业更快地实现目标，而且有时候，我处理复杂问题的能力也能影响我的同事。 207. 除了工资，还有什么福利最吸引你？ 【思路】尽可能诚实，如果你做足了功课，你就知道他们会提供什么，回答尽可能和他们提供的相配。如果你觉得自己该得到更多，也可以多要一点。 208. 有人说，善意的谎言是对的，你如何看？ 【思路】这个问题不能一概而论的， 它仅仅动机是善意的， 但是造成的后果好不好呢， 如果反而引起更大的伤害， 那么就得不偿失了；其次是对象，如果对象意志毅力很强，能够接受突如其来的打击，并且不喜欢别人骗他哪怕是善意的，那么善意的谎言便毫无意义，有时反而造成误会。但是善意的谎言在更多程度上都是对的可以接受的，它可以最大地减少不必要的痛苦，能够起到积极的作用。 209. 领导要你 4 天完成一件工作，突然要你 2 天完成，你该怎么办？ 【思路】 首先分析一下提前完成工作的可能性。 如果确定完不成的，那么去跟领导详谈，跟他讲道理摆事实，说明没法完成的理由。一定要有充足的理由，才能说服他。 如果可以完成，但是需要其他条件的配合的，那么找领导说明情况。请领导给于支持。 如果经过自己努力可以完成的，那么就努力完成吧。 210. 你认为这些年来同事对你怎么样？ 【思路】：面试官问这个问题的目的，主要想从你的同事对你的态度和评价上推测你这个人是什么样的，对于你来说回答这个问题要谨慎。比如：同事对我都很热心（从侧面反衬你对同事也很热心）；同事们有棘手的工作我会主动去帮助他们，所以我有事情的时候他们都来帮助我等等。 211. 向面试官提出的问题。 贵公司对这项职务的工作内容和期望目标为何？有没有什么部分是我可以努力的地方？ 贵公司是否有正式或非正式教育训练？ 贵公司的升迁管道如何？ 贵公司的多角化经营，而且在海内外都设有分公司，将来是否有外派、轮调的机会？ 贵公司能超越同业的最大利基点为何？ 贵公司强调的团队合作中，其它的成员素质和特性如何？ 能否为我介绍一下工作环境，或者是否有机会能参观一下贵公司？ 【思路】在面试结束前，大多数的主考官都会丢问题给求职者，最常见的就是：你有没有什么问题或疑问，想要提出来的？无论求职者是否有提出问题，其实，这个问题背后的真正含意，通常是主考官用来测试你对这份工作有多大的企图心、决心和热情。 因此，如果你害怕发问不妥当，或是不知道该从何问起，甚至回答没有问题时，都很可能会让主考官认为，你想要这份工作的企图心、决心还不够强。 相反地，求职者应该更积极、主动的利用面试最后一关的机会，适时的提出问题，这不但有助于主考官对你的印象能够加深，而且你也能趁此机会进一步了解这家公司的背景、企业文化是否适合你。 最重要的是，如果能够在面试时，提出漂亮的问题，录取的机率将会大大提高。所以，无论如何，前往面试前，先谨记10个可以反问主考官的问题，以便到时候可以提出。 至于薪水待遇、年假天数、年终奖金、福利措施等问题，有些公司的主考官在面试时，会直接向求职者提出。如果对方没有提及，对社会新鲜人来说，在找第一份工作时，比较不适合提出，除非你有对方不得不录取你的条件。另外，也有人在结束前，谦虚的请教主考官：您认为我今天的表现如何？录取的机率有多大？通常，这个问题也会让对方认为，你对这份工作抱有很大的决心和企图心，而你也可以试着从对方的回答中，约略猜测出自己成功的机率有多大，并且作为下一次面试时表现的参考！ 结束语非常感谢各位读者的支持，笔者水平有限，知识点上难免会有遗漏的地方，如果大家有更好的想法或者建议，欢迎留言。也可加我微信：nnsouthwind，进行更进一步的交流。 最后祝大家工作顺利，薪资翻倍，附上本文 PDF 资源的下载链接。 链接: https://pan.baidu.com/s/1jfVHaaXDMWYeNloGgG1-Dg 提取码: dnak 本文首发于 GitChat，未经授权不得转载，转载需与 GitChat 联系。 登录后订阅Chat24 3写评论向作者提问 One先不说别的，先来个赞2018年12月4日 11 1 宁楠: 感谢支持。 民很好的chat,首先从内容数量上就该点赞了。2018年12月4日 7 1 宁楠: 感谢支持。 Nono.c.Rook说拼凑来的 真的是不知道什么想法，在我看来这边文章就算是拼凑来的，但是只要有你不懂的，看这篇文章记住了的知识点就是不亏的，更何况还是大佬辛辛苦苦平时积累，总结的。5块钱，一张地铁票钱，可能你面试的时候就因为这里的一个点你记住了，能回答上面试官的某个问题了。所以你觉得亏吗？多点感恩，少点戾气吧。2018年12月5日 7 1 宁楠: 正能量满满，感谢支持。 快乐对我来说很好很有用，覆盖了我的知识漏洞，非常感谢作者，这么多内容光整理排版就很不容易，真不知道那些鸡蛋里挑骨头的人脑子都是咋想的。2018年12月5日 6 1 宁楠: 感谢支持，吸收对自己有用的就行了。 岁月静好整体来说不错，虽然知识点上有遗漏，但是一篇文章能汇总这么多内容，已经很好了。提个小建议，有些问题的答案篇幅过长，可以适当精简一下，感谢作者提供这么好的一份资料。至于说东拼西凑的那些人，呵呵，无论文章写的怎么样，总会有人挑毛病，众口难调，但是起码应该尊重别人的劳动成果，心怀感恩。2018年12月5日 6 1 宁楠: 建议收到，感谢。 安于她梦这从哪儿东拼西凑来的？2018年12月4日 3 1 宁楠: 收集自网络，书，日常工作等渠道。 四年很不错2018年12月5日 2 1 宁楠: 感谢支持。 木叶算法2018年12月5日 1 1 宁楠: 开篇就是算法。 一枝花算不算浪漫感觉是各种东拼西凑的东西。都什么年代了还有hibernate的面试题。2018年12月4日 0 3 谢工: 找有用的部分有选择的看看宁楠: 看你需要的，不需要的就直接忽略好么。别来无恙ζ: 我就用hibernate 有什么不好么 别来无恙ζ这份Chat最适合应聘什么职位的人来看2018年12月5日 0 1 宁楠: 无论哪个阶段的Java开发都能有所借鉴，每个人都有知识盲点。 @比较适合初学者2018年12月5日 0 1 宁楠: 对，初学者应该好好看看。 Nyx一般吧 跟预期有差距2018年12月1日 0 1 宁楠: 好的。 Mark感觉不值。2018年12月1日 0 1 宁楠: 211道题你认为多少钱值？ 杨丹好多都是面试宝典里的内容2018年12月3日 0 1 宁楠: 211道题，内容多了难免会有重叠。 别来无恙ζ看会了一半，会有人要嘛2018年12月3日 0 0 Safari43. switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上? JDK 1.7以后switch支持String类型了2018年12月4日 0 1 宁楠: 对，答案写错了，抱歉，感谢指正。 Emine第一题就明显不对。Pattern p2 = Pattern.compile(“\\d{6}(\\d{8}).*”);，只适合18位的身份证号。15位的身份证，日期一共就6位，要这么写Pattern.compile(“\\d{6}(\\d{6}).*”)7天前 0 0 鼎晟很棒 ^ _ ^😍1天前 0 0 × 文章评论0/200 提交 Chat免费订 课程随心学 好书每月领 专家畅快聊 成为会员 热门分类 前端人工智能架构区块链职场编程语言技术管理大数据移动开发产品与运营测试安全运维Chat 是什么？ 了解更多Chat 是一种全新的阅读/写作互动体验产品。一场 Chat 包含一篇文章和一场为该文章的读者和作者准备的专属线上交流。 关注 GitChat 微信公众号 获得 Chat 邀请 与作者实时互动 限时特惠不错过 创建一场 Chat 成为达人课作者 加入我们 | 常见问题 | 联系客服 Chat免费订 课程随心学 好书每月领 专家畅快聊 成为会员 热门分类 前端人工智能架构区块链职场编程语言技术管理大数据移动开发产品与运营测试安全运维 微信扫描登录 × 帐号设置头像选择头像 最佳分辨率：200*200像素 昵 称: 微信号: 头 衔: 背景介绍: 正在上传头像，请稍等……正在更新，请稍等……邮件地址格式不正确，请重新填写此邮件地址已经被其他用户使用 取消保存 ×Java 开发必备面试题详解（技术+人事） 请写下您的意见： 提交 提 示购买Chat后即可去读者圈向作者提问！ 去购买","link":"/2019/08/02/Java%20%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3%EF%BC%88%E6%8A%80%E6%9C%AF+%E4%BA%BA%E4%BA%8B%EF%BC%89/"}],"tags":[],"categories":[]}